<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Preguntas sobre Arquitectura de Soluciones</title>
    <style>
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
    </style>
</head>
<body>
    <h1>Preguntas sobre Arquitectura de Soluciones</h1>
    <table>
        <thead>
            <tr>
                <th>#</th>
                <th>Pregunta</th>
                <th>Respuesta Teórica</th>
                <th>Ejemplo de Código (Java)</th>
                <th>Ejemplo de Código (Python)</th>
                <th>Ejemplo de Código (C#)</th>
                <th>Ejemplo de Código (TypeScript)</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>1</td>
                <td>¿Qué es la arquitectura de software?</td>
                <td>La arquitectura de software es la estructura fundamental de un sistema, que define los componentes y sus relaciones.</td>
                <td><pre><code>public class AppConfig {
    private String dbUrl;
    private String dbUser;

    // Getters and Setters
}</code></pre></td>
                <td><pre><code>class AppConfig:
    def __init__(self, db_url: str, db_user: str):
        self.db_url = db_url
        self.db_user = db_user</code></pre></td>
                <td><pre><code>public class AppConfig
{
    public string DbUrl { get; set; }
    public string DbUser { get; set; }
}</code></pre></td>
                <td><pre><code>class AppConfig {
    dbUrl: string;
    dbUser: string;

    constructor(dbUrl: string, dbUser: string) {
        this.dbUrl = dbUrl;
        this.dbUser = dbUser;
    }
}</code></pre></td>
            </tr>
            <tr>
                <td>2</td>
                <td>¿Qué es un patrón arquitectónico?</td>
                <td>Un patrón arquitectónico es una solución general reutilizable para problemas comunes en un contexto dado.</td>
                <td><pre><code>// Example of Singleton pattern in Java
public class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}</code></pre></td>
                <td><pre><code>class Singleton:
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance</code></pre></td>
                <td><pre><code>public class Singleton
{
    private static Singleton _instance;

    private Singleton() { }

    public static Singleton Instance
    {
        get
        {
            if (_instance == null)
            {
                _instance = new Singleton();
            }
            return _instance;
        }
    }
}</code></pre></td>
                <td><pre><code>class Singleton {
    private static instance: Singleton;

    private constructor() {}

    public static getInstance(): Singleton {
        if (!Singleton.instance) {
            Singleton.instance = new Singleton();
        }
        return Singleton.instance;
    }
}</code></pre></td>
            </tr>
            <tr>
                <td>3</td>
                <td>¿Cómo se implementa la separación de responsabilidades?</td>
                <td>La separación de responsabilidades se implementa dividiendo el sistema en componentes o módulos con responsabilidades distintas.</td>
                <td><pre><code>// Java example
public class UserService {
    private UserRepository userRepository;

    public void registerUser(User user) {
        userRepository.save(user);
    }
}</code></pre></td>
                <td><pre><code>class UserService:
    def __init__(self, user_repository):
        self.user_repository = user_repository

    def register_user(self, user):
        self.user_repository.save(user)</code></pre></td>
                <td><pre><code>public class UserService
{
    private UserRepository _userRepository;

    public UserService(UserRepository userRepository)
    {
        _userRepository = userRepository;
    }

    public void RegisterUser(User user)
    {
        _userRepository.Save(user);
    }
}</code></pre></td>
                <td><pre><code>class UserService {
    private userRepository: UserRepository;

    constructor(userRepository: UserRepository) {
        this.userRepository = userRepository;
    }

    public registerUser(user: User): void {
        this.userRepository.save(user);
    }
}</code></pre></td>
            </tr>
            <tr>
                <td>4</td>
                <td>¿Qué es la escalabilidad en una arquitectura?</td>
                <td>La escalabilidad se refiere a la capacidad de un sistema para manejar un incremento en la carga de trabajo sin degradar su rendimiento.</td>
                <td><pre><code>// Java example
public class LoadBalancer {
    public void distributeLoad() {
        // Implementation for load balancing
    }
}</code></pre></td>
                <td><pre><code>class LoadBalancer:
    def distribute_load(self):
        # Implementation for load balancing
        pass</code></pre></td>
                <td><pre><code>public class LoadBalancer
{
    public void DistributeLoad()
    {
        // Implementation for load balancing
    }
}</code></pre></td>
                <td><pre><code>class LoadBalancer {
    public distributeLoad(): void {
        // Implementation for load balancing
    }
}</code></pre></td>
            </tr>
            <tr>
                <td>5</td>
                <td>¿Qué es una API REST?</td>
                <td>Una API REST es un tipo de interfaz de programación de aplicaciones que utiliza HTTP y está basada en el estilo de arquitectura REST para permitir la comunicación entre sistemas.</td>
                <td><pre><code>@RestController
public class ApiController {
    @GetMapping("/api/data")
    public ResponseEntity<Data> getData() {
        return ResponseEntity.ok(new Data());
    }
}</code></pre></td>
                <td><pre><code>from flask import Flask, jsonify

app = Flask(__name__)

@app.route('/api/data', methods=['GET'])
def get_data():
    return jsonify({"data": "value"})</code></pre></td>
                <td><pre><code>[ApiController]
public class ApiController : ControllerBase
{
    [HttpGet("/api/data")]
    public IActionResult GetData()
    {
        return Ok(new { data = "value" });
    }
}</code></pre></td>
                <td><pre><code>import { Request, Response } from 'express';
import express from 'express';

const app = express();

app.get('/api/data', (req: Request, res: Response) => {
    res.json({ data: 'value' });
});
</code></pre></td>
            </tr>
            <tr>
                <td>6</td>
                <td>¿Qué es la inyección de dependencias?</td>
                <td>La inyección de dependencias es un patrón de diseño que permite la creación de dependencias fuera de una clase y su inyección en la misma.</td>
                <td><pre><code>@Service
public class UserService {
    private final UserRepository userRepository;

    @Autowired
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}</code></pre></td>
                <td><pre><code>class UserService:
    def __init__(self, user_repository):
        self.user_repository = user_repository</code></pre></td>
                <td><pre><code>[Service]
public class UserService
{
    private readonly IUserRepository _userRepository;

    public UserService(IUserRepository userRepository)
    {
        _userRepository = userRepository;
    }
}</code></pre></td>
                <td><pre><code>import { Injectable } from '@angular/core';

@Injectable({
    providedIn: 'root'
})
export class UserService {
    constructor(private userRepository: UserRepository) {}
}</code></pre></td>
            </tr>
            <tr>
                <td>7</td>
                <td>¿Qué es un microservicio?</td>
                <td>Un microservicio es una arquitectura que divide una aplicación en servicios independientes y pequeños que se comunican a través de APIs.</td>
                <td><pre><code>@RestController
public class UserController {
    @GetMapping("/users")
    public List<User> getUsers() {
        return Arrays.asList(new User(), new User());
    }
}</code></pre></td>
                <td><pre><code>from flask import Flask, jsonify

app = Flask(__name__)

@app.route('/users', methods=['GET'])
def get_users():
    return jsonify([{"id": 1}, {"id": 2}])</code></pre></td>
                <td><pre><code>[ApiController]
public class UserController : ControllerBase
{
    [HttpGet("/users")]
    public IActionResult GetUsers()
    {
        return Ok(new[] { new User(), new User() });
    }
}</code></pre></td>
                <td><pre><code>import { Request, Response } from 'express';
import express from 'express';

const app = express();

app.get('/users', (req: Request, res: Response) => {
    res.json([{ id: 1 }, { id: 2 }]);
});
</code></pre></td>
            </tr>
            <tr>
                <td>8</td>
                <td>¿Cómo se maneja la consistencia de datos?</td>
                <td>La consistencia de datos se maneja asegurando que todas las transacciones mantengan el estado correcto y coherente en el sistema.</td>
                <td><pre><code>// Java example with transaction management
@Transactional
public void updateData() {
    // Perform database operations
}</code></pre></td>
                <td><pre><code>from sqlalchemy.orm import sessionmaker

Session = sessionmaker(bind=engine)
session = Session()

with session.begin():
    # Perform database operations
    pass</code></pre></td>
                <td><pre><code>[Transactional]
public void UpdateData()
{
    // Perform database operations
}</code></pre></td>
                <td><pre><code>import { Transaction } from 'sequelize';

async function updateData(transaction: Transaction) {
    // Perform database operations within a transaction
}</code></pre></td>
            </tr>
            <tr>
                <td>9</td>
                <td>¿Qué es una arquitectura de servicios?</td>
                <td>Una arquitectura de servicios se basa en la creación de servicios independientes que proporcionan funcionalidades específicas y se comunican a través de interfaces.</td>
                <td><pre><code>public interface UserService {
    User getUser(Long id);
}</code></pre></td>
                <td><pre><code>class UserService:
    def get_user(self, id: int):
        # Return user by id
        pass</code></pre></td>
                <td><pre><code>public interface IUserService
{
    User GetUser(long id);
}</code></pre></td>
                <td><pre><code>interface UserService {
    getUser(id: number): User;
}</code></pre></td>
            </tr>
            <tr>
                <td>10</td>
                <td>¿Cómo se gestiona la comunicación entre microservicios?</td>
                <td>La comunicación entre microservicios se puede gestionar mediante RESTful APIs, mensajes asíncronos o eventos.</td>
                <td><pre><code>// Java example with REST
RestTemplate restTemplate = new RestTemplate();
ResponseEntity<User> response = restTemplate.getForEntity("http://service-url/users/1", User.class);</code></pre></td>
                <td><pre><code>import requests

response = requests.get('http://service-url/users/1')
user = response.json()</code></pre></td>
                <td><pre><code>HttpClient client = new HttpClient();
HttpResponse response = await client.GetAsync("http://service-url/users/1");</code></pre></td>
                <td><pre><code>import axios from 'axios';

const response = await axios.get('http://service-url/users/1');
const user = response.data;</code></pre></td>
            </tr>
            <tr>
                <td>11</td>
                <td>¿Qué es el patrón de diseño MVC?</td>
                <td>El patrón de diseño MVC (Model-View-Controller) separa la aplicación en tres componentes: Modelo, Vista y Controlador, para mejorar la organización y mantenimiento.</td>
                <td><pre><code>// Java example
@Controller
public class UserController {
    @GetMapping("/users")
    public String listUsers(Model model) {
        model.addAttribute("users", userService.getAllUsers());
        return "userList";
    }
}</code></pre></td>
                <td><pre><code>@app.route('/users', methods=['GET'])
def list_users():
    users = get_all_users()
    return render_template('user_list.html', users=users)</code></pre></td>
                <td><pre><code>[Controller]
public class UserController : Controller
{
    [HttpGet("/users")]
    public IActionResult ListUsers()
    {
        var users = userService.GetAllUsers();
        return View("UserList", users);
    }
}</code></pre></td>
                <td><pre><code>import { Request, Response } from 'express';
import { render } from 'ejs';

app.get('/users', (req: Request, res: Response) => {
    const users = getAllUsers();
    res.render('userList', { users });
});
</code></pre></td>
            </tr>
            <tr>
                <td>12</td>
                <td>¿Qué es la tolerancia a fallos?</td>
                <td>La tolerancia a fallos es la capacidad de un sistema para continuar operando correctamente incluso cuando una o más de sus partes fallan.</td>
                <td><pre><code>// Java example with retry mechanism
public void performOperation() {
    int retries = 3;
    while (retries > 0) {
        try {
            // Perform operation
            break;
        } catch (Exception e) {
            retries--;
        }
    }
}</code></pre></td>
                <td><pre><code>import time

def perform_operation():
    retries = 3
    while retries > 0:
        try:
            # Perform operation
            break
        except Exception:
            retries -= 1
            time.sleep(1)</code></pre></td>
                <td><pre><code>public void PerformOperation()
{
    int retries = 3;
    while (retries > 0)
    {
        try
        {
            // Perform operation
            break;
        }
        catch (Exception)
        {
            retries--;
        }
    }
}</code></pre></td>
                <td><pre><code>async function performOperation() {
    let retries = 3;
    while (retries > 0) {
        try {
            // Perform operation
            break;
        } catch (error) {
            retries--;
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
    }
}</code></pre></td>
            </tr>
            <tr>
                <td>13</td>
                <td>¿Qué es la coherencia eventual?</td>
                <td>La coherencia eventual es un modelo de consistencia que garantiza que, en ausencia de nuevas actualizaciones, los datos eventualmente se volverán consistentes.</td>
                <td><pre><code>// Java example with eventual consistency
public class Cache {
    private Map<String, String> data = new ConcurrentHashMap<>();

    public void put(String key, String value) {
        data.put(key, value);
        // Simulate eventual consistency
    }

    public String get(String key) {
        return data.get(key);
    }
}</code></pre></td>
                <td><pre><code>class Cache:
    def __init__(self):
        self.data = {}

    def put(self, key: str, value: str):
        self.data[key] = value
        # Simulate eventual consistency

    def get(self, key: str):
        return self.data.get(key)</code></pre></td>
                <td><pre><code>public class Cache
{
    private readonly ConcurrentDictionary<string, string> _data = new ConcurrentDictionary<string, string>();

    public void Put(string key, string value)
    {
        _data[key] = value;
        // Simulate eventual consistency
    }

    public string Get(string key)
    {
        return _data.TryGetValue(key, out var value) ? value : null;
    }
}</code></pre></td>
                <td><pre><code>class Cache {
    private data: Map<string, string> = new Map();

    public put(key: string, value: string): void {
        this.data.set(key, value);
        // Simulate eventual consistency
    }

    public get(key: string): string | undefined {
        return this.data.get(key);
    }
}</code></pre></td>
            </tr>
            <tr>
                <td>14</td>
                <td>¿Qué es la integración continua?</td>
                <td>La integración continua es una práctica de desarrollo donde el código se integra y se prueba continuamente para detectar errores temprano.</td>
                <td><pre><code>// Java example with Maven
mvn clean install</code></pre></td>
                <td><pre><code># Python example with pytest
pytest</code></pre></td>
                <td><pre><code>// C# example with .NET CLI
dotnet build</code></pre></td>
                <td><pre><code>// TypeScript example with npm
npm run build</code></pre></td>
            </tr>
            <tr>
                <td>15</td>
                <td>¿Qué es el despliegue continuo?</td>
                <td>El despliegue continuo es una práctica que permite que los cambios en el código se desplieguen automáticamente en producción después de pasar las pruebas.</td>
                <td><pre><code>// Java example with Jenkins
// Jenkinsfile pipeline configuration for continuous deployment</code></pre></td>
                <td><pre><code># Python example with GitHub Actions
# .github/workflows/deploy.yml</code></pre></td>
                <td><pre><code>// C# example with Azure DevOps
// YAML pipeline configuration for deployment</code></pre></td>
                <td><pre><code>// TypeScript example with GitHub Actions
// .github/workflows/deploy.yml</code></pre></td>
            </tr>
            <tr>
                <td>16</td>
                <td>¿Qué es un microservicio?</td>
                <td>Un microservicio es un pequeño servicio autónomo que realiza una función específica y se comunica con otros microservicios a través de APIs.</td>
                <td><pre><code>// Java example
@RestController
@RequestMapping("/users")
public class UserController {
    @GetMapping("/{id}")
    public User getUser(@PathVariable Long id) {
        return userService.getUser(id);
    }
}</code></pre></td>
                <td><pre><code>@app.route('/users/<int:id>', methods=['GET'])
def get_user(id):
    return jsonify(user_service.get_user(id))</code></pre></td>
                <td><pre><code>[ApiController]
[Route("users")]
public class UserController : ControllerBase
{
    [HttpGet("{id}")]
    public IActionResult GetUser(long id)
    {
        return Ok(userService.GetUser(id));
    }
}</code></pre></td>
                <td><pre><code>import { Request, Response } from 'express';

app.get('/users/:id', (req: Request, res: Response) => {
    const user = userService.getUser(Number(req.params.id));
    res.json(user);
});
</code></pre></td>
            </tr>
            <tr>
                <td>17</td>
                <td>¿Qué es la separación de responsabilidades?</td>
                <td>La separación de responsabilidades es un principio que establece que cada componente del sistema debe tener una única responsabilidad o propósito.</td>
                <td><pre><code>// Java example
public class UserService {
    public void addUser(User user) {
        // Logic for adding user
    }
}

public class UserRepository {
    public User findById(Long id) {
        // Logic for finding user
    }
}</code></pre></td>
                <td><pre><code>class UserService:
    def add_user(self, user):
        # Logic for adding user
        pass

class UserRepository:
    def find_by_id(self, id: int):
        # Logic for finding user
        pass</code></pre></td>
                <td><pre><code>public class UserService
{
    public void AddUser(User user)
    {
        // Logic for adding user
    }
}

public class UserRepository
{
    public User FindById(long id)
    {
        // Logic for finding user
    }
}</code></pre></td>
                <td><pre><code>class UserService {
    public addUser(user: User): void {
        // Logic for adding user
    }
}

class UserRepository {
    public findById(id: number): User | undefined {
        // Logic for finding user
    }
}</code></pre></td>
            </tr>
            <tr>
                <td>18</td>
                <td>¿Qué es la escalabilidad?</td>
                <td>La escalabilidad es la capacidad de un sistema para manejar un aumento en la carga de trabajo sin perder rendimiento.</td>
                <td><pre><code>// Java example with horizontal scaling
public class LoadBalancer {
    public void balanceLoad() {
        // Distribute load across multiple instances
    }
}</code></pre></td>
                <td><pre><code>def balance_load():
    # Distribute load across multiple instances
    pass</code></pre></td>
                <td><pre><code>public class LoadBalancer
{
    public void BalanceLoad()
    {
        // Distribute load across multiple instances
    }
}</code></pre></td>
                <td><pre><code>function balanceLoad(): void {
    // Distribute load across multiple instances
}</code></pre></td>
            </tr>
            <tr>
                <td>19</td>
                <td>¿Qué es un patrón de diseño?</td>
                <td>Un patrón de diseño es una solución reutilizable a un problema común en el diseño de software.</td>
                <td><pre><code>// Java example with Singleton pattern
public class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}</code></pre></td>
                <td><pre><code>class Singleton:
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance</code></pre></td>
                <td><pre><code>public class Singleton
{
    private static Singleton _instance;

    private Singleton() {}

    public static Singleton GetInstance()
    {
        if (_instance == null)
        {
            _instance = new Singleton();
        }
        return _instance;
    }
}</code></pre></td>
                <td><pre><code>class Singleton {
    private static instance: Singleton;

    private constructor() {}

    public static getInstance(): Singleton {
        if (!Singleton.instance) {
            Singleton.instance = new Singleton();
        }
        return Singleton.instance;
    }
}</code></pre></td>
            </tr>
            <tr>
                <td>20</td>
                <td>¿Qué es la inyección de dependencias?</td>
                <td>La inyección de dependencias es un patrón de diseño que permite que las dependencias de una clase se proporcionen externamente en lugar de ser creadas por la propia clase.</td>
                <td><pre><code>// Java example with Spring
@Autowired
private UserService userService;</code></pre></td>
                <td><pre><code>class UserService:
    def __init__(self, dependency):
        self.dependency = dependency</code></pre></td>
                <td><pre><code>[Inject]
private UserService userService;</code></pre></td>
                <td><pre><code>class UserComponent {
    constructor(private userService: UserService) {}
}</code></pre></td>
            </tr>
            <tr>
                <td>21</td>
                <td>¿Qué es el principio de responsabilidad única?</td>
                <td>El principio de responsabilidad única establece que una clase debe tener una única razón para cambiar, es decir, una sola responsabilidad.</td>
                <td><pre><code>// Java example
public class UserManager {
    public void manageUser(User user) {
        // Manage user
    }
}

public class UserValidator {
    public boolean validate(User user) {
        // Validate user
        return true;
    }
}</code></pre></td>
                <td><pre><code>class UserManager:
    def manage_user(self, user):
        # Manage user
        pass

class UserValidator:
    def validate(self, user):
        # Validate user
        return True</code></pre></td>
                <td><pre><code>public class UserManager
{
    public void ManageUser(User user)
    {
        // Manage user
    }
}

public class UserValidator
{
    public bool Validate(User user)
    {
        // Validate user
        return true;
    }
}</code></pre></td>
                <td><pre><code>class UserManager {
    public manageUser(user: User): void {
        // Manage user
    }
}

class UserValidator {
    public validate(user: User): boolean {
        // Validate user
        return true;
    }
}</code></pre></td>
            </tr>
            <tr>
                <td>22</td>
                <td>¿Qué es el principio de sustitución de Liskov?</td>
                <td>El principio de sustitución de Liskov establece que los objetos de una clase derivada deben ser reemplazables por objetos de la clase base sin alterar el funcionamiento del programa.</td>
                <td><pre><code>// Java example
public class Shape {
    public double area() {
        return 0;
    }
}

public class Circle extends Shape {
    private double radius;

    @Override
    public double area() {
        return Math.PI * radius * radius;
    }
}</code></pre></td>
                <td><pre><code>class Shape:
    def area(self):
        return 0

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14159 * self.radius * self.radius</code></pre></td>
                <td><pre><code>public class Shape
{
    public virtual double Area()
    {
        return 0;
    }
}

public class Circle : Shape
{
    private double radius;

    public Circle(double radius)
    {
        this.radius = radius;
    }

    public override double Area()
    {
        return Math.PI * radius * radius;
    }
}</code></pre></td>
                <td><pre><code>class Shape {
    area(): number {
        return 0;
    }
}

class Circle extends Shape {
    constructor(private radius: number) {
        super();
    }

    area(): number {
        return Math.PI * this.radius * this.radius;
    }
}</code></pre></td>
            </tr>
            <tr>
                <td>23</td>
                <td>¿Qué es el principio de segregación de interfaces?</td>
                <td>El principio de segregación de interfaces establece que una clase no debe verse obligada a implementar interfaces que no usa.</td>
                <td><pre><code>// Java example
public interface UserRepository {
    void addUser(User user);
    User getUserById(Long id);
}

public interface AdminRepository {
    void addAdmin(Admin admin);
    Admin getAdminById(Long id);
}</code></pre></td>
                <td><pre><code>class UserRepository:
    def add_user(self, user):
        pass
    
    def get_user_by_id(self, id):
        pass

class AdminRepository:
    def add_admin(self, admin):
        pass
    
    def get_admin_by_id(self, id):
        pass</code></pre></td>
                <td><pre><code>public interface IUserRepository
{
    void AddUser(User user);
    User GetUserById(long id);
}

public interface IAdminRepository
{
    void AddAdmin(Admin admin);
    Admin GetAdminById(long id);
}</code></pre></td>
                <td><pre><code>interface UserRepository {
    addUser(user: User): void;
    getUserById(id: number): User;
}

interface AdminRepository {
    addAdmin(admin: Admin): void;
    getAdminById(id: number): Admin;
}</code></pre></td>
            </tr>
            <tr>
                <td>24</td>
                <td>¿Qué es el principio de inversión de dependencias?</td>
                <td>El principio de inversión de dependencias establece que las dependencias deben estar dirigidas hacia abstracciones en lugar de hacia implementaciones concretas.</td>
                <td><pre><code>// Java example
public interface UserRepository {
    void addUser(User user);
}

public class UserService {
    private UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}</code></pre></td>
                <td><pre><code>class UserRepository:
    def add_user(self, user):
        pass

class UserService:
    def __init__(self, user_repository: UserRepository):
        self.user_repository = user_repository</code></pre></td>
                <td><pre><code>public interface IUserRepository
{
    void AddUser(User user);
}

public class UserService
{
    private readonly IUserRepository _userRepository;

    public UserService(IUserRepository userRepository)
    {
        _userRepository = userRepository;
    }
}</code></pre></td>
                <td><pre><code>interface UserRepository {
    addUser(user: User): void;
}

class UserService {
    constructor(private userRepository: UserRepository) {}
}</code></pre></td>
            </tr>
            <tr>
                <td>25</td>
                <td>¿Qué es la arquitectura de microservicios?</td>
                <td>La arquitectura de microservicios es un estilo arquitectónico en el que una aplicación está compuesta por pequeños servicios independientes que se comunican entre sí.</td>
                <td><pre><code>// Java example
public class UserService {
    // Service logic
}

public class OrderService {
    // Service logic
}</code></pre></td>
                <td><pre><code>class UserService:
    # Service logic
    pass

class OrderService:
    # Service logic
    pass</code></pre></td>
                <td><pre><code>public class UserService
{
    // Service logic
}

public class OrderService
{
    // Service logic
}</code></pre></td>
                <td><pre><code>class UserService {
    // Service logic
}

class OrderService {
    // Service logic
}</code></pre></td>
            </tr>
        </tbody>
    </table>
</body>
</html>
