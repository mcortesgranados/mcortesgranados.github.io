<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Preguntas sobre Programación Orientada a Objetos y Lógica de Programación</title>
    <style>
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f4f4f4;
        }
        pre {
            background-color: #f4f4f4;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <h1>Preguntas sobre Programación Orientada a Objetos y Lógica de Programación</h1>
    <table>
        <thead>
            <tr>
                <th>#</th>
                <th>Pregunta</th>
                <th>Respuesta Teórica</th>
                <th>Java</th>
                <th>Python</th>
                <th>C#</th>
                <th>TypeScript</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>1</td>
                <td>¿Qué es una clase?</td>
                <td>Una clase es una plantilla para crear objetos que define un conjunto de atributos y métodos que esos objetos pueden tener.</td>
                <td><pre><code>public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }
}</code></pre></td>
                <td><pre><code>class Person:
    def __init__(self, name: str, age: int):
        self.name = name
        self.age = age

    def get_name(self):
        return self.name

    def get_age(self):
        return self.age</code></pre></td>
                <td><pre><code>public class Person
{
    private string Name;
    private int Age;

    public Person(string name, int age)
    {
        Name = name;
        Age = age;
    }

    public string GetName()
    {
        return Name;
    }

    public int GetAge()
    {
        return Age;
    }
}</code></pre></td>
                <td><pre><code>class Person {
    constructor(private name: string, private age: number) {}

    public getName(): string {
        return this.name;
    }

    public getAge(): number {
        return this.age;
    }
}</code></pre></td>
            </tr>
            <tr>
                <td>2</td>
                <td>¿Qué es un objeto?</td>
                <td>Un objeto es una instancia de una clase que contiene valores específicos para los atributos definidos por la clase y puede usar los métodos de la clase.</td>
                <td><pre><code>Person person = new Person("John", 30);
System.out.println(person.getName()); // John</code></pre></td>
                <td><pre><code>person = Person("John", 30)
print(person.get_name())  # John</code></pre></td>
                <td><pre><code>Person person = new Person("John", 30);
Console.WriteLine(person.GetName()); // John</code></pre></td>
                <td><pre><code>let person = new Person("John", 30);
console.log(person.getName()); // John</code></pre></td>
            </tr>
            <tr>
                <td>3</td>
                <td>¿Qué es la herencia?</td>
                <td>La herencia es un mecanismo que permite a una clase heredar atributos y métodos de otra clase.</td>
                <td><pre><code>public class Student extends Person {
    private String studentId;

    public Student(String name, int age, String studentId) {
        super(name, age);
        this.studentId = studentId;
    }

    public String getStudentId() {
        return studentId;
    }
}</code></pre></td>
                <td><pre><code>class Student(Person):
    def __init__(self, name: str, age: int, student_id: str):
        super().__init__(name, age)
        self.student_id = student_id

    def get_student_id(self):
        return self.student_id</code></pre></td>
                <td><pre><code>public class Student : Person
{
    private string StudentId;

    public Student(string name, int age, string studentId) : base(name, age)
    {
        StudentId = studentId;
    }

    public string GetStudentId()
    {
        return StudentId;
    }
}</code></pre></td>
                <td><pre><code>class Student extends Person {
    constructor(name: string, age: number, private studentId: string) {
        super(name, age);
    }

    public getStudentId(): string {
        return this.studentId;
    }
}</code></pre></td>
            </tr>
            <tr>
                <td>4</td>
                <td>¿Qué es el polimorfismo?</td>
                <td>El polimorfismo permite que diferentes clases implementen el mismo método de diferentes maneras.</td>
                <td><pre><code>public class Animal {
    public void makeSound() {
        System.out.println("Some sound");
    }
}

public class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Bark");
    }
}</code></pre></td>
                <td><pre><code>class Animal:
    def make_sound(self):
        print("Some sound")

class Dog(Animal):
    def make_sound(self):
        print("Bark")</code></pre></td>
                <td><pre><code>public class Animal
{
    public virtual void MakeSound()
    {
        Console.WriteLine("Some sound");
    }
}

public class Dog : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine("Bark");
    }
}</code></pre></td>
                <td><pre><code>class Animal {
    public makeSound(): void {
        console.log("Some sound");
    }
}

class Dog extends Animal {
    public makeSound(): void {
        console.log("Bark");
    }
}</code></pre></td>
            </tr>
            <tr>
                <td>5</td>
                <td>¿Qué es la encapsulación?</td>
                <td>La encapsulación es el concepto de ocultar los detalles internos de una clase y exponer solo lo necesario a través de métodos públicos.</td>
                <td><pre><code>public class Person {
    private String name;

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}</code></pre></td>
                <td><pre><code>class Person:
    def __init__(self, name: str):
        self.__name = name

    def set_name(self, name: str):
        self.__name = name

    def get_name(self) -> str:
        return self.__name</code></pre></td>
                <td><pre><code>public class Person
{
    private string Name;

    public void SetName(string name)
    {
        Name = name;
    }

    public string GetName()
    {
        return Name;
    }
}</code></pre></td>
                <td><pre><code>class Person {
    private name: string;

    constructor(name: string) {
        this.name = name;
    }

    public setName(name: string): void {
        this.name = name;
    }

    public getName(): string {
        return this.name;
    }
}</code></pre></td>
            </tr>
            <tr>
                <td>6</td>
                <td>¿Qué es una interfaz?</td>
                <td>Una interfaz define un contrato que otras clases deben implementar, especificando métodos sin proporcionar su implementación.</td>
                <td><pre><code>public interface Animal {
    void makeSound();
}

public class Dog implements Animal {
    @Override
    public void makeSound() {
        System.out.println("Bark");
    }
}</code></pre></td>
                <td><pre><code>class Animal:
    def make_sound(self):
        pass

class Dog(Animal):
    def make_sound(self):
        print("Bark")</code></pre></td>
                <td><pre><code>public interface IAnimal
{
    void MakeSound();
}

public class Dog : IAnimal
{
    public void MakeSound()
    {
        Console.WriteLine("Bark");
    }
}</code></pre></td>
                <td><pre><code>interface Animal {
    makeSound(): void;
}

class Dog implements Animal {
    public makeSound(): void {
        console.log("Bark");
    }
}</code></pre></td>
            </tr>
            <tr>
                <td>7</td>
                <td>¿Qué es la composición?</td>
                <td>La composición es un tipo de relación en la que una clase contiene referencias a otras clases y utiliza sus funcionalidades.</td>
                <td><pre><code>public class Engine {
    // Engine properties and methods
}

public class Car {
    private Engine engine;

    public Car() {
        this.engine = new Engine();
    }
}</code></pre></td>
                <td><pre><code>class Engine:
    # Engine properties and methods
    pass

class Car:
    def __init__(self):
        self.engine = Engine()</code></pre></td>
                <td><pre><code>public class Engine
{
    // Engine properties and methods
}

public class Car
{
    private Engine _engine;

    public Car()
    {
        _engine = new Engine();
    }
}</code></pre></td>
                <td><pre><code>class Engine {
    // Engine properties and methods
}

class Car {
    private engine: Engine;

    constructor() {
        this.engine = new Engine();
    }
}</code></pre></td>
            </tr>
            <tr>
                <td>8</td>
                <td>¿Qué es la agregación?</td>
                <td>La agregación es una relación en la que una clase contiene referencias a otras clases, pero esas clases pueden existir independientemente.</td>
                <td><pre><code>public class Department {
    private List<Employee> employees;

    public Department() {
        this.employees = new ArrayList<>();
    }

    public void addEmployee(Employee employee) {
        employees.add(employee);
    }
}</code></pre></td>
                <td><pre><code>class Employee:
    # Employee properties and methods
    pass

class Department:
    def __init__(self):
        self.employees = []

    def add_employee(self, employee: Employee):
        self.employees.append(employee)</code></pre></td>
                <td><pre><code>public class Department
{
    private List<Employee> Employees;

    public Department()
    {
        Employees = new List<Employee>();
    }

    public void AddEmployee(Employee employee)
    {
        Employees.Add(employee);
    }
}</code></pre></td>
                <td><pre><code>class Department {
    private employees: Employee[] = [];

    public addEmployee(employee: Employee): void {
        this.employees.push(employee);
    }
}</code></pre></td>
            </tr>
            <tr>
                <td>9</td>
                <td>¿Qué es un constructor?</td>
                <td>Un constructor es un método especial de una clase que se llama automáticamente cuando se crea una instancia de la clase, utilizado para inicializar los objetos.</td>
                <td><pre><code>public class Person {
    private String name;

    public Person(String name) {
        this.name = name;
    }
}</code></pre></td>
                <td><pre><code>class Person:
    def __init__(self, name: str):
        self.name = name</code></pre></td>
                <td><pre><code>public class Person
{
    private string Name;

    public Person(string name)
    {
        Name = name;
    }
}</code></pre></td>
                <td><pre><code>class Person {
    constructor(private name: string) {}
}</code></pre></td>
            </tr>
            <tr>
                <td>10</td>
                <td>¿Qué es un método estático?</td>
                <td>Un método estático pertenece a la clase en lugar de a una instancia específica de la clase y puede ser llamado sin crear una instancia de la clase.</td>
                <td><pre><code>public class MathUtils {
    public static int add(int a, int b) {
        return a + b;
    }
}</code></pre></td>
                <td><pre><code>class MathUtils:
    @staticmethod
    def add(a: int, b: int) -> int:
        return a + b</code></pre></td>
                <td><pre><code>public class MathUtils
{
    public static int Add(int a, int b)
    {
        return a + b;
    }
}</code></pre></td>
                <td><pre><code>class MathUtils {
    public static add(a: number, b: number): number {
        return a + b;
    }
}</code></pre></td>
            </tr>
            <tr>
                <td>11</td>
                <td>¿Qué es la sobrecarga de métodos?</td>
                <td>La sobrecarga de métodos permite tener varios métodos con el mismo nombre pero con diferentes parámetros.</td>
                <td><pre><code>public class Printer {
    public void print(int value) {
        System.out.println(value);
    }

    public void print(String value) {
        System.out.println(value);
    }
}</code></pre></td>
                <td><pre><code>class Printer:
    def print(self, value):
        if isinstance(value, int):
            print(f"Integer: {value}")
        elif isinstance(value, str):
            print(f"String: {value}")</code></pre></td>
                <td><pre><code>public class Printer
{
    public void Print(int value)
    {
        Console.WriteLine(value);
    }

    public void Print(string value)
    {
        Console.WriteLine(value);
    }
}</code></pre></td>
                <td><pre><code>class Printer {
    public print(value: number | string): void {
        if (typeof value === 'number') {
            console.log(`Number: ${value}`);
        } else {
            console.log(`String: ${value}`);
        }
    }
}</code></pre></td>
            </tr>
            <tr>
                <td>12</td>
                <td>¿Qué es la sobreescritura de métodos?</td>
                <td>La sobreescritura de métodos permite que una subclase proporcione una implementación específica para un método que ya está definido en su superclase.</td>
                <td><pre><code>public class Animal {
    public void makeSound() {
        System.out.println("Some sound");
    }
}

public class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Bark");
    }
}</code></pre></td>
                <td><pre><code>class Animal:
    def make_sound(self):
        print("Some sound")

class Dog(Animal):
    def make_sound(self):
        print("Bark")</code></pre></td>
                <td><pre><code>public class Animal
{
    public virtual void MakeSound()
    {
        Console.WriteLine("Some sound");
    }
}

public class Dog : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine("Bark");
    }
}</code></pre></td>
                <td><pre><code>class Animal {
    public makeSound(): void {
        console.log("Some sound");
    }
}

class Dog extends Animal {
    public makeSound(): void {
        console.log("Bark");
    }
}</code></pre></td>
            </tr>
            <tr>
                <td>13</td>
                <td>¿Qué es la herencia múltiple?</td>
                <td>La herencia múltiple permite que una clase herede de más de una clase base. Sin embargo, muchos lenguajes de programación no lo soportan directamente.</td>
                <td><pre><code>// Java does not support multiple inheritance directly, but interfaces can be used</code></pre></td>
                <td><pre><code># Python supports multiple inheritance
class A:
    def method_a(self):
        pass

class B:
    def method_b(self):
        pass

class C(A, B):
    pass</code></pre></td>
                <td><pre><code>// C# does not support multiple inheritance directly, but interfaces can be used</code></pre></td>
                <td><pre><code>// TypeScript supports multiple inheritance via interfaces
interface A {
    methodA(): void;
}

interface B {
    methodB(): void;
}

class C implements A, B {
    methodA(): void {}
    methodB(): void {}
}</code></pre></td>
            </tr>
            <tr>
                <td>14</td>
                <td>¿Qué es un patrón de diseño?</td>
                <td>Un patrón de diseño es una solución reutilizable a un problema común en el diseño de software.</td>
                <td><pre><code>public class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}</code></pre></td>
                <td><pre><code>class Singleton:
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(Singleton, cls).__new__(cls)
        return cls._instance</code></pre></td>
                <td><pre><code>public class Singleton
{
    private static Singleton _instance;

    private Singleton() {}

    public static Singleton GetInstance()
    {
        if (_instance == null)
        {
            _instance = new Singleton();
        }
        return _instance;
    }
}</code></pre></td>
                <td><pre><code>class Singleton {
    private static instance: Singleton;

    private constructor() {}

    public static getInstance(): Singleton {
        if (!this.instance) {
            this.instance = new Singleton();
        }
        return this.instance;
    }
}</code></pre></td>
            </tr>
        </tbody>
    </table>

---

Esto debería ofrecer una visión general clara y útil de las preguntas y respuestas relacionadas con la programación orientada a objetos en diferentes lenguajes. ¿Te gustaría ajustar algo más o agregar algún detalle adicional?
