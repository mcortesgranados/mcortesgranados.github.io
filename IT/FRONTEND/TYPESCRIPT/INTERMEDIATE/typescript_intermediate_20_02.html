<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TypeScript Intermediate Level Questions and Answers - Part 2</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        h2 {
            color: #2c3e50;
        }
        pre {
            background: #f4f4f4;
            border: 1px solid #ddd;
            padding: 10px;
            overflow-x: auto;
        }
        code {
            color: #d14;
        }
    </style>
</head>
<body>

    <h1>TypeScript Intermediate Level Questions and Answers - Part 2</h1>

    <h2>1. How do you use <code>Tuple Types</code> with optional elements in TypeScript?</h2>
    <p>Tuples in TypeScript can include optional elements by using the <code>?</code> modifier.</p>
    <pre><code>let tuple: [string, number?] = ["hello"];
tuple = ["hello", 42]; // Valid

// tuple = [42, "hello"]; // Error: Type 'number' is not assignable to type 'string'</code></pre>

    <h2>2. What is <code>Type Assertion</code> and how is it used?</h2>
    <p>Type assertions allow you to specify a type for a value. It does not perform any type checking or restructuring of data.</p>
    <pre><code>let someValue: any = "This is a string";
let strLength: number = (someValue as string).length;
console.log(strLength); // 16

// Alternative syntax
let strLength2: number = (<string>someValue).length;
console.log(strLength2); // 16</code></pre>

    <h2>3. How do you use <code>type</code> alias with union and intersection types?</h2>
    <p>You can create union and intersection types using the <code>type</code> alias in TypeScript.</p>
    <pre><code>type A = { a: number };
type B = { b: string };

type UnionType = A | B; // Union type
type IntersectionType = A & B; // Intersection type

let example1: UnionType = { a: 1 }; // Valid
let example2: IntersectionType = { a: 1, b: "text" }; // Valid

// let example3: IntersectionType = { a: 1 }; // Error: Property 'b' is missing in type '{ a: number }'</code></pre>

    <h2>4. How do you use <code>ReadonlyArray</code> to create an immutable array?</h2>
    <p>The <code>ReadonlyArray</code> type creates an array where elements cannot be modified.</p>
    <pre><code>let numbers: ReadonlyArray<number> = [1, 2, 3];
numbers[0] = 4; // Error: Index signature in type 'ReadonlyArray<number>' only permits reading property

let mutableNumbers: number[] = [1, 2, 3];
mutableNumbers[0] = 4; // Valid</code></pre>

    <h2>5. How do you use <code>typeof</code> operator for type inference in TypeScript?</h2>
    <p>The <code>typeof</code> operator can be used to infer the type of a variable based on another variable's type.</p>
    <pre><code>let message = "Hello, TypeScript";
let anotherMessage: typeof message; // Type is string

anotherMessage = "Hi there!";
console.log(anotherMessage); // Hi there!</code></pre>

    <h2>6. How do you define a function with default parameters in TypeScript?</h2>
    <p>Default parameters allow you to specify default values for function parameters.</p>
    <pre><code>function greet(name: string = "Guest"): void {
    console.log(`Hello, ${name}`);
}

greet(); // Hello, Guest
greet("Alice"); // Hello, Alice</code></pre>

    <h2>7. What are <code>conditional types</code> in TypeScript and how do you use them?</h2>
    <p>Conditional types allow you to create types based on conditions using the <code>extends</code> keyword.</p>
    <pre><code>type IsString<T> = T extends string ? "Yes" : "No";

type Test1 = IsString<string>; // "Yes"
type Test2 = IsString<number>; // "No"</code></pre>

    <h2>8. How do you use <code>this</code> parameter in TypeScript functions?</h2>
    <p>The <code>this</code> parameter allows you to specify the type of <code>this</code> inside a function.</p>
    <pre><code>function logThis(this: { message: string }) {
    console.log(this.message);
}

const obj = { message: "Hello, TypeScript", log: logThis };
obj.log(); // Hello, TypeScript</code></pre>

    <h2>9. How do you use <code>asserts</code> keyword for user-defined type guards?</h2>
    <p>The <code>asserts</code> keyword is used in custom type guards to perform runtime checks and assert types.</p>
    <pre><code>function assertIsString(value: any): asserts value is string {
    if (typeof value !== "string") {
        throw new Error("Not a string");
    }
}

let input: any = "hello";
assertIsString(input);
console.log(input.toUpperCase()); // HELLO</code></pre>

    <h2>10. How do you define a type that represents a function with specific parameters?</h2>
    <p>You can use a type alias to define a function type with specific parameters.</p>
    <pre><code>type AddFunction = (a: number, b: number) => number;

const add: AddFunction = (x, y) => x + y;

console.log(add(2, 3)); // 5</code></pre>

    <h2>11. How do you use <code>keyof</code> with generic constraints in TypeScript?</h2>
    <p>You can use <code>keyof</code> with generic constraints to create type-safe accessors.</p>
    <pre><code>function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
    return obj[key];
}

const user = { name: "Alice", age: 25 };
const userName = getProperty(user, "name");
console.log(userName); // Alice</code></pre>

    <h2>12. How do you use <code>function overloads</code> in TypeScript?</h2>
    <p>Function overloads allow you to define multiple signatures for a single function.</p>
    <pre><code>function greet(person: string): string;
function greet(person: string, age: number): string;
function greet(person: string, age?: number): string {
    if (age !== undefined) {
        return `Hello ${person}, you are ${age} years old.`;
    }
    return `Hello ${person}`;
}

console.log(greet("Alice")); // Hello Alice
console.log(greet("Alice", 30)); // Hello Alice, you are 30 years old.</code></pre>

    <h2>13. How do you use <code>never</code> type in TypeScript?</h2>
    <p>The <code>never</code> type represents values that never occur, typically used for functions that throw errors or have infinite loops.</p>
    <pre><code>function throwError(message: string): never {
    throw new Error(message);
}

function infiniteLoop(): never {
    while (true) {}
}</code></pre>

    <h2>14. How do you use <code>Promise</code> in TypeScript for asynchronous programming?</h2>
    <p>You can use <code>Promise</code> to handle asynchronous operations, specifying the type of the resolved value.</p>
    <pre><code>function fetchData(): Promise<string> {
    return new Promise((resolve) => {
        setTimeout(() => resolve("Data received"), 1000);
    });
}

fetchData().then(data => console.log(data)); // Data received</code></pre>

    <h2>15. How do you use <code>interface merging</code> in TypeScript?</h2>
    <p>Interface merging allows you to combine multiple interfaces into a single interface with the combined properties.</p>
    <pre><code>interface User {
    name: string;
}

interface User {
    age: number;
}

const user: User = { name: "Alice", age: 30 };
console.log(user); // { name: "Alice", age: 30 }</code></pre>

    <h2>16. How do you use <code>type guards</code> with user-defined types?</h2>
    <p>Type guards are used to narrow down the type of a variable, allowing more specific type handling.</p>
    <pre><code>type Cat = { type: "cat"; meow: () => void };
type Dog = { type: "dog"; bark: () => void };

function isCat(pet: Cat | Dog): pet is Cat {
    return pet.type === "cat";
}

const pet: Cat | Dog = { type: "cat", meow: () => console.log("Meow") };

if (isCat(pet)) {
    pet.meow(); // Meow
} else {
    pet.bark(); // This will not run
}</code></pre>

    <h2>17. How do you define and use <code>mapped types</code> in TypeScript?</h2>
    <p>Mapped types create new types by transforming properties of an existing type.</p>
    <pre><code>type Readonly<T> = {
    readonly [K in keyof T]: T[K];
};

interface User {
    name: string;
    age: number;
}

const readonlyUser: Readonly<User> = { name: "Alice", age: 30 };

// readonlyUser.age = 31; // Error: Cannot assign to 'age' because it is a read-only property</code></pre>

    <h2>18. How do you define <code>type predicates</code> in TypeScript?</h2>
    <p>Type predicates are used in type guard functions to assert the type of a variable.</p>
    <pre><code>function isString(value: any): value is string {
    return typeof value === "string";
}

const value: any = "hello";

if (isString(value)) {
    console.log(value.toUpperCase()); // HELLO
}</code></pre>

    <h2>19. How do you use <code>class decorators</code> in TypeScript?</h2>
    <p>Class decorators are functions that can modify or extend the behavior of a class.</p>
    <pre><code>function LogClass(constructor: Function) {
    console.log("Class created: " + constructor.name);
}

@LogClass
class Person {
    constructor(public name: string) {}
}

const person = new Person("Alice"); // Class created: Person</code></pre>

    <h2>20. How do you use <code>enum</code> types in TypeScript?</h2>
    <p>Enums allow you to define a set of named constants.</p>
    <pre><code>enum Direction {
    Up = 1,
    Down,
    Left,
    Right
}

let move: Direction = Direction.Up;
console.log(move); // 1</code></pre>

</body>
</html>
