<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TypeScript Intermediate Level Questions and Answers - Part 3</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        h2 {
            color: #2c3e50;
        }
        pre {
            background: #f4f4f4;
            border: 1px solid #ddd;
            padding: 10px;
            overflow-x: auto;
        }
        code {
            color: #d14;
        }
    </style>
</head>
<body>

    <h1>TypeScript Intermediate Level Questions and Answers - Part 3</h1>

    <h2>1. How do you define a function that returns a tuple in TypeScript?</h2>
    <p>To define a function that returns a tuple, specify the return type as a tuple with fixed elements.</p>
    <pre><code>function getPair(): [string, number] {
    return ["Alice", 30];
}

const pair = getPair();
console.log(pair[0]); // Alice
console.log(pair[1]); // 30</code></pre>

    <h2>2. How do you use <code>keyof</code> and <code>in</code> operators in TypeScript?</h2>
    <p>The <code>keyof</code> operator gets the keys of a type, while <code>in</code> is used to iterate over those keys.</p>
    <pre><code>type User = { name: string; age: number };

type UserKeys = keyof User; // "name" | "age"

function logKey(key: UserKeys, user: User) {
    console.log(user[key]);
}

const user = { name: "Alice", age: 30 };
logKey("name", user); // Alice
logKey("age", user); // 30</code></pre>

    <h2>3. How do you use <code>Partial</code> and <code>Required</code> utility types?</h2>
    <p>The <code>Partial</code> type makes all properties of a type optional, while <code>Required</code> makes all properties required.</p>
    <pre><code>interface User {
    name: string;
    age?: number;
}

const partialUser: Partial<User> = { name: "Alice" }; // Valid

const fullUser: Required<User> = { name: "Alice", age: 30 }; // Valid

// const incompleteUser: Required<User> = { name: "Alice" }; // Error: Property 'age' is missing</code></pre>

    <h2>4. How do you use <code>ReturnType</code> to get the return type of a function?</h2>
    <p>The <code>ReturnType</code> utility type extracts the return type of a function type.</p>
    <pre><code>function getAge(): number {
    return 30;
}

type AgeType = ReturnType<typeof getAge>; // number

const age: AgeType = 25;
console.log(age); // 25</code></pre>

    <h2>5. How do you use <code>Readonly</code> to create immutable types in TypeScript?</h2>
    <p>The <code>Readonly</code> utility type makes all properties of an object read-only.</p>
    <pre><code>interface User {
    name: string;
    age: number;
}

const user: Readonly<User> = { name: "Alice", age: 30 };

// user.age = 31; // Error: Cannot assign to 'age' because it is a read-only property</code></pre>

    <h2>6. How do you use <code>Intersection Types</code> to combine multiple types?</h2>
    <p>Intersection types combine multiple types into one, including all properties from the combined types.</p>
    <pre><code>interface Person {
    name: string;
}

interface Address {
    street: string;
}

type PersonWithAddress = Person & Address;

const person: PersonWithAddress = {
    name: "Alice",
    street: "123 Main St"
};

console.log(person); // { name: "Alice", street: "123 Main St" }</code></pre>

    <h2>7. How do you use <code>Extract</code> and <code>Exclude</code> utility types?</h2>
    <p>The <code>Extract</code> type extracts types that are present in both types, while <code>Exclude</code> removes types present in one type.</p>
    <pre><code>type AllTypes = "a" | "b" | "c";
type Extracted = Extract<AllTypes, "a" | "b">; // "a" | "b"
type Excluded = Exclude<AllTypes, "a">; // "b" | "c"</code></pre>

    <h2>8. How do you use <code>NonNullable</code> to remove null and undefined from a type?</h2>
    <p>The <code>NonNullable</code> utility type removes <code>null</code> and <code>undefined</code> from a type.</p>
    <pre><code>type NullableString = string | null | undefined;
type NonNullableString = NonNullable<NullableString>; // string

const value: NonNullableString = "Hello";
console.log(value); // Hello</code></pre>

    <h2>9. How do you use <code>type</code> and <code>interface</code> to define a type for a function?</h2>
    <p>You can define a function type using either <code>type</code> or <code>interface</code>, but <code>type</code> is generally preferred for function types.</p>
    <pre><code>type SumFunction = (a: number, b: number) => number;

const sum: SumFunction = (x, y) => x + y;
console.log(sum(2, 3)); // 5

interface MultiplyFunction {
    (a: number, b: number): number;
}

const multiply: MultiplyFunction = (x, y) => x * y;
console.log(multiply(2, 3)); // 6</code></pre>

    <h2>10. How do you use <code>typeof</code> operator for type inference with objects?</h2>
    <p>The <code>typeof</code> operator can infer the type of an object based on its structure.</p>
    <pre><code>const person = { name: "Alice", age: 30 };
type PersonType = typeof person;

const anotherPerson: PersonType = { name: "Bob", age: 25 };
console.log(anotherPerson); // { name: "Bob", age: 25 }</code></pre>

    <h2>11. How do you use <code>const assertions</code> to create immutable values?</h2>
    <p>Const assertions can be used to create immutable values and ensure their types are as specified.</p>
    <pre><code>const colors = ["red", "green", "blue"] as const;
type Colors = typeof colors[number]; // "red" | "green" | "blue"

const color: Colors = "red";
console.log(color); // red</code></pre>

    <h2>12. How do you define a class with optional constructor parameters in TypeScript?</h2>
    <p>Optional constructor parameters are defined with a <code>?</code> after the parameter name.</p>
    <pre><code>class Person {
    constructor(public name: string, public age?: number) {}
}

const person1 = new Person("Alice");
const person2 = new Person("Bob", 30);

console.log(person1); // Person { name: 'Alice' }
console.log(person2); // Person { name: 'Bob', age: 30 }</code></pre>

    <h2>13. How do you use <code>readonly</code> with arrays in TypeScript?</h2>
    <p>The <code>readonly</code> modifier can be used to create an immutable array type.</p>
    <pre><code>const numbers: readonly number[] = [1, 2, 3];

// numbers[0] = 4; // Error: Index signature in type 'readonly number[]' only permits reading

console.log(numbers); // [1, 2, 3]</code></pre>

    <h2>14. How do you use <code>type inference</code> with <code>generics</code> in TypeScript?</h2>
    <p>Type inference with generics allows TypeScript to infer the type based on the arguments provided.</p>
    <pre><code>function identity<T>(value: T): T {
    return value;
}

const result = identity("Hello");
console.log(result); // Hello

const numberResult = identity(123);
console.log(numberResult); // 123</code></pre>

    <h2>15. How do you use <code>this</code> type in class methods in TypeScript?</h2>
    <p>The <code>this</code> type is used to refer to the instance of a class within its methods.</p>
    <pre><code>class Person {
    constructor(public name: string) {}

    greet(this: Person) {
        console.log(`Hello, my name is ${this.name}`);
    }
}

const person = new Person("Alice");
person.greet(); // Hello, my name is Alice</code></pre>

    <h2>16. How do you use <code>type guards</code> with custom types?</h2>
    <p>Custom type guards help TypeScript understand specific types at runtime.</p>
    <pre><code>interface Car {
    type: "car";
    drive(): void;
}

interface Bike {
    type: "bike";
    pedal(): void;
}

function isCar(vehicle: Car | Bike): vehicle is Car {
    return vehicle.type === "car";
}

const vehicle: Car | Bike = { type: "car", drive: () => console.log("Vroom") };

if (isCar(vehicle)) {
    vehicle.drive(); // Vroom
} else {
    vehicle.pedal(); // This will not run
}</code></pre>

    <h2>17. How do you use <code>overloads</code> in TypeScript functions?</h2>
    <p>Function overloads allow you to define multiple signatures for a function with different parameters.</p>
    <pre><code>function greet(person: string): string;
function greet(person: string, age: number): string;
function greet(person: string, age?: number): string {
    if (age !== undefined) {
        return `Hello ${person}, you are ${age} years old.`;
    }
    return `Hello ${person}`;
}

console.log(greet("Alice")); // Hello Alice
console.log(greet("Bob", 30)); // Hello Bob, you are 30 years old.</code></pre>

    <h2>18. How do you use <code>abstract classes</code> in TypeScript?</h2>
    <p>Abstract classes define methods that must be implemented by derived classes and cannot be instantiated directly.</p>
    <pre><code>abstract class Shape {
    abstract area(): number;

    describe(): string {
        return `The area is ${this.area()} square units.`;
    }
}

class Circle extends Shape {
    constructor(private radius: number) {
        super();
    }

    area(): number {
        return Math.PI * this.radius ** 2;
    }
}

const circle = new Circle(5);
console.log(circle.describe()); // The area is 78.53981633974483 square units.</code></pre>

    <h2>19. How do you use <code>conditional types</code> in TypeScript?</h2>
    <p>Conditional types allow you to create types based on a condition.</p>
    <pre><code>type TrueType = true extends true ? "Yes" : "No"; // "Yes"
type FalseType = false extends true ? "Yes" : "No"; // "No"

type Result<T> = T extends string ? "String" : "Other";
type Test1 = Result<string>; // "String"
type Test2 = Result<number>; // "Other"</code></pre>

    <h2>20. How do you use <code>indexed access types</code> in TypeScript?</h2>
    <p>Indexed access types allow you to access a property type using another type.</p>
    <pre><code>interface User {
    name: string;
    age: number;
}

type UserNameType = User["name"]; // string
type UserAgeType = User["age"]; // number

const name: UserNameType = "Alice";
const age: UserAgeType = 30;

console.log(name, age); // Alice 30</code></pre>

</body>
</html>
