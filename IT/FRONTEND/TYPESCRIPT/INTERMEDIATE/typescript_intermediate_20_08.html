<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TypeScript Intermediate Level Questions and Answers - Part 8</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        h2 {
            color: #2c3e50;
        }
        pre {
            background: #f4f4f4;
            border: 1px solid #ddd;
            padding: 10px;
            overflow-x: auto;
        }
        code {
            color: #d14;
        }
    </style>
</head>
<body>

    <h1>TypeScript Intermediate Level Questions and Answers - Part 8</h1>

    <h2>1. How do you use <code>Record</code> to create an object type with specific keys and values?</h2>
    <p>The <code>Record</code> utility type creates an object type with specific keys and value types.</p>
    <pre><code>type Person = Record<string, number>;

const ages: Person = {
    Alice: 30,
    Bob: 25
};

console.log(ages); // { Alice: 30, Bob: 25 }</code></pre>

    <h2>2. How do you use <code>Exclude</code> to remove types from a union type?</h2>
    <p>The <code>Exclude</code> utility type removes specified types from a union type.</p>
    <pre><code>type All = "a" | "b" | "c";
type Excluded = Exclude<All, "b">; // "a" | "c"

const value: Excluded = "a";
console.log(value); // a</code></pre>

    <h2>3. How do you use <code>Extract</code> to get common types from a union type?</h2>
    <p>The <code>Extract</code> utility type extracts common types from a union type.</p>
    <pre><code>type All = "a" | "b" | "c";
type Common = Extract<All, "b" | "c">; // "b" | "c"

const value: Common = "b";
console.log(value); // b</code></pre>

    <h2>4. How do you use <code>NonNullable</code> to remove <code>null</code> and <code>undefined</code> from a type?</h2>
    <p>The <code>NonNullable</code> utility type removes <code>null</code> and <code>undefined</code> from a type.</p>
    <pre><code>type MaybeString = string | null | undefined;
type NonNullString = NonNullable<MaybeString>; // string

const value: NonNullString = "Hello";
console.log(value); // Hello</code></pre>

    <h2>5. How do you use <code>Readonly</code> to make all properties of a type read-only?</h2>
    <p>The <code>Readonly</code> utility type makes all properties of a type read-only.</p>
    <pre><code>interface User {
    name: string;
    age: number;
}

const user: Readonly<User> = {
    name: "Alice",
    age: 30
};

// user.age = 31; // Error: Cannot assign to 'age' because it is a read-only property

console.log(user); // { name: 'Alice', age: 30 }</code></pre>

    <h2>6. How do you use <code>Parameters</code> to get parameter types of a function type?</h2>
    <p>The <code>Parameters</code> utility type extracts the parameter types from a function type.</p>
    <pre><code>function add(a: number, b: number): number {
    return a + b;
}

type AddParams = Parameters<typeof add>; // [number, number]

const params: AddParams = [1, 2];
console.log(add(...params)); // 3</code></pre>

    <h2>7. How do you use <code>ReturnType</code> to get the return type of a function?</h2>
    <p>The <code>ReturnType</code> utility type extracts the return type of a function type.</p>
    <pre><code>function getValue(): string {
    return "Hello";
}

type ValueType = ReturnType<typeof getValue>; // string

const value: ValueType = "World";
console.log(value); // World</code></pre>

    <h2>8. How do you use <code>InstanceType</code> to get the instance type of a class constructor?</h2>
    <p>The <code>InstanceType</code> utility type extracts the instance type from a class constructor.</p>
    <pre><code>class Person {
    constructor(public name: string) {}
}

type PersonInstance = InstanceType<typeof Person>;

const person: PersonInstance = new Person("Alice");
console.log(person.name); // Alice</code></pre>

    <h2>9. How do you use <code>typeof</code> to get the type of a variable?</h2>
    <p>The <code>typeof</code> operator can be used to get the type of a variable or expression.</p>
    <pre><code>const name = "Alice";
type NameType = typeof name; // string

const value: NameType = "Bob";
console.log(value); // Bob</code></pre>

    <h2>10. How do you use <code>keyof</code> to get the keys of an object type?</h2>
    <p>The <code>keyof</code> operator creates a union type of the keys of an object type.</p>
    <pre><code>interface Person {
    name: string;
    age: number;
}

type PersonKeys = keyof Person; // "name" | "age"

const key: PersonKeys = "name";
console.log(key); // name</code></pre>

    <h2>11. How do you use <code>Type Guards</code> to handle union types?</h2>
    <p>Type guards allow you to narrow down union types to more specific types.</p>
    <pre><code>function isString(value: string | number): value is string {
    return typeof value === "string";
}

function printValue(value: string | number) {
    if (isString(value)) {
        console.log("String:", value);
    } else {
        console.log("Number:", value);
    }
}

printValue("Hello"); // String: Hello
printValue(123);     // Number: 123</code></pre>

    <h2>12. How do you use <code>Custom Type Guards</code> to create user-defined type guards?</h2>
    <p>Custom type guards are functions that help in type narrowing.</p>
    <pre><code>interface Dog {
    bark(): void;
}

interface Cat {
    meow(): void;
}

function isDog(animal: Dog | Cat): animal is Dog {
    return (animal as Dog).bark !== undefined;
}

const animal: Dog | Cat = { bark: () => console.log("Woof!") };

if (isDog(animal)) {
    animal.bark(); // Woof!
} else {
    animal.meow();
}</code></pre>

    <h2>13. How do you use <code>type</code> to create a union type?</h2>
    <p>The <code>type</code> keyword is used to create a union type that allows a variable to be one of several types.</p>
    <pre><code>type ID = number | string;

const id1: ID = 123;
const id2: ID = "abc";

console.log(id1); // 123
console.log(id2); // abc</code></pre>

    <h2>14. How do you use <code>type</code> to create a tuple type?</h2>
    <p>The <code>type</code> keyword can create a tuple type with fixed-length and specific types.</p>
    <pre><code>type Person = [string, number];

const person: Person = ["Alice", 30];

console.log(person); // ['Alice', 30]</code></pre>

    <h2>15. How do you use <code>interface</code> to extend other interfaces?</h2>
    <p>The <code>interface</code> keyword allows you to extend other interfaces to create new interfaces.</p>
    <pre><code>interface Person {
    name: string;
}

interface Employee extends Person {
    employeeId: number;
}

const employee: Employee = {
    name: "Alice",
    employeeId: 123
};

console.log(employee); // { name: 'Alice', employeeId: 123 }</code></pre>

    <h2>16. How do you use <code>abstract classes</code> to create base classes with abstract methods?</h2>
    <p>Abstract classes cannot be instantiated directly and are used to define methods that must be implemented by subclasses.</p>
    <pre><code>abstract class Animal {
    abstract makeSound(): void;

    move(): void {
        console.log("Moving...");
    }
}

class Dog extends Animal {
    makeSound(): void {
        console.log("Woof!");
    }
}

const dog = new Dog();
dog.makeSound(); // Woof!
dog.move();      // Moving...</code></pre>

    <h2>17. How do you use <code>readonly</code> modifier to make object properties immutable?</h2>
    <p>The <code>readonly</code> modifier ensures that properties of an object cannot be modified after initialization.</p>
    <pre><code>interface Point {
    readonly x: number;
    readonly y: number;
}

const point: Point = { x: 10, y: 20 };

// point.x = 15; // Error: Cannot assign to 'x' because it is a read-only property

console.log(point); // { x: 10, y: 20 }</code></pre>

    <h2>18. How do you use <code>tuple</code> types with <code>rest</code> elements?</h2>
    <p>Tuple types can include <code>rest</code> elements to represent an array of elements after a fixed number of initial elements.</p>
    <pre><code>type TupleWithRest = [number, ...string[]];

const tuple: TupleWithRest = [1, "hello", "world"];

console.log(tuple); // [1, 'hello', 'world']</code></pre>

    <h2>19. How do you use <code>enum</code> to define a set of named constants?</h2>
    <p>The <code>enum</code> keyword creates a set of named constants for representing values.</p>
    <pre><code>enum Direction {
    Up,
    Down,
    Left,
    Right
}

const move: Direction = Direction.Up;

console.log(move); // 0</code></pre>

    <h2>20. How do you use <code>type</code> assertions to tell TypeScript the type of a variable?</h2>
    <p>Type assertions are used to override TypeScript's inferred type.</p>
    <pre><code>const value: any = "Hello, world!";
const length: number = (value as string).length;

console.log(length); // 13</code></pre>

</body>
</html>
