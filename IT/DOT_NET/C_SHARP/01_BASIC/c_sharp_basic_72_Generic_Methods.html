<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C# Generic Methods</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
            background-color: #f9f9f9;
        }
        h1, h2 {
            color: #333;
        }
        p {
            margin: 10px 0;
        }
        pre {
            background-color: #eee;
            border-radius: 5px;
            padding: 10px;
            font-family: Consolas, monospace;
        }
        code {
            font-family: Consolas, monospace;
        }
    </style>
</head>
<body>
    <h1>C# Generic Methods</h1>
    <p>Generic methods in C# allow you to create methods that can operate on different types of data. By using type parameters, you can write a single method that works with various types while maintaining type safety.</p>

    <h2>1. Declaring a Generic Method</h2>
    <p>To declare a generic method, specify the type parameter before the return type of the method. Here's an example of a generic method that swaps two values:</p>
    <pre><code>
public class Utilities
{
    // Generic method to swap two values
    public static void Swap&lt;T&gt;(ref T x, ref T y)
    {
        T temp = x;
        x = y;
        y = temp;
    }
}
    </code></pre>

    <h2>2. Using a Generic Method</h2>
    <p>You can call a generic method with different types. Here's how to use the <code>Swap&lt;T&gt;</code> method:</p>
    <pre><code>
public class Program
{
    public static void Main()
    {
        int a = 1, b = 2;
        Utilities.Swap&lt;int&gt;(ref a, ref b);
        Console.WriteLine($"Swapped integers: a = {a}, b = {b}");

        string first = "Hello", second = "World";
        Utilities.Swap&lt;string&gt;(ref first, ref second);
        Console.WriteLine($"Swapped strings: first = {first}, second = {second}");
    }
}
    </code></pre>

    <h2>3. Generic Methods with Constraints</h2>
    <p>Generic methods can also have constraints to restrict the types that can be used. For example, if you want a generic method to work only with types that implement a particular interface, you can use constraints:</p>
    <pre><code>
public class Processor
{
    public static void Print&lt;T&gt;(T item) where T : IPrintable
    {
        item.Print();
    }
}

public interface IPrintable
{
    void Print();
}

public class Document : IPrintable
{
    public void Print()
    {
        Console.WriteLine("Printing document...");
    }
}
    </code></pre>
    <p>In this example, the <code>Print&lt;T&gt;</code> method has a constraint that requires <code>T</code> to implement the <code>IPrintable</code> interface.</p>

    <h2>4. Key Points</h2>
    <ul>
        <li>Generic methods allow you to write methods that can handle various types while maintaining type safety.</li>
        <li>Type parameters are specified before the return type of the method.</li>
        <li>Generic methods can be constrained to restrict the types that can be used.</li>
    </ul>

    <h2>Conclusion</h2>
    <p>Generic methods in C# enhance code reusability and type safety by allowing you to define methods that can operate on multiple types. By using generics, you avoid code duplication and ensure that your methods can handle different types effectively.</p>
</body>
</html>
