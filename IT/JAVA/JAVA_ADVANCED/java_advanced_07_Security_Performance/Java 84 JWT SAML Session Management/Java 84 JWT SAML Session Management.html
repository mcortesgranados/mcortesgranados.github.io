<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JWT, SAML, and Session Management Questions</title>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        .question-set {
            margin-bottom: 20px;
        }
        .question {
            margin-bottom: 10px;
        }
        .answer {
            margin-left: 20px;
            font-style: italic;
        }
    </style>
</head>
<body>

    <div class="question-set">
        <h3>Set 1</h3>

        <div class="question">
            <p><strong>1. What is JWT and how does it work?</strong></p>
            <p class="answer">JWT (JSON Web Token) is an open standard (RFC 7519) that defines a compact and self-contained way to securely transmit information between parties as a JSON object. The information can be verified and trusted because it is digitally signed.</p>
        </div>

        <div class="question">
            <p><strong>2. What is the structure of a JWT token?</strong></p>
            <p class="answer">A JWT consists of three parts: a header, a payload, and a signature. The header typically consists of two parts: the type of the token (JWT) and the signing algorithm (e.g., HMAC SHA256 or RSA). The payload contains the claims. The signature is used to verify that the sender is who it says it is and to ensure that the message wasn’t changed along the way.</p>
        </div>

        <div class="question">
            <p><strong>3. How do you generate a JWT in Java?</strong></p>
            <p class="answer">You can use the `jjwt` library to generate a JWT in Java. Here's an example:</p>
            <pre><code>
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;

import java.util.Date;

public class JwtGenerator {
    public static String generateJWT() {
        return Jwts.builder()
                .setSubject("user123")
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + 1000 * 60 * 60)) // 1 hour
                .signWith(SignatureAlgorithm.HS256, "secretkey")
                .compact();
    }
}
            </code></pre>
        </div>

        <div class="question">
            <p><strong>4. What is SAML and how does it differ from JWT?</strong></p>
            <p class="answer">SAML (Security Assertion Markup Language) is an XML-based open standard for exchanging authentication and authorization data between parties, specifically between an identity provider and a service provider. Unlike JWT, which is more lightweight and JSON-based, SAML is XML-based and usually used for single sign-on (SSO) purposes.</p>
        </div>

        <div class="question">
            <p><strong>5. What are the advantages of using JWT over SAML?</strong></p>
            <p class="answer">JWT is more compact, JSON-based, and easier to parse compared to SAML, which uses XML. JWT is also typically used for RESTful APIs and mobile applications, while SAML is more commonly used in enterprise Single Sign-On (SSO) scenarios.</p>
        </div>

        <div class="question">
            <p><strong>6. What is session management in the context of web applications?</strong></p>
            <p class="answer">Session management refers to the process of securely storing and managing the state of a user's interaction with a web application. This involves maintaining information about the user's login status, preferences, and other context-specific data across multiple HTTP requests.</p>
        </div>

        <div class="question">
            <p><strong>7. How does token-based authentication work in JWT?</strong></p>
            <p class="answer">In token-based authentication, after a user successfully logs in, the server generates a JWT and sends it back to the client. The client then sends this token in the Authorization header in subsequent requests, allowing the server to authenticate the user based on the token’s validity and expiration.</p>
        </div>

        <div class="question">
            <p><strong>8. How can you validate a JWT in Java?</strong></p>
            <p class="answer">You can use the `jjwt` library to validate a JWT by parsing it with the secret key and verifying its signature. Here's an example:</p>
            <pre><code>
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureException;

public class JwtValidator {
    public static boolean validateJWT(String token, String secretKey) {
        try {
            Jwts.parser()
                    .setSigningKey(secretKey)
                    .parseClaimsJws(token); // Throws exception if the token is invalid
            return true;
        } catch (SignatureException e) {
            return false; // Invalid signature
        }
    }
}
            </code></pre>
        </div>

        <div class="question">
            <p><strong>9. What is the role of the signature in a JWT?</strong></p>
            <p class="answer">The signature in a JWT is used to verify that the sender of the JWT is who it says it is and to ensure that the message has not been altered. It is created using the header, payload, and a secret key or private key (in the case of asymmetric encryption). If the signature is valid, the recipient can trust the authenticity of the token.</p>
        </div>

      <div class="question">
            <p><strong>10. How do you handle JWT expiration in Java?</strong></p>
            <p class="answer">JWT expiration is handled by setting the expiration time when generating the token. The `exp` claim is used for this purpose. Once the token is expired, it will no longer be valid, and the user needs to reauthenticate. Here is how you can set the expiration:</p>
            <pre><code>
import java.util.Date;

public class JwtGenerator {
    public static String generateJWT() {
        return Jwts.builder()
                .setSubject("user123")
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + 1000 * 60 * 60)) // 1 hour
                .signWith(SignatureAlgorithm.HS256, "secretkey")
                .compact();
    }
}
            </code></pre>
            <p>&nbsp;</p>
            <h3>Set 2</h3>
            <div class="question">
              <p><strong>11. What are the common use cases for JWT?</strong></p>
              <p class="answer">JWT is commonly used for authentication and authorization in web applications and APIs. It is widely used in Single Page Applications (SPAs), mobile applications, and distributed systems where stateless authentication is required.</p>
            </div>
            <div class="question">
              <p><strong>12. What is the difference between a session cookie and a JWT?</strong></p>
              <p class="answer">A session cookie is typically stored on the server-side and associated with a session identifier. The server uses this ID to retrieve the session data. In contrast, JWT is a self-contained token stored on the client-side, containing user information and claims, which the server can validate without needing to maintain session state.</p>
            </div>
            <div class="question">
              <p><strong>13. How can you implement a secure JWT authentication system?</strong></p>
              <p class="answer">To implement a secure JWT authentication system, you should follow best practices such as using strong, random secret keys, setting a short expiration time for tokens, using HTTPS to transmit tokens, and validating the token's signature before trusting its content.</p>
            </div>
            <div class="question">
              <p><strong>14. What is the purpose of the 'aud' claim in a JWT?</strong></p>
              <p class="answer">The 'aud' (audience) claim identifies the intended recipient(s) of the JWT. It ensures that the token is only accepted by the specified audience and helps prevent misuse by third parties.</p>
            </div>
            <div class="question">
              <p><strong>15. Can a JWT be invalidated before its expiration?</strong></p>
              <p class="answer">JWT tokens are stateless and do not have a built-in mechanism for invalidation before expiration. However, you can implement a token revocation mechanism by maintaining a blacklist of invalid tokens or by using short-lived tokens and refresh tokens for better control.</p>
            </div>
            <div class="question">
              <p><strong>16. How does SAML handle user authentication?</strong></p>
              <p class="answer">In SAML, user authentication is handled by the identity provider (IdP). The IdP authenticates the user and sends a SAML response (assertion) to the service provider (SP) containing the user's authentication and authorization data.</p>
            </div>
            <div class="question">
              <p><strong>17. What is a SAML assertion?</strong></p>
              <p class="answer">A SAML assertion is an XML document containing the authentication, attribute, and authorization data issued by the identity provider. It is used by the service provider to establish the identity and permissions of the user.</p>
            </div>
            <div class="question">
              <p><strong>18. What are the security considerations when using SAML?</strong></p>
              <p class="answer">Security considerations when using SAML include ensuring the integrity and confidentiality of SAML assertions through digital signatures and encryption, using secure transport mechanisms like HTTPS, and validating the issuer and audience of the assertions to prevent attacks like replay or man-in-the-middle attacks.</p>
            </div>
            <div class="question">
              <p><strong>19. How can you integrate JWT with a Spring Boot application?</strong></p>
              <p class="answer">To integrate JWT with Spring Boot, you can use a filter that intercepts incoming requests, extracts the JWT from the Authorization header, validates it, and sets the authentication context. You can also use libraries like `spring-security` to simplify this process.</p>
              <pre><code>
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import io.jsonwebtoken.Jwts;

public class JwtFilter extends OncePerRequestFilter {
    private final String SECRET_KEY = "secretkey";
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        String token = request.getHeader("Authorization").replace("Bearer ", "");
        Claims claims = Jwts.parser()
            .setSigningKey(SECRET_KEY)
            .parseClaimsJws(token)
            .getBody();
        SecurityContextHolder.getContext().setAuthentication(new UsernamePasswordAuthenticationToken(claims.getSubject(), null, null));
        filterChain.doFilter(request, response);
    }
}
            </code></pre>
            </div>
            <h3>Set 3</h3>
            <div class="question">
              <p><strong>20. How does the refresh token mechanism work in JWT?</strong></p>
              <p class="answer">A refresh token is used to obtain a new access token after the old one has expired. The refresh token is typically long-lived and is stored securely. When the access token expires, the client can send the refresh token to the server to receive a new access token.</p>
            </div>
            <div class="question">
              <p><strong>21. How can you prevent CSRF attacks when using JWT?</strong></p>
              <p class="answer">To prevent CSRF attacks when using JWT, ensure that the token is sent in the Authorization header (Bearer token) rather than in a cookie. Additionally, using SameSite cookies can help mitigate the risk of cross-site request forgery.</p>
            </div>
            <div class="question">
              <p><strong>22. What are the key differences between JWT and OAuth?</strong></p>
              <p class="answer">JWT is a compact, self-contained token used for securely transmitting information between parties. OAuth is an authorization framework that allows third-party applications to access a user's resources without exposing credentials. JWT can be used as a token format in OAuth 2.0 for access tokens.</p>
            </div>
            <div class="question">
              <p><strong>23. How can you set a session timeout in a Spring Boot application?</strong></p>
              <p class="answer">To set a session timeout in Spring Boot, you can configure the `server.servlet.session.timeout` property in `application.properties` or `application.yml`. For example, to set the session timeout to 30 minutes, use:</p>
              <pre><code>
server.servlet.session.timeout=30m
            </code></pre>
            </div>
            <div class="question">
              <p><strong>24. What is the 'iat' claim in a JWT?</strong></p>
              <p class="answer">The 'iat' (issued at) claim is used to indicate the time at which the JWT was issued. It helps in determining the age of the token and can be used to prevent replay attacks by ensuring that the token was issued within an acceptable time frame.</p>
            </div>
            <div class="question">
              <p><strong>25. How does JWT support stateless authentication?</strong></p>
              <p class="answer">JWT supports stateless authentication by allowing the server to verify the token and authenticate the user without maintaining any session state. The token contains all necessary information to authenticate the user, reducing the need for server-side session storage.</p>
            </div>
            <div class="question">
              <p><strong>26. What is the role of the 'sub' claim in a JWT?</strong></p>
              <p class="answer">The 'sub' (subject) claim identifies the principal (usually the user) that the JWT is intended to represent. This claim is commonly used to store the user ID or username in the token payload.</p>
            </div>
            <div class="question">
              <p><strong>27. What is the difference between SAML and OpenID Connect?</strong></p>
              <p class="answer">SAML is an XML-based standard used primarily for Single Sign-On (SSO) in enterprise environments. OpenID Connect is a JSON-based protocol built on top of OAuth 2.0, designed for web and mobile apps to authenticate users and is more lightweight and easier to integrate compared to SAML.</p>
            </div>
            <div class="question">
              <p><strong>28. How does SSO (Single Sign-On) work with JWT?</strong></p>
              <p class="answer">SSO with JWT works by generating a JWT upon successful user authentication by the identity provider. This token can then be used by different services or applications to authenticate the user without the need for additional logins, ensuring a seamless user experience.</p>
            </div>
            <div class="question">
              <p><strong>29. How can you store a JWT securely on the client-side?</strong></p>
              <p class="answer">JWTs should be stored securely on the client-side in either localStorage or sessionStorage, with the latter offering a higher level of security due to its session scope. However, storing JWTs in HTTP-only, secure cookies is generally considered the most secure option as it helps prevent XSS attacks.</p>
            </div>
            <p>&nbsp;</p>
            <p>&nbsp;</p>
            <h3>Set 4</h3>
            <div class="question">
              <p><strong>30. How do you implement JWT token validation in Spring Security?</strong></p>
              <p class="answer">In Spring Security, JWT token validation can be implemented by creating a custom filter that intercepts the requests, extracts the token from the Authorization header, and validates its signature using the secret key. You then set the authentication context using the parsed claims.</p>
              <pre><code>
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    private final String SECRET_KEY = "secretkey";
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        String token = request.getHeader("Authorization").replace("Bearer ", "");
        Claims claims = Jwts.parser()
            .setSigningKey(SECRET_KEY)
            .parseClaimsJws(token)
            .getBody();
        Authentication authentication = new UsernamePasswordAuthenticationToken(claims.getSubject(), null, null);
        SecurityContextHolder.getContext().setAuthentication(authentication);
        filterChain.doFilter(request, response);
    }
}
            </code></pre>
            </div>
            <div class="question">
              <p><strong>31. What are the advantages of using JWT over traditional session-based authentication?</strong></p>
              <p class="answer">JWT provides several advantages, such as being stateless (no need to store session data on the server), scalability (easy to implement in distributed systems), and flexibility (it can carry custom claims, including user roles and permissions). It also works well for mobile applications and APIs.</p>
            </div>
            <div class="question">
              <p><strong>32. How does a JWT token handle authorization?</strong></p>
              <p class="answer">Authorization is handled by verifying the claims in the JWT. After the token is validated, the server can inspect the claims, such as user roles or permissions, to determine if the user has the necessary rights to access specific resources.</p>
            </div>
            <div class="question">
              <p><strong>33. Can JWT be used for Single Sign-On (SSO)?</strong></p>
              <p class="answer">Yes, JWT can be used for Single Sign-On (SSO). The identity provider can issue a JWT after successful authentication, and this token can be used to authenticate the user across multiple applications without needing to log in again.</p>
            </div>
            <div class="question">
              <p><strong>34. How does SAML handle user identity assertion?</strong></p>
              <p class="answer">In SAML, the identity provider (IdP) authenticates the user and then creates an assertion containing the user's identity and attributes. This assertion is digitally signed and sent to the service provider (SP), which uses it to grant access to the user.</p>
            </div>
            <div class="question">
              <p><strong>35. What is the difference between the 'NameID' and 'Subject' elements in SAML?</strong></p>
              <p class="answer">In SAML, the 'NameID' is an identifier for the user, typically representing a unique value like an email address. The 'Subject' element refers to the entity being authenticated (e.g., the user) and is usually included in the assertion as part of the overall authentication information.</p>
            </div>
            <div class="question">
              <p><strong>36. How do you configure a SAML Identity Provider (IdP) with Spring Security?</strong></p>
              <p class="answer">To configure a SAML Identity Provider with Spring Security, you can use the Spring Security SAML extension. This requires setting up metadata for the IdP, configuring the SAML authentication filter, and enabling the necessary SAML context parameters to handle assertions.</p>
            </div>
            <div class="question">
              <p><strong>37. What is a 'SAML Response' and what does it contain?</strong></p>
              <p class="answer">A SAML Response is an XML document containing a SAML Assertion from the identity provider. It contains information about the user, such as authentication statements, attributes, and possibly authorization decisions, and is sent to the service provider to establish the user's identity.</p>
            </div>
            <div class="question">
              <p><strong>38. What is the role of the 'Audience' element in SAML?</strong></p>
              <p class="answer">The 'Audience' element in SAML identifies the service provider (SP) that the assertion is intended for. It is used to ensure that the SAML assertion is valid only for the specified audience and prevents unauthorized parties from using the assertion.</p>
            </div>
            <div class="question">
              <p><strong>39. What is the main advantage of using SAML for Single Sign-On (SSO) over other protocols?</strong></p>
              <p class="answer">The main advantage of using SAML for SSO is its enterprise-level security, providing robust features such as strong authentication mechanisms, encrypted assertions, and digital signatures. It also supports federated identity management across different organizations.</p>
            </div>
            <p>&nbsp;</p>
            <p>&nbsp;</p>
            <h3>Set 5</h3>
            <div class="question">
              <p><strong>40. How do you configure session management in Spring Boot?</strong></p>
              <p class="answer">In Spring Boot, session management can be configured through the `application.properties` or `application.yml` file. For example, to configure a session timeout, use the following:</p>
              <pre><code>
server.servlet.session.timeout=30m
            </code></pre>
              <p>Alternatively, you can also configure session management in the `SecurityConfig` class using `HttpSecurity`:</p>
              <pre><code>
http.sessionManagement()
    .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)
    .maximumSessions(1)
    .expiredUrl("/sessionExpired");
            </code></pre>
            </div>
            <div class="question">
              <p><strong>41. What are the possible causes of a JWT token being rejected?</strong></p>
              <p class="answer">Possible causes of a JWT token being rejected include an invalid signature, an expired token (based on the 'exp' claim), an incorrect or missing 'iat' (issued at) claim, an invalid audience ('aud'), or a mismatch between the token issuer ('iss') and the expected issuer.</p>
            </div>
            <div class="question">
              <p><strong>42. How can you implement a token blacklist in a JWT-based authentication system?</strong></p>
              <p class="answer">To implement a token blacklist, you can maintain a list of invalidated JWT tokens (e.g., in a database or cache like Redis). Each time a request is made, you can check if the token is in the blacklist before validating it. If it’s blacklisted, reject the request.</p>
            </div>
            <div class="question">
              <p><strong>43. How can you ensure secure transmission of JWT tokens over HTTP?</strong></p>
              <p class="answer">To ensure secure transmission of JWT tokens, always use HTTPS (SSL/TLS) to encrypt communication between the client and server. This prevents attackers from intercepting the token during transmission (man-in-the-middle attacks).</p>
            </div>
            <div class="question">
              <p><strong>44. How does the 'exp' claim in a JWT work?</strong></p>
              <p class="answer">The 'exp' (expiration time) claim in a JWT specifies the date and time when the token will expire. After this time, the token is considered invalid. The 'exp' claim is used to enforce token expiration and to prevent replay attacks with expired tokens.</p>
            </div>
            <div class="question">
              <p><strong>45. What is the 'jti' claim in a JWT?</strong></p>
              <p class="answer">The 'jti' (JWT ID) claim is a unique identifier for the token. It can be used to prevent replay attacks by ensuring that each token is unique. If a token is used more than once, it can be detected by checking the 'jti' value.</p>
            </div>
            <div class="question">
              <p><strong>46. What is the difference between 'stateless' and 'stateful' authentication?</strong></p>
              <p class="answer">In stateless authentication (e.g., JWT), the server does not store session information, and each request contains all necessary information to authenticate the user. In stateful authentication, the server maintains session data (e.g., session ID), which must be checked on each request.</p>
            </div>
            <div class="question">
              <p><strong>47. What are the main benefits of using JWT for authentication in microservices architecture?</strong></p>
              <p class="answer">JWT provides several benefits in a microservices architecture: it’s lightweight, stateless, and can be used to authenticate across distributed services. Each service can independently validate the token without relying on a central session store, leading to improved scalability and performance.</p>
            </div>
            <div class="question">
              <p><strong>48. How does the 'aud' (audience) claim work in a JWT?</strong></p>
              <p class="answer">The 'aud' (audience) claim specifies the intended recipient(s) of the token. The token will only be valid if the audience claim matches the expected value. This ensures that the token is not used by unauthorized parties.</p>
            </div>
            <div class="question">
              <p><strong>49. How can you refresh a JWT token in a secure manner?</strong></p>
              <p class="answer">To refresh a JWT token securely, use a refresh token that is stored securely (e.g., in an HTTP-only cookie). When the access token expires, the client can send the refresh token to the server to obtain a new access token, keeping the refresh token’s lifetime longer than the access token's.</p>
            </div>
            <p>&nbsp;</p>
            <p>&nbsp;</p>
            <h3>Set 6</h3>
            <div class="question">
              <p><strong>50. How do you configure a session timeout in Spring Security?</strong></p>
              <p class="answer">In Spring Security, you can configure a session timeout by using the `session-management` element in the `http` configuration of your `SecurityConfig` class:</p>
              <pre><code>
http
    .sessionManagement()
    .invalidSessionUrl("/sessionExpired")
    .maximumSessions(1)
    .expiredUrl("/sessionExpired");
            </code></pre>
            </div>
            <div class="question">
              <p><strong>51. How does token-based authentication work in a distributed system?</strong></p>
              <p class="answer">Token-based authentication works by embedding the user’s identity and permissions into a token (e.g., JWT), which is passed with each request. Since tokens are stateless, no session information needs to be shared between distributed systems, making the system scalable and resilient.</p>
            </div>
            <div class="question">
              <p><strong>52. What is the difference between OAuth 2.0 and SAML?</strong></p>
              <p class="answer">OAuth 2.0 is an authorization framework that allows a third-party application to access user resources on a server without exposing the user's credentials. SAML is an authentication protocol used for Single Sign-On (SSO), where an identity provider authenticates a user and sends an assertion to a service provider. OAuth 2.0 is typically used for API authorization, while SAML is often used for enterprise SSO.</p>
            </div>
            <div class="question">
              <p><strong>53. How does the OAuth 2.0 authorization code flow work?</strong></p>
              <p class="answer">In the OAuth 2.0 authorization code flow, the client application redirects the user to the authorization server to authenticate. Upon successful authentication, the server redirects the user back to the client with an authorization code. The client exchanges the authorization code for an access token and refresh token to authenticate subsequent API calls.</p>
            </div>
            <div class="question">
              <p><strong>54. How do you implement secure logout in a token-based authentication system?</strong></p>
              <p class="answer">To implement secure logout in a token-based authentication system, the client should delete the token from storage (e.g., local storage or cookies) and the server should invalidate the token by adding it to a blacklist, ensuring it cannot be used in future requests.</p>
            </div>
            <div class="question">
              <p><strong>55. How can you configure a custom login page in Spring Security?</strong></p>
              <p class="answer">In Spring Security, you can configure a custom login page by overriding the default login page URL. This can be done using the following code in the `SecurityConfig` class:</p>
              <pre><code>
http.formLogin()
    .loginPage("/login")
    .permitAll();
            </code></pre>
            </div>
            <div class="question">
              <p><strong>56. How do you handle user authentication in a REST API?</strong></p>
              <p class="answer">User authentication in a REST API is typically done using token-based methods such as JWT. The user provides credentials (e.g., username and password) to the API, which returns a JWT. This token is then included in the Authorization header of subsequent requests for authentication.</p>
            </div>
            <div class="question">
              <p><strong>57. What is the purpose of the 'sub' claim in a JWT?</strong></p>
              <p class="answer">The 'sub' (subject) claim in a JWT identifies the principal (user or entity) that the token is associated with. This is typically used to represent the user ID or username within the token, making it easy to associate the token with a specific user.</p>
            </div>
            <div class="question">
              <p><strong>58. How does the 'scope' parameter work in OAuth 2.0?</strong></p>
              <p class="answer">The 'scope' parameter in OAuth 2.0 defines the permissions that the client is requesting from the user. For example, it can specify whether the client is requesting access to the user's email, profile, or other data. The authorization server then grants or denies access based on the requested scope.</p>
            </div>
            <div class="question">
              <p><strong>59. How can you handle session fixation attacks in Spring Security?</strong></p>
              <p class="answer">To prevent session fixation attacks, Spring Security provides the option to change the session ID after authentication. This ensures that attackers cannot hijack an existing session. You can configure this in the `SecurityConfig` class:</p>
              <pre><code>
http.sessionManagement()
    .sessionFixation().migrateSession();
            </code></pre>
            </div>
            <p>&nbsp;</p>
            <h3>Set 7</h3>
            <div class="question">
              <p><strong>60. How do you implement role-based access control (RBAC) in Spring Security?</strong></p>
              <p class="answer">Role-based access control (RBAC) can be implemented in Spring Security by using the `@PreAuthorize` annotation or configuring HTTP security to restrict access based on roles:</p>
              <pre><code>
http.authorizeRequests()
    .antMatchers("/admin/**").hasRole("ADMIN")
    .antMatchers("/user/**").hasAnyRole("USER", "ADMIN");
            </code></pre>
            </div>
            <div class="question">
              <p><strong>61. What is the role of the 'iss' (issuer) claim in a JWT?</strong></p>
              <p class="answer">The 'iss' (issuer) claim identifies the principal that issued the token. It helps to verify that the token was issued by a trusted source. This claim is especially useful when the token can be used across different applications or services.</p>
            </div>
            <div class="question">
              <p><strong>62. How do you validate a JWT token in Java?</strong></p>
              <p class="answer">To validate a JWT token in Java, you can use the `io.jsonwebtoken.Jwts` library. Here’s how you can do it:</p>
              <pre><code>
Claims claims = Jwts.parser()
    .setSigningKey(SECRET_KEY)
    .parseClaimsJws(token)
    .getBody();
            </code></pre>
              <p>Make sure to handle the possible exceptions such as `ExpiredJwtException`, `SignatureException`, etc.</p>
            </div>
            <div class="question">
              <p><strong>63. How do you store a JWT token securely in a web application?</strong></p>
              <p class="answer">A JWT token should be stored securely, preferably in an HTTP-only cookie. This prevents JavaScript from accessing the token, mitigating XSS attacks. Alternatively, it can be stored in local storage, but this exposes it to potential attacks, so it should be avoided for highly sensitive applications.</p>
            </div>
            <div class="question">
              <p><strong>64. How do you handle CORS issues in a Spring Boot REST API?</strong></p>
              <p class="answer">Cross-Origin Resource Sharing (CORS) issues can be handled by configuring the `CorsRegistry` in Spring Security or through the `@CrossOrigin` annotation:</p>
              <pre><code>
@CrossOrigin(origins = "http://example.com")
@RestController
public class MyController {
    // controller methods
}
            </code></pre>
              <p>Alternatively, you can configure it globally in the `WebMvcConfigurer` class:</p>
              <pre><code>
@Override
public void addCorsMappings(CorsRegistry registry) {
    registry.addMapping("/**").allowedOrigins("http://example.com");
}
            </code></pre>
            </div>
            <div class="question">
              <p><strong>65. How do you prevent token theft in a JWT-based authentication system?</strong></p>
              <p class="answer">To prevent token theft, use HTTPS to encrypt the transmission of JWT tokens and store tokens in secure, HTTP-only cookies. Additionally, implement proper token expiration and refresh mechanisms to minimize the impact of a stolen token.</p>
            </div>
            <div class="question">
              <p><strong>66. What is the role of the 'nbf' (not before) claim in a JWT?</strong></p>
              <p class="answer">The 'nbf' (not before) claim defines the time before which the JWT should not be considered valid. It helps to prevent the token from being used before the specified time.</p>
            </div>
            <div class="question">
              <p><strong>67. How does session fixation prevention work in Spring Security?</strong></p>
              <p class="answer">Spring Security provides session fixation protection by allowing the session ID to be changed after successful authentication. You can configure it using the following code:</p>
              <pre><code>
http.sessionManagement()
    .sessionFixation().migrateSession();
            </code></pre>
              <p>This ensures that the attacker cannot hijack a session before or after login.</p>
            </div>
            <div class="question">
              <p><strong>68. How do you implement Single Sign-On (SSO) using SAML in a Spring Boot application?</strong></p>
              <p class="answer">To implement SSO using SAML, you can use the `spring-security-saml` library. First, configure a `Saml2WebSsoAuthenticationFilter`, then set up your identity provider (IdP) and service provider (SP). You'll also need to configure metadata and endpoint URLs for SSO to work.</p>
            </div>
            <div class="question">
              <p><strong>69. What is the difference between a JWT and an OAuth token?</strong></p>
              <p class="answer">A JWT is a type of token that can be used for both authentication and authorization, containing claims like user info and expiration time. An OAuth token is a broader concept used to grant access to resources on behalf of a user. OAuth tokens can be JWTs, but they can also be other formats such as opaque tokens, which do not carry any user information.</p>
            </div>
            <p>&nbsp;</p>
            <h3>Set 8</h3>
            <div class="question">
              <p><strong>70. What are the main components of a SAML assertion?</strong></p>
              <p class="answer">A SAML assertion consists of three main components: the `Subject`, which identifies the user; the `Conditions`, which define the validity period and restrictions of the assertion; and the `AuthnStatement`, which contains the authentication information about the user.</p>
            </div>
            <div class="question">
              <p><strong>71. How do you implement token revocation in a JWT authentication system?</strong></p>
              <p class="answer">Token revocation can be implemented by maintaining a blacklist of revoked tokens. When a token is revoked, it is added to the blacklist, and on each request, the system checks if the token exists in the blacklist before proceeding with the authentication process.</p>
            </div>
            <div class="question">
              <p><strong>72. How do you configure the session timeout in a Java web application using Spring Boot?</strong></p>
              <p class="answer">In Spring Boot, session timeout can be configured in the `application.properties` or `application.yml` file:</p>
              <pre><code>
server.servlet.session.timeout=30m
            </code></pre>
              <p>This sets the session timeout to 30 minutes.</p>
            </div>
            <div class="question">
              <p><strong>73. How do you implement Single Sign-On (SSO) using OAuth 2.0?</strong></p>
              <p class="answer">To implement SSO with OAuth 2.0, you can use an OAuth 2.0 authorization server such as Keycloak or Okta. The user authenticates once with the authorization server, which provides an access token that can be used across different services within the same organization or ecosystem.</p>
            </div>
            <div class="question">
              <p><strong>74. How do you authenticate a user using a JWT in Spring Boot?</strong></p>
              <p class="answer">In Spring Boot, you can authenticate a user using a JWT by creating a custom filter that extracts the token from the `Authorization` header. The filter then validates the token and sets the `Authentication` object in the security context:</p>
              <pre><code>
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException {
        String token = request.getHeader("Authorization").substring(7); // Extract token
        if (token != null && validateToken(token)) {
            Authentication auth = new UsernamePasswordAuthenticationToken(user, null, authorities);
            SecurityContextHolder.getContext().setAuthentication(auth);
        }
        chain.doFilter(request, response);
    }
}
            </code></pre>
            </div>
            <div class="question">
              <p><strong>75. What are the advantages of using JWT over session-based authentication?</strong></p>
              <p class="answer">JWT provides several advantages over session-based authentication, including statelessness, scalability, and reduced server-side storage requirements. Since the token is self-contained, the server does not need to store session data, which is particularly beneficial in distributed systems.</p>
            </div>
            <div class="question">
              <p><strong>76. How can you handle JWT expiration in a Spring Boot application?</strong></p>
              <p class="answer">JWT expiration can be handled by setting an expiration claim (`exp`) in the token and checking it on each request. If the token is expired, the server can respond with an error message, prompting the user to re-authenticate or refresh the token using a refresh token mechanism.</p>
            </div>
            <div class="question">
              <p><strong>77. What is the difference between a public key and a private key in JWT authentication?</strong></p>
              <p class="answer">In JWT authentication, a public key is used to verify the signature of the JWT (authentication), while the private key is used to sign the token. The private key should be kept secret, while the public key is shared with anyone who needs to validate the token.</p>
            </div>
            <div class="question">
              <p><strong>78. What is the purpose of the 'aud' (audience) claim in a JWT?</strong></p>
              <p class="answer">The 'aud' (audience) claim defines the intended recipient(s) of the token. It is used to ensure that the token is being sent to the correct service or API. If the 'aud' claim does not match the service that is validating the token, the token will be considered invalid.</p>
            </div>
            <div class="question">
              <p><strong>79. How do you prevent Cross-Site Request Forgery (CSRF) attacks when using token-based authentication?</strong></p>
              <p class="answer">To prevent CSRF attacks when using token-based authentication, you can use the `SameSite` cookie attribute to restrict cross-site cookie sending, or implement token-based mechanisms like anti-CSRF tokens in addition to JWT authentication.</p>
            </div>
            <p>&nbsp;</p>
            <h3>Set 9</h3>
            <div class="question">
              <p><strong>80. What is the 'sub' claim in a JWT?</strong></p>
              <p class="answer">The 'sub' (subject) claim is used to represent the principal (usually the user) that the token is identifying. It is often the unique identifier of the user in the system.</p>
            </div>
            <div class="question">
              <p><strong>81. How do you secure a JWT token stored in localStorage?</strong></p>
              <p class="answer">JWT tokens stored in localStorage can be exposed to XSS attacks. To secure the token, it is best to use HTTPS to encrypt communications, avoid storing sensitive tokens in localStorage if possible, and implement Content Security Policy (CSP) to mitigate XSS risks.</p>
            </div>
            <div class="question">
              <p><strong>82. What is the difference between SAML 2.0 and OAuth 2.0?</strong></p>
              <p class="answer">SAML 2.0 is primarily used for Single Sign-On (SSO) in enterprise environments and is based on XML. OAuth 2.0 is a more general-purpose authorization framework that allows third-party applications to access user resources without exposing user credentials. OAuth is typically used with JSON-based tokens (like JWT).</p>
            </div>
            <div class="question">
              <p><strong>83. How do you implement token expiration and refresh in Spring Boot with JWT?</strong></p>
              <p class="answer">To implement token expiration and refresh in Spring Boot with JWT, you can set an expiration time for the JWT and create a refresh token endpoint. When the JWT expires, the client can send the refresh token to get a new JWT without re-authenticating the user.</p>
              <pre><code>
public class JwtTokenUtil {
    private static final long EXPIRATION_TIME = 86400000; // 24 hours
    private static final String SECRET_KEY = "your_secret_key";

    public static String generateToken(String username) {
        return Jwts.builder()
            .setSubject(username)
            .setExpiration(new Date(System.currentTimeMillis() + EXPIRATION_TIME))
            .signWith(SignatureAlgorithm.HS256, SECRET_KEY)
            .compact();
    }
}
            </code></pre>
            </div>
            <div class="question">
              <p><strong>84. What is the purpose of the 'jti' (JWT ID) claim in a JWT?</strong></p>
              <p class="answer">The 'jti' (JWT ID) claim is used to uniquely identify the token. It is useful for preventing replay attacks, as you can store the JWT ID on the server and check if the token has already been used.</p>
            </div>
            <div class="question">
              <p><strong>85. How do you implement OAuth 2.0 authorization in a Spring Boot application?</strong></p>
              <p class="answer">OAuth 2.0 authorization can be implemented in Spring Boot by using Spring Security’s OAuth 2.0 client support. You configure the `application.yml` or `application.properties` to include your OAuth provider's details, then secure your endpoints with the `@PreAuthorize` annotation.</p>
              <pre><code>
spring:
  security:
    oauth2:
      client:
        registration:
          google:
            client-id: YOUR_CLIENT_ID
            client-secret: YOUR_CLIENT_SECRET
            scope: profile, email
            redirect-uri: "{baseUrl}/login/oauth2/code/{registrationId}"
        provider:
          google:
            authorization-uri: https://accounts.google.com/o/oauth2/auth
            token-uri: https://oauth2.googleapis.com/token
            user-info-uri: https://www.googleapis.com/oauth2/v3/userinfo
            user-name-attribute: id
            jwk-set-uri: https://www.googleapis.com/oauth2/v3/certs
            client-name: Google
            client-alias: google
            client-authentication-method: post
            login-page-url: /login/oauth2/code/google
            authorization-code-uri: /oauth2/authorization/google
            redirect-uri: http://localhost:8080/login/oauth2/code/google
            client-id: YOUR_GOOGLE_CLIENT_ID
            client-secret: YOUR_GOOGLE_CLIENT_SECRET
      </code></pre>
            </div>
            <div class="question">
              <p><strong>86. How do you configure session management for distributed applications in Spring Boot?</strong></p>
              <p class="answer">For distributed applications, you can configure Spring Boot to use a shared session store like Redis to ensure session data is consistent across multiple instances. You can use the `spring-session` project to integrate Redis with Spring Boot:</p>
              <pre><code>
spring:
  session:
    store-type: redis
    redis:
      host: localhost
      port: 6379
      database: 0
      timeout: 60000
            </code></pre>
            </div>
            <div class="question">
              <p><strong>87. How do you handle user authorization in a microservices architecture?</strong></p>
              <p class="answer">In a microservices architecture, user authorization can be managed using JWTs for stateless authentication. Each microservice can validate the JWT and check the user’s roles or permissions to grant access. Centralized authorization can be achieved by using an OAuth 2.0 authorization server or a service like Keycloak.</p>
            </div>
            <div class="question">
              <p><strong>88. What is the purpose of the 'aud' claim in a JWT?</strong></p>
              <p class="answer">The 'aud' (audience) claim specifies the intended recipient(s) of the token. It ensures that the token is only used by the services or parties that the token was issued for, providing an additional layer of validation and security.</p>
            </div>
            <div class="question">
              <p><strong>89. How do you prevent JWT replay attacks?</strong></p>
              <p class="answer">JWT replay attacks can be prevented by including the 'jti' claim (JWT ID) in the token and maintaining a record of the used JWT IDs on the server. Additionally, using short-lived access tokens and issuing refresh tokens can reduce the window for replay attacks.</p>
            </div>
            <p>&nbsp;</p>
            <h3>Set 10</h3>
            <div class="question">
              <p><strong>90. How do you secure a SAML assertion?</strong></p>
              <p class="answer">SAML assertions can be secured by using XML Signature and XML Encryption. The assertion can be signed with a private key to verify the sender's identity, and the data can be encrypted to prevent unauthorized access.</p>
            </div>
            <div class="question">
              <p><strong>91. What is the role of the identity provider (IdP) in SAML authentication?</strong></p>
              <p class="answer">The Identity Provider (IdP) is responsible for authenticating users and providing the necessary identity information in the form of SAML assertions. The IdP communicates with the Service Provider (SP) to confirm the user's identity.</p>
            </div>
            <div class="question">
              <p><strong>92. How does OAuth 2.0 handle authorization codes?</strong></p>
              <p class="answer">In OAuth 2.0, the authorization code is a temporary code that the client application exchanges for an access token and possibly a refresh token. The code is received after the user authorizes the client and is sent back to the client's redirect URI.</p>
            </div>
            <div class="question">
              <p><strong>93. How do you implement SSO using JWT in a Spring Boot application?</strong></p>
              <p class="answer">To implement SSO using JWT in Spring Boot, you can use Spring Security with JWT. After user authentication, a JWT token is generated and passed to the client. The client includes the token in the Authorization header for every request, and each microservice can validate the JWT for access control.</p>
              <pre><code>
public class JwtTokenProvider {
    private String secretKey = "secret";

    public String generateToken(String username) {
        return Jwts.builder()
            .setSubject(username)
            .setIssuedAt(new Date())
            .setExpiration(new Date(System.currentTimeMillis() + 86400000))
            .signWith(SignatureAlgorithm.HS256, secretKey)
            .compact();
    }
}
            </code></pre>
            </div>
            <div class="question">
              <p><strong>94. How does session management work with JWT?</strong></p>
              <p class="answer">With JWT, session management is stateless. The server does not store any session information, but instead, the JWT contains all the necessary user authentication details. The client is responsible for sending the token with each request, and the server validates the token to authenticate the user.</p>
            </div>
            <div class="question">
              <p><strong>95. How can you implement logout functionality with JWT?</strong></p>
              <p class="answer">In a JWT-based system, logout functionality can be implemented by simply deleting the JWT from the client (e.g., localStorage or sessionStorage). Since JWTs are stateless, the server does not need to manage user sessions, but the client must ensure that the token is no longer used.</p>
            </div>
            <div class="question">
              <p><strong>96. What is the difference between bearer tokens and SAML tokens?</strong></p>
              <p class="answer">Bearer tokens are typically used in OAuth 2.0 and JWT-based authentication. They are short-lived tokens that are included in the HTTP Authorization header. SAML tokens, on the other hand, are XML-based tokens used in SAML authentication for Single Sign-On (SSO) systems. SAML tokens are typically larger and contain identity information about the user.</p>
            </div>
            <div class="question">
              <p><strong>97. What are the advantages of using JWT over traditional session-based authentication?</strong></p>
              <p class="answer">JWT provides several advantages over traditional session-based authentication, including statelessness (the server does not need to store session data), scalability (works well in distributed systems), and performance (fewer round trips to the server for validation). JWTs are also portable and can be easily used across different domains and services.</p>
            </div>
            <div class="question">
              <p><strong>98. How do you implement token revocation with JWT?</strong></p>
              <p class="answer">Token revocation with JWT can be achieved by maintaining a blacklist of revoked tokens or using short-lived tokens along with refresh tokens. If the user logs out or their access is revoked, the JWT can be added to the blacklist, and any future requests with the revoked token will be denied.</p>
            </div>
            <div class="question">
              <p><strong>99. How do you use JWT for user role-based access control in Spring Security?</strong></p>
              <p class="answer">JWT can be used for role-based access control by including the user's roles or permissions in the JWT claims (e.g., 'roles' claim). Spring Security can then extract these roles from the JWT and grant access to specific endpoints based on the user's roles.</p>
              <pre><code>
public class JwtTokenFilter extends OncePerRequestFilter {
    private JwtTokenProvider jwtTokenProvider;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        String token = request.getHeader("Authorization");

        if (token != null && token.startsWith("Bearer ")) {
            token = token.substring(7);
            if (jwtTokenProvider.validateToken(token)) {
                String roles = jwtTokenProvider.getRoles(token);
                SecurityContextHolder.getContext().setAuthentication(new UsernamePasswordAuthenticationToken(token, null, getAuthorities(roles)));
            }
        }
        filterChain.doFilter(request, response);
    }

    private Collection getAuthorities(String roles) {
        return Arrays.stream(roles.split(","))
            .map(SimpleGrantedAuthority::new)
            .collect(Collectors.toList());
    }
}
            </code></pre>
            </div>
            <p>&nbsp;</p>
            <h3>Set 11</h3>
            <div class="question">
              <p><strong>100. How do you handle token expiration in JWT-based authentication?</strong></p>
              <p class="answer">Token expiration in JWT can be managed by including an "exp" claim in the token. When the token is validated, the server checks if the current time is before the expiration time. If the token is expired, the user must re-authenticate or obtain a new token using a refresh token.</p>
            </div>
            <div class="question">
              <p><strong>101. How does session fixation attack work, and how can it be prevented?</strong></p>
              <p class="answer">A session fixation attack occurs when an attacker sets a user's session ID before they authenticate, allowing the attacker to hijack the session. It can be prevented by regenerating the session ID after successful authentication and using secure, HttpOnly session cookies.</p>
            </div>
            <div class="question">
              <p><strong>102. How do you implement JWT refresh tokens in a Spring Boot application?</strong></p>
              <p class="answer">In a Spring Boot application, you can implement JWT refresh tokens by generating a new access token when the refresh token is sent to the server. The refresh token itself has a longer expiration time and is used to issue a new short-lived access token.</p>
              <pre><code>
public class JwtRefreshTokenProvider {
    private String refreshSecretKey = "refresh_secret";

    public String generateRefreshToken(String username) {
        return Jwts.builder()
            .setSubject(username)
            .setIssuedAt(new Date())
            .setExpiration(new Date(System.currentTimeMillis() + 2592000000L))  // 30 days
            .signWith(SignatureAlgorithm.HS256, refreshSecretKey)
            .compact();
    }
}
            </code></pre>
            </div>
            <div class="question">
              <p><strong>103. How can you protect against Cross-Site Request Forgery (CSRF) in a JWT-based system?</strong></p>
              <p class="answer">In a JWT-based system, CSRF attacks can be mitigated by using SameSite cookies or by storing JWTs in a secure location like HttpOnly cookies or localStorage, and ensuring that the token is sent only with requests made from the same origin.</p>
            </div>
            <div class="question">
              <p><strong>104. What is the difference between a session cookie and a persistent cookie?</strong></p>
              <p class="answer">A session cookie is temporary and is deleted when the browser is closed. A persistent cookie has an expiration date set by the server and remains on the client's device until it expires or is deleted manually.</p>
            </div>
            <div class="question">
              <p><strong>105. How do you handle user identity management in a microservices architecture with JWT?</strong></p>
              <p class="answer">In a microservices architecture, user identity management with JWT involves using a centralized authentication service (e.g., an Identity Provider) that issues a JWT. Each microservice validates the JWT in each request to authenticate the user and enforce access control policies.</p>
            </div>
            <div class="question">
              <p><strong>106. How do you handle cross-domain authentication with JWT?</strong></p>
              <p class="answer">Cross-domain authentication with JWT is handled by configuring the server to accept JWT tokens from multiple domains and by setting proper CORS (Cross-Origin Resource Sharing) headers. The JWT is included in the Authorization header and is validated across different domains.</p>
            </div>
            <div class="question">
              <p><strong>107. How can you implement single sign-out (SSO) in a JWT-based authentication system?</strong></p>
              <p class="answer">Single sign-out (SSO) can be implemented in a JWT-based system by invalidating the JWT or adding it to a token blacklist at the time of logout. Additionally, you may notify other services in the system that the user has logged out, ensuring that no requests are accepted with the expired token.</p>
            </div>
            <div class="question">
              <p><strong>108. What is the role of a Service Provider (SP) in SAML authentication?</strong></p>
              <p class="answer">The Service Provider (SP) relies on the Identity Provider (IdP) for user authentication. After the IdP authenticates the user, the SP uses the SAML assertion to obtain user attributes and authorize the user to access its resources.</p>
            </div>
            <div class="question">
              <p><strong>109. How does JWT handle authentication across different devices?</strong></p>
              <p class="answer">JWT handles authentication across different devices by issuing the same token to all devices after a successful login. The token can be used on any device to authenticate requests, and each device must include the token in the Authorization header when making API calls.</p>
            </div>
            <p>&nbsp;</p>
            <h3>Set 12</h3>
            <div class="question">
              <p><strong>110. How do you ensure secure storage of JWT tokens in a browser?</strong></p>
              <p class="answer">JWT tokens should be stored in HttpOnly, Secure cookies to prevent access by JavaScript and to ensure the token is transmitted only over HTTPS. Alternatively, tokens can be stored in memory (sessionStorage or localStorage) but should be handled carefully to prevent XSS attacks.</p>
            </div>
            <div class="question">
              <p><strong>111. What is the role of the Identity Provider (IdP) in a SAML authentication process?</strong></p>
              <p class="answer">The Identity Provider (IdP) is responsible for authenticating users and providing the Service Provider (SP) with a SAML assertion containing user identity information. The IdP validates the user's credentials and generates the assertion sent to the SP.</p>
            </div>
            <div class="question">
              <p><strong>112. What are the advantages of using JWT over traditional session-based authentication?</strong></p>
              <p class="answer">JWT provides stateless authentication, meaning there is no need to store session information on the server. This improves scalability and reduces server-side storage overhead. Additionally, JWT tokens can be used across multiple domains and devices easily.</p>
            </div>
            <div class="question">
              <p><strong>113. How can you secure a JWT token during transmission?</strong></p>
              <p class="answer">JWT tokens should always be transmitted over HTTPS to prevent interception during transmission. Using the HTTPS protocol ensures that the token is encrypted and prevents man-in-the-middle (MITM) attacks.</p>
            </div>
            <div class="question">
              <p><strong>114. What is the difference between JWT and OAuth 2.0?</strong></p>
              <p class="answer">JWT is a token format that is commonly used for authentication and information exchange, while OAuth 2.0 is an authorization framework that allows third-party applications to access resources on behalf of a user without exposing their credentials. OAuth 2.0 often uses JWT as an access token format.</p>
            </div>
            <div class="question">
              <p><strong>115. How can you implement role-based access control (RBAC) using JWT?</strong></p>
              <p class="answer">Role-based access control (RBAC) can be implemented in JWT by including user roles as claims within the JWT token. When the token is received, the server can check the roles in the token and enforce access control policies based on the user's role.</p>
              <pre><code>
public class JwtRoleValidator {
    public boolean hasRole(String jwtToken, String requiredRole) {
        Claims claims = Jwts.parser()
                            .setSigningKey("your_secret_key")
                            .parseClaimsJws(jwtToken)
                            .getBody();
        String role = claims.get("role", String.class);
        return role.equals(requiredRole);
    }
}
            </code></pre>
            </div>
            <div class="question">
              <p><strong>116. What is the purpose of the "aud" (audience) claim in a JWT?</strong></p>
              <p class="answer">The "aud" (audience) claim identifies the intended recipient(s) of the JWT. It ensures that the token is used only by the correct audience, such as a specific service or application, and can help prevent misuse of the token by unauthorized services.</p>
            </div>
            <div class="question">
              <p><strong>117. What are the key differences between SAML and OpenID Connect?</strong></p>
              <p class="answer">SAML is an older XML-based protocol primarily used for Single Sign-On (SSO) in enterprise environments, while OpenID Connect is a modern, JSON-based protocol built on top of OAuth 2.0. OpenID Connect is simpler and more suitable for mobile and web applications.</p>
            </div>
            <div class="question">
              <p><strong>118. How can you implement SAML Single Logout (SLO)?</strong></p>
              <p class="answer">SAML Single Logout (SLO) is implemented by sending logout requests to all service providers after the user logs out of the identity provider. The logout request is propagated through the SPs to ensure that the user is logged out from all applications.</p>
            </div>
            <div class="question">
              <p><strong>119. What are the risks associated with storing JWT tokens in localStorage?</strong></p>
              <p class="answer">Storing JWT tokens in localStorage makes them vulnerable to Cross-Site Scripting (XSS) attacks, where malicious scripts can access the stored token. If the token is stolen, an attacker can impersonate the user and access their resources.</p>
            </div>
            <p>&nbsp;</p>
            <p>&nbsp;</p>
            <p>&nbsp;</p>
            <p>&nbsp;</p>
            <p>&nbsp;</p>
            <p>&nbsp;</p>
            <p>&nbsp;</p>
            <p>&nbsp;</p>
            <p>&nbsp;</p>
            <p>&nbsp;</p>
            <p>&nbsp;</p>
            <p>&nbsp;</p>
            <p>&nbsp;</p>
      </div>

    </div>

</body>
</html>
