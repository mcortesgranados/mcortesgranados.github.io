<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Set 1: Factory, Singleton, Builder, Prototype, Decorator, Proxy</title>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        .question {
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <h1>Set 1: Factory, Singleton, Builder, Prototype, Decorator, Proxy</h1>

    <div class="question">
        <h2>1. What is the Factory design pattern?</h2>
        <p>The Factory design pattern provides a method for creating objects without specifying the exact class of object that will be created. Instead, the factory method delegates the creation to subclasses.</p>
        <pre>
class Car {
    void drive() {
        System.out.println("Driving car...");
    }
}

class CarFactory {
    public Car createCar() {
        return new Car();
    }
}

public class Main {
    public static void main(String[] args) {
        CarFactory factory = new CarFactory();
        Car car = factory.createCar();
        car.drive();
    }
}
        </pre>
    </div>

    <div class="question">
        <h2>2. What is the Singleton design pattern?</h2>
        <p>The Singleton pattern ensures that a class has only one instance, and provides a global point of access to it. It is often used to manage shared resources such as a configuration object.</p>
        <pre>
class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}

public class Main {
    public static void main(String[] args) {
        Singleton singleton = Singleton.getInstance();
        System.out.println(singleton);
    }
}
        </pre>
    </div>

    <div class="question">
        <h2>3. What is the Builder design pattern?</h2>
        <p>The Builder pattern allows for the construction of complex objects step by step. The pattern is useful for creating objects that need to be configured with many possible options.</p>
        <pre>
class Car {
    private String engine;
    private String wheels;
    private String color;

    public static class Builder {
        private String engine;
        private String wheels;
        private String color;

        public Builder engine(String engine) {
            this.engine = engine;
            return this;
        }

        public Builder wheels(String wheels) {
            this.wheels = wheels;
            return this;
        }

        public Builder color(String color) {
            this.color = color;
            return this;
        }

        public Car build() {
            Car car = new Car();
            car.engine = this.engine;
            car.wheels = this.wheels;
            car.color = this.color;
            return car;
        }
    }

    @Override
    public String toString() {
        return "Car [engine=" + engine + ", wheels=" + wheels + ", color=" + color + "]";
    }
}

public class Main {
    public static void main(String[] args) {
        Car car = new Car.Builder().engine("V8").wheels("Alloy").color("Red").build();
        System.out.println(car);
    }
}
        </pre>
    </div>

    <div class="question">
        <h2>4. What is the Prototype design pattern?</h2>
        <p>The Prototype pattern creates new objects by copying an existing object, known as the prototype. This is useful when the creation of an object is costly or complex.</p>
        <pre>
interface Prototype {
    Prototype clone();
}

class Car implements Prototype {
    private String engine;

    public Car(String engine) {
        this.engine = engine;
    }

    @Override
    public Prototype clone() {
        return new Car(this.engine);
    }

    @Override
    public String toString() {
        return "Car with engine: " + engine;
    }
}

public class Main {
    public static void main(String[] args) {
        Car car1 = new Car("V8");
        Car car2 = (Car) car1.clone();
        System.out.println(car1);
        System.out.println(car2);
    }
}
        </pre>
    </div>

    <div class="question">
        <h2>5. What is the Decorator design pattern?</h2>
        <p>The Decorator pattern allows additional behavior to be added to an object dynamically, without affecting other objects of the same class.</p>
        <pre>
interface Car {
    void drive();
}

class BasicCar implements Car {
    @Override
    public void drive() {
        System.out.println("Driving basic car...");
    }
}

class CarDecorator implements Car {
    protected Car decoratedCar;

    public CarDecorator(Car decoratedCar) {
        this.decoratedCar = decoratedCar;
    }

    @Override
    public void drive() {
        decoratedCar.drive();
    }
}

class SportsCar extends CarDecorator {
    public SportsCar(Car decoratedCar) {
        super(decoratedCar);
    }

    @Override
    public void drive() {
        decoratedCar.drive();
        addSportsFeature();
    }

    private void addSportsFeature() {
        System.out.println("Adding sports features...");
    }
}

public class Main {
    public static void main(String[] args) {
        Car sportsCar = new SportsCar(new BasicCar());
        sportsCar.drive();
    }
}
        </pre>
    </div>

    <div class="question">
        <h2>6. What is the Proxy design pattern?</h2>
        <p>The Proxy pattern provides a surrogate or placeholder for another object. It controls access to the original object and can perform additional actions before or after the request.</p>
        <pre>
interface Image {
    void display();
}

class RealImage implements Image {
    private String filename;

    public RealImage(String filename) {
        this.filename = filename;
        loadImage();
    }

    private void loadImage() {
        System.out.println("Loading image: " + filename);
    }

    @Override
    public void display() {
        System.out.println("Displaying image: " + filename);
    }
}

class ProxyImage implements Image {
    private RealImage realImage;
    private String filename;

    public ProxyImage(String filename) {
        this.filename = filename;
    }

    @Override
    public void display() {
        if (realImage == null) {
            realImage = new RealImage(filename);
        }
        realImage.display();
    }
}

public class Main {
    public static void main(String[] args) {
        Image image = new ProxyImage("image.jpg");
        image.display();
    }
}
        </pre>
    </div>

    <div class="question">
        <h2>7. What are the benefits of the Factory pattern?</h2>
        <p>The Factory pattern helps to decouple the creation of objects from the client code, provides flexibility, and enables easy addition of new product types.</p>
    </div>

    <div class="question">
        <h2>8. How does the Singleton pattern ensure that only one instance is created?</h2>
        <p>The Singleton pattern restricts instantiation of a class to a single object and provides a global access point. The instance is created lazily, ensuring that only one instance is used.</p>
    </div>

    <div class="question">
        <h2>9. What is the advantage of the Builder pattern?</h2>
        <p>The Builder pattern separates the construction of a complex object from its representation. It allows for the creation of objects with different configurations and avoids constructor telescoping.</p>
    </div>

    <div class="question">
        <h2>10. How does the Prototype pattern differ from the Factory pattern?</h2>
        <p>The Prototype pattern creates new objects by cloning an existing instance, while the Factory pattern creates new objects by calling a factory method.</p>
    </div>
    <h1>Set 2: Factory, Singleton, Builder, Prototype, Decorator, Proxy</h1>
    <div class="question">
      <h2>11. Can the Singleton pattern be thread-safe?</h2>
      <p>Yes, the Singleton pattern can be thread-safe by using synchronized blocks or using double-checked locking or the Bill Pugh Singleton Design (using the static inner class).</p>
      <pre>
class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
        </pre>
    </div>
    <div class="question">
      <h2>12. What is a real-world example of the Builder pattern?</h2>
      <p>A real-world example of the Builder pattern is the construction of a meal in a fast-food restaurant. The builder allows customization of various aspects of the meal (e.g., size, drink, sides) step by step.</p>
    </div>
    <div class="question">
      <h2>13. How can you modify the Proxy pattern to include caching?</h2>
      <p>By storing the result of the method in the proxy object, subsequent calls can use the cached result instead of reloading it from the original object.</p>
      <pre>
class CachedProxy implements Image {
    private RealImage realImage;
    private String filename;
    private String cachedResult;

    public CachedProxy(String filename) {
        this.filename = filename;
    }

    @Override
    public void display() {
        if (cachedResult == null) {
            if (realImage == null) {
                realImage = new RealImage(filename);
            }
            cachedResult = "Image Data: " + filename;
        }
        System.out.println(cachedResult);
    }
}
        </pre>
    </div>
    <div class="question">
      <h2>14. Can the Decorator pattern be used to add functionalities to a class at runtime?</h2>
      <p>Yes, the Decorator pattern allows you to dynamically add functionalities to an object at runtime without modifying the original object or class.</p>
    </div>
    <div class="question">
      <h2>15. What is the difference between a concrete class and a prototype in the Prototype pattern?</h2>
      <p>The prototype is an abstract definition of an object, and it provides a method to clone itself. A concrete class is an actual implementation of an object.</p>
    </div>
    <div class="question">
      <h2>16. Can the Factory pattern be used to create multiple types of objects?</h2>
      <p>Yes, the Factory pattern can be extended to create multiple types of objects based on parameters passed to the factory method.</p>
      <pre>
class ShapeFactory {
    public Shape createShape(String type) {
        if (type.equals("circle")) {
            return new Circle();
        } else if (type.equals("rectangle")) {
            return new Rectangle();
        }
        return null;
    }
}
        </pre>
    </div>
    <div class="question">
      <h2>17. How can the Singleton pattern be used with Enum in Java?</h2>
      <p>Using an enum to implement a Singleton ensures that only one instance is created, and it handles serialization automatically.</p>
      <pre>
enum Singleton {
    INSTANCE;

    public void showMessage() {
        System.out.println("Hello from Singleton!");
    }
}

public class Main {
    public static void main(String[] args) {
        Singleton.INSTANCE.showMessage();
    }
}
        </pre>
    </div>
    <div class="question">
      <h2>18. What are the advantages of using the Builder pattern in Java?</h2>
      <p>The Builder pattern allows for more readable and maintainable code when creating complex objects, eliminates telescoping constructor pattern, and allows for object immutability.</p>
    </div>
    <div class="question">
      <h2>19. What are the common use cases for the Prototype pattern?</h2>
      <p>The Prototype pattern is commonly used when creating new instances is costly, such as in graphics or large database management systems where cloning existing objects is cheaper.</p>
    </div>
    <div class="question">
      <h2>20. How can the Proxy pattern be used for logging requests?</h2>
      <p>In the Proxy pattern, you can intercept requests and log them before forwarding the request to the real object.</p>
      <pre>
class LoggingProxy implements Image {
    private RealImage realImage;
    private String filename;

    public LoggingProxy(String filename) {
        this.filename = filename;
    }

    @Override
    public void display() {
        System.out.println("Logging request for image: " + filename);
        if (realImage == null) {
            realImage = new RealImage(filename);
        }
        realImage.display();
    }
}
        </pre>
    </div>
<p>&nbsp;</p>
    <h1>Set 3: Factory, Singleton, Builder, Prototype, Decorator, Proxy</h1>
    <div class="question">
      <h2>21. How does the Factory Method differ from the Abstract Factory pattern?</h2>
      <p>The Factory Method defines a method for creating objects in a superclass, but it allows subclasses to alter the type of objects that will be created. The Abstract Factory provides an interface for creating families of related or dependent objects without specifying their concrete classes.</p>
    </div>
    <div class="question">
      <h2>22. How does the Prototype pattern work with deep cloning?</h2>
      <p>Deep cloning in the Prototype pattern ensures that not only the object but also the objects referenced by it are cloned, so changes to the clone do not affect the original object.</p>
      <pre>
class Address implements Cloneable {
    private String street;
    
    public Address(String street) {
        this.street = street;
    }

    @Override
    public Address clone() throws CloneNotSupportedException {
        return new Address(this.street);
    }
}

class Person implements Cloneable {
    private String name;
    private Address address;
    
    public Person(String name, Address address) {
        this.name = name;
        this.address = address;
    }

    @Override
    public Person clone() throws CloneNotSupportedException {
        Person clonedPerson = (Person) super.clone();
        clonedPerson.address = address.clone(); // Deep clone the Address object
        return clonedPerson;
    }
}
        </pre>
    </div>
    <div class="question">
      <h2>23. Can the Decorator pattern be used to add state to objects?</h2>
      <p>Yes, the Decorator pattern can be used to add state to objects dynamically. The decorator class can store additional state or modify existing state of the object it decorates.</p>
    </div>
    <div class="question">
      <h2>24. What is the purpose of the Proxy pattern in relation to performance?</h2>
      <p>The Proxy pattern can be used to improve performance by controlling access to an object. For example, the proxy can be used to load a resource only when it is needed, or it can cache the result of expensive operations.</p>
    </div>
    <div class="question">
      <h2>25. How can the Singleton pattern be implemented using a static inner class?</h2>
      <p>The Singleton pattern can be implemented using a static inner class (Bill Pugh Singleton) which ensures lazy initialization and thread-safety without synchronization.</p>
      <pre>
class Singleton {
    private Singleton() {}

    private static class SingletonHelper {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return SingletonHelper.INSTANCE;
    }
}
        </pre>
    </div>
    <div class="question">
      <h2>26. Can the Builder pattern be used to create an immutable object?</h2>
      <p>Yes, the Builder pattern can be used to create immutable objects by ensuring that all fields are initialized via the builder and that no setters are provided in the final object.</p>
      <pre>
class Person {
    private final String name;
    private final int age;

    private Person(PersonBuilder builder) {
        this.name = builder.name;
        this.age = builder.age;
    }

    public static class PersonBuilder {
        private String name;
        private int age;

        public PersonBuilder setName(String name) {
            this.name = name;
            return this;
        }

        public PersonBuilder setAge(int age) {
            this.age = age;
            return this;
        }

        public Person build() {
            return new Person(this);
        }
    }
}
        </pre>
    </div>
    <div class="question">
      <h2>27. What are the advantages of using the Factory pattern?</h2>
      <p>The Factory pattern helps in abstracting the creation process of objects, making code more maintainable and scalable. It promotes loose coupling by decoupling the client code from specific classes.</p>
    </div>
    <div class="question">
      <h2>28. Can a class have both a Builder and a Factory pattern?</h2>
      <p>Yes, a class can implement both patterns. The Builder can be used to create complex objects, while the Factory can provide different ways to instantiate the objects based on various parameters.</p>
    </div>
    <div class="question">
      <h2>29. How does the Proxy pattern help with access control?</h2>
      <p>The Proxy pattern can help with access control by acting as a gatekeeper between the client and the real object. It can check permissions, manage access levels, or apply security policies before delegating the request to the real object.</p>
    </div>
    <div class="question">
      <h2>30. How do you ensure thread safety with the Singleton pattern?</h2>
      <p>Thread safety in the Singleton pattern can be achieved by using synchronized blocks or by using the static inner class implementation (Bill Pugh Singleton) which inherently handles thread safety without additional synchronization.</p>
    </div>
    <p>&nbsp;</p>
    <h1>Set 4: Factory, Singleton, Builder, Prototype, Decorator, Proxy</h1>
    <div class="question">
      <h2>31. What is the advantage of using the Prototype pattern over the Factory pattern?</h2>
      <p>The Prototype pattern allows cloning of existing objects rather than creating new ones from scratch, which can be more efficient when creating similar objects that differ in only a few attributes.</p>
    </div>
    <div class="question">
      <h2>32. How does the Singleton pattern affect performance?</h2>
      <p>In general, the Singleton pattern does not significantly affect performance. However, if synchronization is heavily used in a multi-threaded environment, it may introduce some overhead.</p>
    </div>
    <div class="question">
      <h2>33. Can the Decorator pattern be used for logging purposes?</h2>
      <p>Yes, the Decorator pattern can be used to add logging functionality to existing objects without modifying the core behavior of those objects. It is commonly used in scenarios where behavior needs to be extended dynamically.</p>
      <pre>
class LoggingDecorator implements Service {
    private final Service service;

    public LoggingDecorator(Service service) {
        this.service = service;
    }

    @Override
    public void execute() {
        System.out.println("Logging execution...");
        service.execute();
    }
}
        </pre>
    </div>
    <div class="question">
      <h2>34. How do you handle the "null object" scenario in the Factory pattern?</h2>
      <p>To handle a "null object," you can return a default object from the factory method when a valid object cannot be created. This prevents null checks in the client code.</p>
      <pre>
class ShapeFactory {
    public Shape createShape(String type) {
        if (type == null) return new NullShape(); // Return a default object
        if (type.equals("circle")) return new Circle();
        return new Rectangle();
    }
}
        </pre>
    </div>
    <div class="question">
      <h2>35. Can the Builder pattern be used to create different representations of the same object?</h2>
      <p>Yes, the Builder pattern is used to create different representations of the same object by changing the configuration or state through various builder methods.</p>
    </div>
    <div class="question">
      <h2>36. How would you implement the Singleton pattern with double-checked locking?</h2>
      <p>Double-checked locking ensures that the instance is only created once while also minimizing synchronization overhead by only locking the method when the instance is null.</p>
      <pre>
class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
        </pre>
    </div>
    <div class="question">
      <h2>37. Can the Prototype pattern be used for object caching?</h2>
      <p>Yes, the Prototype pattern can be used to cache objects by cloning them when needed, thus avoiding the overhead of creating new objects from scratch.</p>
    </div>
    <div class="question">
      <h2>38. What are the limitations of the Proxy pattern?</h2>
      <p>One limitation of the Proxy pattern is that it introduces an additional layer between the client and the real object, which can increase complexity. Also, the proxy can become a bottleneck if not implemented efficiently.</p>
    </div>
    <div class="question">
      <h2>39. Can you combine the Singleton pattern with the Factory pattern?</h2>
      <p>Yes, the Singleton and Factory patterns can be combined by using the Singleton pattern to manage the creation of the factory instance, ensuring that only one factory instance is used to create objects.</p>
      <pre>
class SingletonFactory {
    private static SingletonFactory instance;

    private SingletonFactory() {}

    public static SingletonFactory getInstance() {
        if (instance == null) {
            instance = new SingletonFactory();
        }
        return instance;
    }

    public Product createProduct() {
        return new Product();
    }
}
        </pre>
    </div>
    <div class="question">
      <h2>40. How can the Builder pattern help with handling complex constructors?</h2>
      <p>The Builder pattern separates the construction logic from the object itself, making the construction process more readable and maintainable. It avoids the need for multiple constructors with different parameters.</p>
    </div>
    <h1>Set 5: Factory, Singleton, Builder, Prototype, Decorator, Proxy</h1>
    <div class="question">
      <h2>41. Can the Builder pattern be used to construct objects with variable states?</h2>
      <p>Yes, the Builder pattern is designed to construct objects step by step, allowing different states to be set as needed during the construction process.</p>
    </div>
    <div class="question">
      <h2>42. How does the Proxy pattern support lazy initialization?</h2>
      <p>The Proxy pattern can implement lazy initialization by delaying the instantiation of the real object until it is actually needed by the client.</p>
    </div>
    <div class="question">
      <h2>43. How do you prevent multiple instances in the Singleton pattern?</h2>
      <p>You prevent multiple instances by using a private constructor and ensuring that the instance is only created once, typically through static initialization or double-checked locking in a multi-threaded environment.</p>
    </div>
    <div class="question">
      <h2>44. Can the Factory pattern handle complex object creation logic?</h2>
      <p>Yes, the Factory pattern is designed to handle complex object creation logic by abstracting the creation process into separate classes, allowing for customization without affecting the client code.</p>
    </div>
    <div class="question">
      <h2>45. How can you use the Prototype pattern with a cache of cloned objects?</h2>
      <p>The Prototype pattern can be used with a cache by storing clones of objects, and when a new object is needed, you can return a clone from the cache rather than creating a new object from scratch.</p>
      <pre>
class PrototypeCache {
    private Map cache = new HashMap<>();

    public Prototype getPrototype(String key) {
        return cache.get(key).clone();
    }

    public void addPrototype(String key, Prototype prototype) {
        cache.put(key, prototype);
    }
}
        </pre>
    </div>
    <div class="question">
      <h2>46. Can the Singleton pattern be used to manage shared resources?</h2>
      <p>Yes, the Singleton pattern is often used to manage shared resources, ensuring that only one instance of the resource manager exists throughout the application.</p>
    </div>
    <div class="question">
      <h2>47. How does the Decorator pattern provide flexibility for object behavior?</h2>
      <p>The Decorator pattern provides flexibility by allowing dynamic addition of behaviors or responsibilities to an object without modifying its original structure. Multiple decorators can be combined to create various behaviors.</p>
    </div>
    <div class="question">
      <h2>48. What are the drawbacks of using the Singleton pattern?</h2>
      <p>Drawbacks of the Singleton pattern include tight coupling, making testing more difficult, and the potential for creating a global state that could lead to unintended side effects in a multi-threaded environment.</p>
    </div>
    <div class="question">
      <h2>49. How can the Proxy pattern help with network performance?</h2>
      <p>The Proxy pattern can improve network performance by caching data or by acting as an intermediary that reduces the load on the real object, such as in the case of a Remote Proxy that minimizes network traffic.</p>
    </div>
    <div class="question">
      <h2>50. Can the Builder pattern be used for complex object validation?</h2>
      <p>Yes, the Builder pattern can be extended to perform validation during the construction process, ensuring that the final object meets certain criteria before it is created.</p>
      <pre>
class PersonBuilder {
    private String name;
    private int age;

    public PersonBuilder setName(String name) {
        this.name = name;
        return this;
    }

    public PersonBuilder setAge(int age) {
        if (age < 0) throw new IllegalArgumentException("Age cannot be negative");
        this.age = age;
        return this;
    }

    public Person build() {
        return new Person(name, age);
    }
}
        </pre>
    </div>
    <p>&nbsp;</p>
    <h1>Set 6: Factory, Singleton, Builder, Prototype, Decorator, Proxy</h1>
    <div class="question">
      <h2>51. How can the Singleton pattern be used to create a global configuration object?</h2>
      <p>The Singleton pattern is commonly used to create a global configuration object, ensuring that all parts of the application access the same configuration instance.</p>
      <pre>
class Config {
    private static Config instance;
    private Map settings = new HashMap<>();

    private Config() {}

    public static Config getInstance() {
        if (instance == null) {
            instance = new Config();
        }
        return instance;
    }

    public String getSetting(String key) {
        return settings.get(key);
    }
}
        </pre>
    </div>
    <div class="question">
      <h2>52. How do you ensure thread-safety in the Factory pattern?</h2>
      <p>Thread-safety in the Factory pattern can be ensured by using synchronization techniques such as synchronized blocks or thread-safe collections when creating shared resources.</p>
    </div>
    <div class="question">
      <h2>53. Can the Decorator pattern be used to add logging functionality dynamically?</h2>
      <p>Yes, the Decorator pattern is a perfect fit for adding logging functionality dynamically to existing classes without modifying the original class behavior.</p>
      <pre>
class LoggingDecorator implements Service {
    private final Service service;

    public LoggingDecorator(Service service) {
        this.service = service;
    }

    @Override
    public void execute() {
        System.out.println("Logging execution...");
        service.execute();
    }
}
        </pre>
    </div>
    <div class="question">
      <h2>54. How do you implement lazy loading with the Proxy pattern?</h2>
      <p>Lazy loading can be implemented in the Proxy pattern by delaying the creation of an object until it is accessed for the first time, thereby improving performance by avoiding unnecessary initialization.</p>
    </div>
    <div class="question">
      <h2>55. What are the best use cases for the Builder pattern?</h2>
      <p>The Builder pattern is best used when objects need to be created with many optional components or when an object has a complex construction process involving multiple steps.</p>
    </div>
    <div class="question">
      <h2>56. How can the Prototype pattern help with performance optimization?</h2>
      <p>The Prototype pattern helps optimize performance by cloning existing objects rather than creating new instances from scratch, which can be especially useful when creating objects is costly.</p>
    </div>
    <div class="question">
      <h2>57. Can you combine the Proxy and Decorator patterns?</h2>
      <p>Yes, the Proxy and Decorator patterns can be combined, where the Proxy provides additional behavior such as lazy initialization or access control, while the Decorator can add further behavior like logging or validation.</p>
    </div>
    <div class="question">
      <h2>58. What is the difference between a real object and a proxy in the Proxy pattern?</h2>
      <p>The real object is the actual implementation, while the proxy acts as a placeholder that controls access to the real object. The proxy can add additional functionality like access control or lazy initialization.</p>
    </div>
    <div class="question">
      <h2>59. How do you ensure immutability in the Builder pattern?</h2>
      <p>Immutability in the Builder pattern can be ensured by making the fields of the object final and providing no setters after the object is built, preventing any changes to the object after construction.</p>
      <pre>
class ImmutablePerson {
    private final String name;
    private final int age;

    private ImmutablePerson(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public static class Builder {
        private String name;
        private int age;

        public Builder setName(String name) {
            this.name = name;
            return this;
        }

        public Builder setAge(int age) {
            this.age = age;
            return this;
        }

        public ImmutablePerson build() {
            return new ImmutablePerson(name, age);
        }
    }
}
        </pre>
    </div>
    <div class="question">
      <h2>60. Can the Singleton pattern be applied to database connections?</h2>
      <p>Yes, the Singleton pattern is commonly used to ensure that only one instance of a database connection is created and shared throughout the application, which helps with resource management and efficiency.</p>
    </div>
    <p>&nbsp;</p>
    <h1>Set 7: Factory, Singleton, Builder, Prototype, Decorator, Proxy</h1>
    <div class="question">
      <h2>61. How can the Factory pattern be adapted for creating different types of products?</h2>
      <p>The Factory pattern can be adapted by defining an interface or abstract class for products, and then creating concrete product classes that implement or extend this interface. The Factory will then return the appropriate product based on input parameters.</p>
      <pre>
interface Product {
    void doSomething();
}

class ConcreteProductA implements Product {
    public void doSomething() {
        System.out.println("Product A action");
    }
}

class ConcreteProductB implements Product {
    public void doSomething() {
        System.out.println("Product B action");
    }
}

class ProductFactory {
    public static Product createProduct(String type) {
        switch(type) {
            case "A": return new ConcreteProductA();
            case "B": return new ConcreteProductB();
            default: throw new IllegalArgumentException("Unknown product type");
        }
    }
}
        </pre>
    </div>
    <div class="question">
      <h2>62. Can the Singleton pattern be used to manage a thread pool?</h2>
      <p>Yes, the Singleton pattern is commonly used to manage a thread pool to ensure that there is only one instance managing threads in the system, preventing excessive thread creation and promoting resource reuse.</p>
    </div>
    <div class="question">
      <h2>63. How does the Builder pattern separate object construction from its representation?</h2>
      <p>The Builder pattern separates object construction from its representation by using a builder object that constructs the product step by step, while the client code interacts with the builder without needing to know how the product is constructed.</p>
    </div>
    <div class="question">
      <h2>64. Can the Prototype pattern be used for shallow copies of objects?</h2>
      <p>Yes, the Prototype pattern can be used to create shallow copies of objects. However, deep copies, where all objects within the prototype are cloned, may be needed if the object graph contains references to other objects.</p>
    </div>
    <div class="question">
      <h2>65. How does the Decorator pattern differ from inheritance?</h2>
      <p>The Decorator pattern allows behavior to be added to an object dynamically at runtime, while inheritance requires defining the behavior in a base class at compile-time. Decorators offer more flexibility without modifying the class hierarchy.</p>
    </div>
    <div class="question">
      <h2>66. Can the Proxy pattern be used to control access to an object?</h2>
      <p>Yes, the Proxy pattern is often used to control access to an object, such as for lazy initialization, access control, logging, or monitoring.</p>
    </div>
    <div class="question">
      <h2>67. What is the main advantage of using the Singleton pattern in a logging system?</h2>
      <p>The main advantage of using the Singleton pattern in a logging system is that it ensures there is only one instance of the logger throughout the application, which prevents issues with inconsistent logging output and resource wastage.</p>
    </div>
    <div class="question">
      <h2>68. How can you implement a thread-safe Singleton in Java?</h2>
      <p>You can implement a thread-safe Singleton using the double-checked locking method with `synchronized` and `volatile`, ensuring that the instance is created only once, even in a multi-threaded environment.</p>
      <pre>
class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
        </pre>
    </div>
    <div class="question">
      <h2>69. Can the Builder pattern be used for constructing objects with optional fields?</h2>
      <p>Yes, the Builder pattern is ideal for constructing objects with optional fields, as it allows you to specify only the required fields while leaving optional fields blank or with default values.</p>
    </div>
    <div class="question">
      <h2>70. How can the Prototype pattern help with object pool management?</h2>
      <p>The Prototype pattern can be used for object pool management by cloning objects from a prototype instead of creating new instances. This reduces the overhead of creating objects when they are frequently used or requested.</p>
    </div>
    <p>&nbsp;</p>
    <h1>Set 8: Factory, Singleton, Builder, Prototype, Decorator, Proxy</h1>
    <div class="question">
      <h2>71. How do you handle creating objects with multiple dependencies in the Factory pattern?</h2>
      <p>In the Factory pattern, you can manage objects with multiple dependencies by passing those dependencies to the factory method or using dependency injection frameworks to inject them into the object being created.</p>
    </div>
    <div class="question">
      <h2>72. Can the Singleton pattern be extended to hold a collection of objects?</h2>
      <p>Yes, the Singleton pattern can be extended to hold a collection of objects, typically by using a map or list to store multiple instances of objects, while still ensuring that the collection itself is only created once.</p>
    </div>
    <div class="question">
      <h2>73. How can you implement the Builder pattern when objects have required and optional parameters?</h2>
      <p>The Builder pattern can be implemented by providing methods for both required and optional parameters. The builder will allow the client to specify only the required parameters and optionally set other parameters before constructing the object.</p>
    </div>
    <div class="question">
      <h2>74. Can the Prototype pattern be used to clone an object with deep references?</h2>
      <p>Yes, the Prototype pattern can be used for deep cloning, where all referenced objects are also cloned. This ensures that the cloned object is fully independent of the original object.</p>
    </div>
    <div class="question">
      <h2>75. How can the Decorator pattern help with adding functionality to a class dynamically?</h2>
      <p>The Decorator pattern adds functionality to an existing class dynamically by wrapping the object and modifying its behavior, without modifying the original class code or using inheritance.</p>
    </div>
    <div class="question">
      <h2>76. How does the Proxy pattern differ from the Decorator pattern?</h2>
      <p>The Proxy pattern controls access to the original object, often for lazy initialization, access control, or monitoring, while the Decorator pattern enhances or alters the functionality of the object without changing its interface.</p>
    </div>
    <div class="question">
      <h2>77. Can the Factory pattern be used for complex object creation that involves multiple steps?</h2>
      <p>Yes, the Factory pattern can be used for complex object creation that involves multiple steps by breaking down the creation process into smaller parts and encapsulating each step within the factory.</p>
    </div>
    <div class="question">
      <h2>78. How can you ensure that only one instance of a database connection is created using the Singleton pattern?</h2>
      <p>You can ensure only one instance of a database connection is created by using the Singleton pattern, where the database connection is initialized only once and shared across the application using a static `getInstance()` method.</p>
    </div>
    <div class="question">
      <h2>79. How can the Prototype pattern be used to clone an object with complex state?</h2>
      <p>The Prototype pattern can clone an object with complex state by implementing a deep clone method that replicates the entire object graph, ensuring that all states and references are correctly cloned.</p>
    </div>
    <div class="question">
      <h2>80. How do you handle adding responsibilities to objects without modifying their code using the Decorator pattern?</h2>
      <p>The Decorator pattern allows adding responsibilities to objects without modifying their code by wrapping the existing object with a decorator that implements the same interface and extends its behavior dynamically at runtime.</p>
    </div>
    <p>&nbsp;</p>
    <h1>Set 9: Factory, Singleton, Builder, Prototype, Decorator, Proxy</h1>
    <div class="question">
      <h2>81. How do you implement the Factory pattern to create objects based on configuration?</h2>
      <p>The Factory pattern can be implemented by reading configuration values (e.g., from a file or environment variables) and using those values to determine which type of object to create and return.</p>
      <pre>
class ConfigurableProductFactory {
    public static Product createProductFromConfig(String config) {
        if (config.equals("A")) {
            return new ConcreteProductA();
        } else if (config.equals("B")) {
            return new ConcreteProductB();
        } else {
            throw new IllegalArgumentException("Unknown config");
        }
    }
}
        </pre>
    </div>
    <div class="question">
      <h2>82. How does the Singleton pattern ensure thread safety when accessing a resource?</h2>
      <p>The Singleton pattern ensures thread safety by using synchronization, particularly with the double-checked locking method, which prevents multiple threads from creating different instances of the singleton.</p>
    </div>
    <div class="question">
      <h2>83. Can you use the Builder pattern for constructing immutable objects?</h2>
      <p>Yes, the Builder pattern is ideal for constructing immutable objects by using a builder to set the final state of the object, and then providing a final step that creates the immutable object.</p>
    </div>
    <div class="question">
      <h2>84. How do you use the Prototype pattern to create new instances of objects with the same initial state?</h2>
      <p>You can use the Prototype pattern by implementing a `clone()` method that creates a copy of the object with the same state. This allows you to create new instances without needing to reinitialize or recreate the state.</p>
    </div>
    <div class="question">
      <h2>85. Can the Decorator pattern be used to extend functionality at runtime?</h2>
      <p>Yes, the Decorator pattern is designed to extend the functionality of an object at runtime by dynamically adding new behavior while maintaining the object's original interface.</p>
    </div>
    <div class="question">
      <h2>86. How do you use the Proxy pattern for access control?</h2>
      <p>The Proxy pattern can be used for access control by wrapping the real object and adding logic to control access, such as checking user permissions or roles before allowing the action to proceed.</p>
    </div>
    <div class="question">
      <h2>87. How does the Factory pattern help with the decoupling of object creation?</h2>
      <p>The Factory pattern decouples object creation by centralizing the instantiation of objects in a factory class, preventing the client code from directly creating instances and coupling it to specific classes.</p>
    </div>
    <div class="question">
      <h2>88. How can you ensure a Singleton is used only once per application lifecycle?</h2>
      <p>You can ensure a Singleton is used only once per application lifecycle by lazily initializing the instance, ensuring that only one instance is created and used throughout the application's execution.</p>
    </div>
    <div class="question">
      <h2>89. Can the Builder pattern be used to create complex objects with dependencies on each other?</h2>
      <p>Yes, the Builder pattern can handle complex objects with interdependent parts by building each component step by step, allowing dependencies to be set before the object is completed.</p>
    </div>
    <div class="question">
      <h2>90. How can the Prototype pattern be used for managing complex objects with dynamic state changes?</h2>
      <p>The Prototype pattern can be used for managing complex objects with dynamic state changes by creating deep clones of the object each time a new instance is needed, ensuring that the state changes are independent of the original object.</p>
    </div>
    <p>&nbsp;</p>
    <h1>Set 10: Factory, Singleton, Builder, Prototype, Decorator, Proxy</h1>
    <div class="question">
      <h2>91. How do you ensure a Singleton object is created only once in a multi-threaded environment?</h2>
      <p>In a multi-threaded environment, you can use the double-checked locking method with synchronization to ensure that the Singleton instance is created only once, even when multiple threads access the instance simultaneously.</p>
    </div>
    <div class="question">
      <h2>92. How can you implement a Factory pattern when dealing with a family of related objects?</h2>
      <p>The Factory pattern can be extended to handle families of related objects by creating an abstract factory class that defines methods for creating different types of objects, allowing subclasses to implement these methods for specific product families.</p>
    </div>
    <div class="question">
      <h2>93. Can the Builder pattern be used to construct a product in multiple steps?</h2>
      <p>Yes, the Builder pattern is specifically designed to construct a product step by step, allowing you to define different parts of the object and construct it incrementally.</p>
    </div>
    <div class="question">
      <h2>94. How does the Prototype pattern help in cloning objects with complex hierarchies?</h2>
      <p>The Prototype pattern helps by providing a `clone()` method that can create deep copies of objects, ensuring that even objects with complex hierarchies are cloned properly without sharing references with the original.</p>
    </div>
    <div class="question">
      <h2>95. Can the Decorator pattern be used to add new responsibilities to an object without changing its interface?</h2>
      <p>Yes, the Decorator pattern allows new responsibilities to be added to an object at runtime without modifying the object's interface, enabling dynamic behavior extension.</p>
    </div>
    <div class="question">
      <h2>96. How can you implement the Proxy pattern to delay the creation of an object?</h2>
      <p>The Proxy pattern can be used to delay the creation of an object by using a proxy class that holds a reference to the real object and only initializes it when necessary, typically on the first method call.</p>
    </div>
    <div class="question">
      <h2>97. How do you manage the state of objects when using the Prototype pattern?</h2>
      <p>When using the Prototype pattern, the state of the object is typically managed through deep cloning, ensuring that all internal states are copied independently, so modifications to the clone do not affect the original object.</p>
    </div>
    <div class="question">
      <h2>98. Can the Singleton pattern be used for controlling access to shared resources in a multi-threaded environment?</h2>
      <p>Yes, the Singleton pattern is ideal for controlling access to shared resources in a multi-threaded environment, as it ensures that only one instance is responsible for managing the resource, preventing concurrent access issues.</p>
    </div>
    <div class="question">
      <h2>99. How does the Builder pattern improve code readability when creating complex objects?</h2>
      <p>The Builder pattern improves code readability by clearly defining a step-by-step process for constructing complex objects, making the creation process explicit and more understandable to other developers.</p>
    </div>
    <div class="question">
      <h2>100. How does the Proxy pattern help in implementing lazy initialization for objects?</h2>
      <p>The Proxy pattern can implement lazy initialization by delaying the creation of an object until it is actually needed, ensuring that resources are only consumed when necessary.</p>
    </div>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
<p>&nbsp;</p>
    <p>&nbsp;</p>
</body>
</html>
