<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Untitled Document</title>
<style type="text/css">
<!--
.question {            margin-bottom: 20px;
}
.style1 {font-family: Arial, Helvetica, sans-serif}
.style2 {margin-bottom: 20px; font-family: Arial, Helvetica, sans-serif; }
-->
</style>
</head>

<body>
<h2 class="style1">Spring Data JPA - Set 1</h2>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
        }
        th {
            background-color: #f4f4f4;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
    </style>
    <h2>Comparison of Java JPA Features</h2>

    <table>
        <tr>
            <th>Feature</th>
            <th>Description</th>
            <th>Key Focus</th>
            <th>Goal</th>
            <th>Benefits</th>
            <th>Real-World Application</th>
        </tr>
        <tr>
            <td><strong>Entity Mapping</strong></td>
            <td>Mapping Java classes to database tables using annotations like `@Entity`, `@Table`, and `@Id`.</td>
            <td>Object-Relational Mapping (ORM)</td>
            <td>To establish a clear mapping between Java objects and database tables, simplifying database interaction.</td>
            <td>Improves developer productivity by automatically mapping Java objects to database tables.</td>
            <td>In an e-commerce platform, mapping an `Order` class to a `orders` table in the database simplifies creating and retrieving order records.</td>
        </tr>
        <tr>
            <td><strong>Persistence Context</strong></td>
            <td>A context where entities are managed by the JPA provider, typically using the `EntityManager`.</td>
            <td>State Management</td>
            <td>To manage entity instances and their lifecycle within a defined scope, such as a transaction.</td>
            <td>Ensures that all entities in the persistence context are synchronized with the database.</td>
            <td>In a financial application, keeping the state of bank account balances in sync during a transaction ensures consistency.</td>
        </tr>
        <tr>
            <td><strong>Lazy vs Eager Loading</strong></td>
            <td>Defines how related entities are fetched from the database, either lazily (on demand) or eagerly (immediately).</td>
            <td>Data Fetching</td>
            <td>To optimize performance and memory usage by controlling when related data is fetched.</td>
            <td>Helps in improving performance by delaying the loading of data until it is actually needed.</td>
            <td>In a blogging platform, eagerly loading author details alongside an article might be efficient, but lazily loading comments only when requested can save resources.</td>
        </tr>
        <tr>
            <td><strong>Query Language (JPQL)</strong></td>
            <td>Java Persistence Query Language (JPQL) allows you to write queries using Java object-oriented syntax.</td>
            <td>Querying</td>
            <td>To provide a platform-independent way to query database entities, resembling SQL but based on Java classes.</td>
            <td>Improves readability and maintainability by using Java object models directly in queries.</td>
            <td>In an inventory system, using JPQL to query products based on category and availability is more natural than writing raw SQL.</td>
        </tr>
        <tr>
            <td><strong>Entity Lifecycle</strong></td>
            <td>Defines the different states an entity goes through, such as new, managed, detached, and removed.</td>
            <td>Entity Management</td>
            <td>To track and manage the state of entities as they undergo various operations like saving, updating, and deleting.</td>
            <td>Allows for better control of how entities are handled during CRUD operations.</td>
            <td>In a CRM system, managing the lifecycle of customer entities ensures that customer data is properly inserted, updated, and deleted based on business rules.</td>
        </tr>
        <tr>
            <td><strong>Transaction Management</strong></td>
            <td>Provides support for managing transactions using `@Transactional` annotations or `EntityTransaction` in code.</td>
            <td>Transaction Control</td>
            <td>To ensure that operations like data insertion, update, and deletion are handled atomically and consistently.</td>
            <td>Ensures that changes to the database are rolled back if any part of the transaction fails, maintaining data integrity.</td>
            <td>In an order processing system, transactions are used to ensure that inventory updates, payment processing, and order creation either all succeed or all fail.</td>
        </tr>
        <tr>
            <td><strong>Named Queries</strong></td>
            <td>Predefined queries in the `@NamedQuery` annotation that can be reused across the application.</td>
            <td>Query Reusability</td>
            <td>To avoid repetitive code and centralize query definitions for better maintainability.</td>
            <td>Enhances performance and readability by allowing queries to be reused without rewriting them each time.</td>
            <td>In a payroll system, using named queries for recurring reports (e.g., employee salary data) allows for easier maintenance and consistency.</td>
        </tr>
        <tr>
            <td><strong>Criteria API</strong></td>
            <td>A programmatic API for creating dynamic, type-safe queries in Java.</td>
            <td>Dynamic Query Construction</td>
            <td>To allow developers to create flexible, type-safe queries without directly writing JPQL strings.</td>
            <td>Provides a more flexible, dynamic way to build queries based on runtime conditions.</td>
            <td>In an e-commerce site, using the Criteria API to create dynamic product searches based on various user inputs such as price range, category, and rating.</td>
        </tr>
        <tr>
            <td><strong>Many-to-One/One-to-Many Mapping</strong></td>
            <td>Defines the relationships between entities using annotations like `@ManyToOne`, `@OneToMany`, etc.</td>
            <td>Relationship Mapping</td>
            <td>To model and maintain relationships between entities in the database efficiently.</td>
            <td>Reduces redundancy and ensures that relationships are maintained correctly across entities.</td>
            <td>In a library system, mapping books to authors (many-to-one) and authors to multiple books (one-to-many) ensures accurate data integrity.</td>
        </tr>
        <tr>
            <td><strong>Bidirectional Relationships</strong></td>
            <td>Allow for relationships to be navigated in both directions, e.g., `@OneToMany` and `@ManyToOne` relationships.</td>
            <td>Navigation Flexibility</td>
            <td>To allow easy access to both sides of a relationship, making data retrieval more flexible.</td>
            <td>Improves data consistency and makes it easier to work with related entities in both directions.</td>
            <td>In a social media application, allowing a `User` to have many `Posts` (one-to-many) and also letting each `Post` know the `User` who created it (many-to-one) ensures easy navigation between user posts and author information.</td>
        </tr>
    </table><p class="style1">&nbsp;</p>
<h2 class="style1"><a href="Java 25 Spring Data JPA Repositories Query Methods Entity Relations 01.mp3" target="_blank">Audio 1</a> - <a href="Java 25 Spring Data JPA Repositories Query Methods Entity Relations 02.mp3" target="_blank">Audio 2</a></h2>
<div class="style2">
  <h3>1. What is Spring Data JPA?</h3>
  <p><strong>Answer:</strong> Spring Data JPA is a part of the Spring Data project that makes it easier to implement JPA-based data access layers. It provides repositories for common database operations like saving, finding, and deleting entities without writing boilerplate code.</p>
</div>
<div class="style2">
  <h3>2. What is the purpose of a <code>JpaRepository</code>?</h3>
  <p><strong>Answer:</strong> <code>JpaRepository</code> is an interface provided by Spring Data JPA that simplifies CRUD operations by extending <code>PagingAndSortingRepository</code> and <code>CrudRepository</code>. It provides methods like <code>save()</code>, <code>findAll()</code>, <code>findById()</code>, and others for accessing and modifying data in the database.</p>
  <pre>
            <code>
                public interface UserRepository extends JpaRepository { }
            </code>
        </pre>
</div>
<div class="style2">
  <h3>3. How do you define custom query methods in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> Custom query methods can be defined by adding method names following Spring Data JPA's conventions, such as <code>findBy</code>, <code>countBy</code>, etc. You can also use the <code>@Query</code> annotation for more complex queries.</p>
  <pre>
            <code>
                public List<User> findByLastName(String lastName);
            </code>
        </pre>
</div>
<div class="style2">
  <h3>4. What is the purpose of the <code>@Query</code> annotation in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> The <code>@Query</code> annotation is used to define custom queries using JPQL (Java Persistence Query Language) or SQL. It allows you to write queries that are not easily expressed through method names.</p>
  <pre>
            <code>
                @Query(&quot;SELECT u FROM User u WHERE u.age &gt; :age&quot;)
                List<User> findUsersAboveAge(@Param(&quot;age&quot;) int age);
            </code>
        </pre>
</div>
<div class="style2">
  <h3>5. How do you define a One-to-Many relationship in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> A One-to-Many relationship is defined by using the <code>@OneToMany</code> annotation on the &quot;one&quot; side of the relationship and <code>@ManyToOne</code> on the &quot;many&quot; side.</p>
  <pre>
            <code>
                @Entity
                public class Department {
                    @OneToMany(mappedBy = &quot;department&quot;)
                    private List<Employee> employees;
                }
            </code>
        </pre>
</div>
<div class="style2">
  <h3>6. What is the difference between <code>save()</code> and <code>saveAll()</code> in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> <code>save()</code> is used to save a single entity, while <code>saveAll()</code> is used to save a collection of entities.</p>
  <pre>
            <code>
                userRepository.save(user);  // saves one user
                userRepository.saveAll(users);  // saves a list of users
            </code>
        </pre>
</div>
<div class="style2">
  <h3>7. How can you fetch a lazy-loaded relationship in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> Lazy-loaded relationships can be fetched by accessing the relationship property in the service layer, or by using <code>JOIN FETCH</code> in a <code>@Query</code> annotation to eagerly load the relationship.</p>
  <pre>
            <code>
                @Query(&quot;SELECT d FROM Department d JOIN FETCH d.employees&quot;)
                List<Department> findDepartmentsWithEmployees();
            </code>
        </pre>
</div>
<div class="style2">
  <h3>8. What is the <code>@ManyToOne</code> annotation used for?</h3>
  <p><strong>Answer:</strong> The <code>@ManyToOne</code> annotation is used to define a many-to-one relationship between entities. It is placed on the &quot;many&quot; side of the relationship.</p>
  <pre>
            <code>
                @ManyToOne
                private Department department;
            </code>
        </pre>
</div>
<div class="style2">
  <h3>9. How do you define a Many-to-Many relationship in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> A Many-to-Many relationship is defined using the <code>@ManyToMany</code> annotation on both sides of the relationship, often with a joining table.</p>
  <pre>
            <code>
                @ManyToMany
                @JoinTable(name = &quot;student_course&quot;, joinColumns = @JoinColumn(name = &quot;student_id&quot;), inverseJoinColumns = @JoinColumn(name = &quot;course_id&quot;))
                private List<Course> courses;
            </code>
        </pre>
</div>
<div class="style2">
  <h3>10. What is the purpose of the <code>@Id</code> annotation in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> The <code>@Id</code> annotation is used to specify the primary key field of an entity class in JPA.</p>
  <pre>
            <code>
                @Id
                @GeneratedValue(strategy = GenerationType.IDENTITY)
                private Long id;
            </code>
        </pre>
</div>
<p class="style1">&nbsp;</p>
<h2 class="style1">Spring Data JPA - Set 2</h2>
<div class="style2">
  <h3>1. What is the <code>@GeneratedValue</code> annotation in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> The <code>@GeneratedValue</code> annotation is used to specify the strategy for generating primary key values. It can be used with strategies like <code>IDENTITY</code>, <code>SEQUENCE</code>, or <code>AUTO</code> to automatically generate a primary key.</p>
  <pre>
            <code>
                @Id
                @GeneratedValue(strategy = GenerationType.AUTO)
                private Long id;
            </code>
        </pre>
</div>
<div class="style2">
  <h3>2. What is the difference between <code>fetch = FetchType.LAZY</code> and <code>fetch = FetchType.EAGER</code>?</h3>
  <p><strong>Answer:</strong> <code>FetchType.LAZY</code> means that the related entities are fetched only when accessed, whereas <code>FetchType.EAGER</code> fetches the related entities immediately along with the parent entity.</p>
  <pre>
            <code>
                @ManyToOne(fetch = FetchType.LAZY)
                private Department department;
            </code>
        </pre>
</div>
<div class="style2">
  <h3>3. What does the <code>mappedBy</code> attribute do in a relationship annotation?</h3>
  <p><strong>Answer:</strong> The <code>mappedBy</code> attribute specifies the field in the other entity that owns the relationship. It is used in a bidirectional relationship to indicate the inverse side of the relationship.</p>
  <pre>
            <code>
                @OneToMany(mappedBy = &quot;department&quot;)
                private List<Employee> employees;
            </code>
        </pre>
</div>
<div class="style2">
  <h3>4. What is the role of the <code>@JoinColumn</code> annotation?</h3>
  <p><strong>Answer:</strong> The <code>@JoinColumn</code> annotation is used to specify the column in the table that is used to join two entities in a relationship. It is typically used in the &quot;many&quot; side of a relationship.</p>
  <pre>
            <code>
                @ManyToOne
                @JoinColumn(name = &quot;department_id&quot;)
                private Department department;
            </code>
        </pre>
</div>
<div class="style2">
  <h3>5. How can you prevent a specific field from being persisted in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> You can use the <code>@Transient</code> annotation to mark a field that should not be persisted in the database.</p>
  <pre>
            <code>
                @Transient
                private String temporaryField;
            </code>
        </pre>
</div>
<div class="style2">
  <h3>6. What is the <code>@OneToOne</code> annotation used for in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> The <code>@OneToOne</code> annotation defines a one-to-one relationship between two entities. It is used when one entity is associated with exactly one instance of another entity.</p>
  <pre>
            <code>
                @OneToOne
                private Address address;
            </code>
        </pre>
</div>
<div class="style2">
  <h3>7. What is the purpose of the <code>@EntityGraph</code> annotation?</h3>
  <p><strong>Answer:</strong> The <code>@EntityGraph</code> annotation is used to define an entity graph, allowing you to fetch certain attributes of an entity eagerly without changing the default fetching behavior.</p>
  <pre>
            <code>
                @EntityGraph(attributePaths = &quot;employees&quot;)
                List<Department> findAllWithEmployees();
            </code>
        </pre>
</div>
<div class="style2">
  <h3>8. How do you perform paging and sorting with Spring Data JPA?</h3>
  <p><strong>Answer:</strong> You can use the <code>Pageable</code> and <code>Sort</code> interfaces provided by Spring Data JPA to handle pagination and sorting in your repository methods.</p>
  <pre>
            <code>
                Page<User> findAll(Pageable pageable);
                List<User> findByLastName(String lastName, Sort sort);
            </code>
        </pre>
</div>
<div class="style2">
  <h3>9. How do you update an entity in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> You can update an entity by retrieving it from the database, making changes to its fields, and then saving it back using the <code>save()</code> method. If the entity already exists, the <code>save()</code> method performs an update.</p>
  <pre>
            <code>
                User user = userRepository.findById(1L).orElseThrow();
                user.setLastName(&quot;UpdatedLastName&quot;);
                userRepository.save(user);
            </code>
        </pre>
</div>
<div class="style2">
  <h3>10. How do you handle cascading operations in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> You can use the <code>cascade</code> attribute of the relationship annotations to specify which operations should be propagated to related entities. For example, <code>CascadeType.ALL</code> will propagate all operations (persist, merge, remove, etc.) to the related entity.</p>
  <pre>
            <code>
                @OneToMany(cascade = CascadeType.ALL)
                private List<Employee> employees;
            </code>
        </pre>
</div>
<p class="style1">&nbsp;</p>
<h2 class="style1">Spring Data JPA - Set 3</h2>
<div class="style2">
  <h3>1. What is the <code>@Query</code> annotation used for in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> The <code>@Query</code> annotation allows you to define custom JPQL (Java Persistence Query Language) queries in repository methods. This can be useful for complex queries that cannot be easily generated using method names.</p>
  <pre>
            <code>
                @Query(&quot;SELECT e FROM Employee e WHERE e.department.id = :departmentId&quot;)
                List<Employee> findByDepartmentId(@Param(&quot;departmentId&quot;) Long departmentId);
            </code>
        </pre>
</div>
<div class="style2">
  <h3>2. How do you define a custom query with named parameters in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> Named parameters can be defined using the <code>:paramName</code> syntax in the <code>@Query</code> annotation. You can then use the <code>@Param</code> annotation in the method signature to bind the parameters.</p>
  <pre>
            <code>
                @Query(&quot;SELECT e FROM Employee e WHERE e.salary &gt; :salary&quot;)
                List<Employee> findEmployeesWithSalaryGreaterThan(@Param(&quot;salary&quot;) BigDecimal salary);
            </code>
        </pre>
</div>
<div class="style2">
  <h3>3. What is the <code>@Modifying</code> annotation used for?</h3>
  <p><strong>Answer:</strong> The <code>@Modifying</code> annotation is used to indicate that a query is an update, delete, or insert operation, and not a SELECT query. This is typically used with <code>@Query</code> when modifying data in the database.</p>
  <pre>
            <code>
                @Modifying
                @Query(&quot;UPDATE Employee e SET e.salary = :salary WHERE e.id = :id&quot;)
                int updateSalary(@Param(&quot;salary&quot;) BigDecimal salary, @Param(&quot;id&quot;) Long id);
            </code>
        </pre>
</div>
<div class="style2">
  <h3>4. What is the <code>flush()</code> method used for in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> The <code>flush()</code> method is used to synchronize the persistence context with the database. It forces any pending changes in the persistence context to be written to the database.</p>
  <pre>
            <code>
                entityManager.flush();
            </code>
        </pre>
</div>
<div class="style2">
  <h3>5. How can you use Spring Data JPA to delete entities?</h3>
  <p><strong>Answer:</strong> You can delete entities using the <code>deleteById()</code>, <code>delete()</code>, or custom delete queries. The <code>deleteById()</code> method removes an entity by its primary key.</p>
  <pre>
            <code>
                employeeRepository.deleteById(1L);
            </code>
        </pre>
</div>
<div class="style2">
  <h3>6. What is the purpose of the <code>@EntityListeners</code> annotation in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> The <code>@EntityListeners</code> annotation allows you to specify a class that listens for lifecycle events of the entity, such as <code>@PrePersist</code>, <code>@PostPersist</code>, etc.</p>
  <pre>
            <code>
                @Entity
                @EntityListeners(AuditListener.class)
                public class Employee { ... }
            </code>
        </pre>
</div>
<div class="style2">
  <h3>7. How do you use <code>Querydsl</code> with Spring Data JPA?</h3>
  <p><strong>Answer:</strong> Querydsl can be integrated with Spring Data JPA to create type-safe queries. It allows for building dynamic queries in a fluent style.</p>
  <pre>
            <code>
                QEmployee employee = QEmployee.employee;
                JPAQuery<Employee> query = new JPAQuery&lt;&gt;(entityManager);
                List<Employee> employees = query.select(employee)
                                                  .from(employee)
                                                  .where(employee.salary.gt(10000))
                                                  .fetch();
            </code>
        </pre>
</div>
<div class="style2">
  <h3>8. What is the <code>Specification</code> interface used for?</h3>
  <p><strong>Answer:</strong> The <code>Specification</code> interface is used to create dynamic, reusable predicates for queries in Spring Data JPA. It is particularly useful when combining multiple criteria in a type-safe way.</p>
  <pre>
            <code>
                Specification<Employee> salaryGreaterThan(BigDecimal salary) {
                    return (root, query, criteriaBuilder) -&gt; criteriaBuilder.greaterThan(root.get(&quot;salary&quot;), salary);
                }
            </code>
        </pre>
</div>
<div class="style2">
  <h3>9. How do you perform pagination in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> You can use the <code>Pageable</code> interface to request paginated results. The <code>Page</code> object returned will contain the data and pagination information.</p>
  <pre>
            <code>
                Page<Employee> page = employeeRepository.findAll(PageRequest.of(0, 10));
            </code>
        </pre>
</div>
<div class="style2">
  <h3>10. What is the purpose of the <code>@QueryHints</code> annotation?</h3>
  <p><strong>Answer:</strong> The <code>@QueryHints</code> annotation allows you to specify query hints, which can be used to optimize the query execution, such as setting the <code>javax.persistence.query.timeout</code> hint to control the query timeout.</p>
  <pre>
            <code>
                @QueryHints(@QueryHint(name = &quot;javax.persistence.query.timeout&quot;, value = &quot;5000&quot;))
                List<Employee> findEmployeesWithTimeout();
            </code>
        </pre>
</div>
<p class="style1">&nbsp;</p>
<h2 class="style1">Spring Data JPA - Set 4</h2>
<div class="style2">
  <h3>1. How do you implement an entity relationship in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> You can implement entity relationships in Spring Data JPA using annotations like <code>@OneToOne</code>, <code>@OneToMany</code>, <code>@ManyToOne</code>, and <code>@ManyToMany</code>. These annotations are used to define the cardinality of relationships between entities.</p>
  <pre>
            <code>
                @ManyToOne
                @JoinColumn(name = &quot;department_id&quot;)
                private Department department;
            </code>
        </pre>
</div>
<div class="style2">
  <h3>2. What does the <code>@JoinColumn</code> annotation do?</h3>
  <p><strong>Answer:</strong> The <code>@JoinColumn</code> annotation is used to specify the column that joins the current entity to the related entity in a relationship. It is typically used in <code>@ManyToOne</code> or <code>@OneToOne</code> relationships.</p>
  <pre>
            <code>
                @ManyToOne
                @JoinColumn(name = &quot;department_id&quot;)
                private Department department;
            </code>
        </pre>
</div>
<div class="style2">
  <h3>3. How do you configure a <code>@ManyToMany</code> relationship in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> You can configure a <code>@ManyToMany</code> relationship by using the <code>@ManyToMany</code> annotation on both sides of the relationship. The join table is automatically created by JPA if not explicitly defined.</p>
  <pre>
            <code>
                @ManyToMany
                @JoinTable(
                    name = &quot;employee_project&quot;,
                    joinColumns = @JoinColumn(name = &quot;employee_id&quot;),
                    inverseJoinColumns = @JoinColumn(name = &quot;project_id&quot;)
                )
                private List<Project> projects;
            </code>
        </pre>
</div>
<div class="style2">
  <h3>4. How do you perform a query using a <code>NamedQuery</code>?</h3>
  <p><strong>Answer:</strong> You can define a <code>NamedQuery</code> in the entity class using the <code>@NamedQuery</code> annotation. Then, you can use it in your repository methods by specifying the named query.</p>
  <pre>
            <code>
                @NamedQuery(name = &quot;Employee.findBySalary&quot;, query = &quot;SELECT e FROM Employee e WHERE e.salary &gt; :salary&quot;)
                public class Employee { ... }
            </code>
            <code>
                List<Employee> employees = entityManager.createNamedQuery(&quot;Employee.findBySalary&quot;)
                                                        .setParameter(&quot;salary&quot;, 50000)
                                                        .getResultList();
            </code>
        </pre>
</div>
<div class="style2">
  <h3>5. How can you use <code>@Transactional</code> with Spring Data JPA?</h3>
  <p><strong>Answer:</strong> The <code>@Transactional</code> annotation is used to define transactional boundaries for methods. It ensures that all operations within the method are executed within a transaction. If any operation fails, the transaction is rolled back.</p>
  <pre>
            <code>
                @Transactional
                public void updateEmployeeSalary(Long id, BigDecimal salary) {
                    Employee employee = employeeRepository.findById(id).orElseThrow(...);
                    employee.setSalary(salary);
                }
            </code>
        </pre>
</div>
<div class="style2">
  <h3>6. How do you use <code>QueryByExampleExecutor</code> in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> The <code>QueryByExampleExecutor</code> interface allows you to find entities by example. You can create an example object with the properties you want to match and then execute the query using that example.</p>
  <pre>
            <code>
                Example<Employee> example = Example.of(new Employee(null, &quot;John&quot;));
                List<Employee> employees = employeeRepository.findAll(example);
            </code>
        </pre>
</div>
<div class="style2">
  <h3>7. How do you use Spring Data JPA to implement pagination with sorting?</h3>
  <p><strong>Answer:</strong> You can use the <code>Pageable</code> interface with sorting options by passing a <code>PageRequest</code> object with sorting criteria to your repository method.</p>
  <pre>
            <code>
                PageRequest pageRequest = PageRequest.of(0, 10, Sort.by(&quot;salary&quot;).descending());
                Page<Employee> employees = employeeRepository.findAll(pageRequest);
            </code>
        </pre>
</div>
<div class="style2">
  <h3>8. What is the <code>@Version</code> annotation used for?</h3>
  <p><strong>Answer:</strong> The <code>@Version</code> annotation is used to implement optimistic locking. It ensures that updates to the entity are only made if the version value has not changed since the entity was last fetched.</p>
  <pre>
            <code>
                @Version
                private Long version;
            </code>
        </pre>
</div>
<div class="style2">
  <h3>9. How do you fetch related entities in Spring Data JPA using <code>fetch</code> joins?</h3>
  <p><strong>Answer:</strong> You can use <code>fetch</code> joins in <code>@Query</code> annotations to eagerly fetch related entities in a single query. This reduces the number of database queries needed for retrieving related entities.</p>
  <pre>
            <code>
                @Query(&quot;SELECT e FROM Employee e JOIN FETCH e.department WHERE e.salary &gt; :salary&quot;)
                List<Employee> findEmployeesWithDepartment(@Param(&quot;salary&quot;) BigDecimal salary);
            </code>
        </pre>
</div>
<div class="style2">
  <h3>10. How do you avoid N+1 problems in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> You can avoid N+1 problems by using <code>fetch</code> joins in your queries or by specifying the fetch strategy for relationships in your entity mappings, such as <code>@OneToMany(fetch = FetchType.LAZY)</code>.</p>
  <pre>
            <code>
                @Query(&quot;SELECT e FROM Employee e JOIN FETCH e.projects&quot;)
                List<Employee> findEmployeesWithProjects();
            </code>
        </pre>
</div>
<p class="style1">&nbsp;</p>
<h2 class="style1">Spring Data JPA - Set 5</h2>
<div class="style2">
  <h3>1. What is the difference between <code>fetch = FetchType.LAZY</code> and <code>fetch = FetchType.EAGER</code>?</h3>
  <p><strong>Answer:</strong> <code>LAZY</code> loading means that related entities are loaded only when they are accessed for the first time, whereas <code>EAGER</code> loading means that related entities are loaded immediately along with the parent entity. <code>LAZY</code> loading helps to avoid unnecessary database queries, but might lead to N+1 problems.</p>
  <pre>
            <code>
                @OneToMany(fetch = FetchType.LAZY)
                private Set<Order> orders;
            </code>
        </pre>
</div>
<div class="style2">
  <h3>2. How do you use Spring Data JPA’s <code>@Query</code> annotation?</h3>
  <p><strong>Answer:</strong> You can use the <code>@Query</code> annotation to define custom queries for repository methods. The query can be JPQL (Java Persistence Query Language) or SQL, and you can also use parameters within the query.</p>
  <pre>
            <code>
                @Query(&quot;SELECT e FROM Employee e WHERE e.salary &gt; :salary&quot;)
                List<Employee> findEmployeesBySalary(@Param(&quot;salary&quot;) BigDecimal salary);
            </code>
        </pre>
</div>
<div class="style2">
  <h3>3. What is the role of <code>@Repository</code> annotation in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> The <code>@Repository</code> annotation marks the interface as a Spring Data repository, enabling automatic implementation by Spring Data JPA. It also enables exception translation, converting database-related exceptions into Spring’s DataAccessException.</p>
  <pre>
            <code>
                @Repository
                public interface EmployeeRepository extends JpaRepository {
                }
            </code>
        </pre>
</div>
<div class="style2">
  <h3>4. How do you implement soft deletes in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> You can implement soft deletes by adding a <code>deleted</code> field (usually a boolean or a date) to your entity. Instead of removing the entity from the database, you update the field to mark the entity as deleted.</p>
  <pre>
            <code>
                @Entity
                public class Employee {
                    @Id
                    private Long id;
                    private Boolean deleted;
                    
                    public void markAsDeleted() {
                        this.deleted = true;
                    }
                }
            </code>
        </pre>
</div>
<div class="style2">
  <h3>5. How do you write a custom query to update a field in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> You can use the <code>@Modifying</code> annotation along with the <code>@Query</code> annotation to create a custom update query. You also need to ensure that the query is run within a transaction, which <code>@Transactional</code> can help with.</p>
  <pre>
            <code>
                @Modifying
                @Transactional
                @Query(&quot;UPDATE Employee e SET e.salary = :salary WHERE e.id = :id&quot;)
                int updateEmployeeSalary(@Param(&quot;id&quot;) Long id, @Param(&quot;salary&quot;) BigDecimal salary);
            </code>
        </pre>
</div>
<div class="style2">
  <h3>6. How do you create a derived query in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> You can create derived queries by defining method names in the repository interface that match the entity attributes and actions you want to query. Spring Data JPA automatically generates the SQL based on the method name.</p>
  <pre>
            <code>
                List<Employee> findBySalaryGreaterThan(BigDecimal salary);
                List<Employee> findByDepartmentName(String departmentName);
            </code>
        </pre>
</div>
<div class="style2">
  <h3>7. What is the purpose of <code>@QueryHints</code> in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> The <code>@QueryHints</code> annotation is used to provide additional query hints to the underlying JPA provider, such as specifying the fetch size, timeouts, or locking behavior.</p>
  <pre>
            <code>
                @QueryHints({ @QueryHint(name = &quot;javax.persistence.query.timeout&quot;, value = &quot;5000&quot;) })
                List<Employee> findByName(@Param(&quot;name&quot;) String name);
            </code>
        </pre>
</div>
<div class="style2">
  <h3>8. How do you configure cascade operations in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> Cascade operations are configured using the <code>@OneToMany</code>, <code>@OneToOne</code>, <code>@ManyToOne</code>, or <code>@ManyToMany</code> annotations. You can specify cascade types such as <code>CascadeType.ALL</code>, <code>CascadeType.PERSIST</code>, or <code>CascadeType.MERGE</code>.</p>
  <pre>
            <code>
                @OneToMany(cascade = CascadeType.ALL)
                private Set<Order> orders;
            </code>
        </pre>
</div>
<div class="style2">
  <h3>9. How do you implement custom pagination in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> You can implement custom pagination using the <code>Pageable</code> interface. You pass a <code>Pageable</code> object with page number, size, and sorting criteria to the repository method.</p>
  <pre>
            <code>
                Pageable pageable = PageRequest.of(0, 10, Sort.by(&quot;name&quot;).ascending());
                Page<Employee> employees = employeeRepository.findAll(pageable);
            </code>
        </pre>
</div>
<div class="style2">
  <h3>10. How can you query using native SQL in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> You can query using native SQL by setting the <code>nativeQuery</code> attribute to <code>true</code> in the <code>@Query</code> annotation. This allows you to write queries in SQL instead of JPQL.</p>
  <pre>
            <code>
                @Query(value = &quot;SELECT * FROM employee WHERE salary &gt; ?1&quot;, nativeQuery = true)
                List<Employee> findEmployeesBySalaryNative(BigDecimal salary);
            </code>
        </pre>
</div>
<p class="style1">&nbsp;</p>
<h2 class="style1">Spring Data JPA - Set 6</h2>
<div class="style2">
  <h3>1. How do you prevent N+1 query problems in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> To avoid N+1 query issues, you can use <code>fetch = FetchType.EAGER</code> cautiously, or prefer <code>fetch = FetchType.LAZY</code> with <code>@EntityGraph</code> or <code>JOIN FETCH</code> in JPQL queries to eagerly load associations when needed.</p>
  <pre>
            <code>
                @Query(&quot;SELECT e FROM Employee e JOIN FETCH e.orders&quot;)
                List<Employee> findEmployeesWithOrders();
            </code>
        </pre>
</div>
<div class="style2">
  <h3>2. What is the difference between <code>save()</code> and <code>saveAndFlush()</code> in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> <code>save()</code> persists an entity in the database, and the entity is synchronized with the database at a later point. <code>saveAndFlush()</code> persists the entity and immediately synchronizes the changes with the database.</p>
  <pre>
            <code>
                employeeRepository.save(employee); // Synchronized later
                employeeRepository.saveAndFlush(employee); // Immediate flush
            </code>
        </pre>
</div>
<div class="style2">
  <h3>3. How can you use <code>@ManyToMany</code> relationships in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> A <code>@ManyToMany</code> relationship is used when two entities have a many-to-many relationship, and a join table is typically used to store the associations between the entities.</p>
  <pre>
            <code>
                @ManyToMany
                @JoinTable(name = &quot;student_course&quot;,
                           joinColumns = @JoinColumn(name = &quot;student_id&quot;),
                           inverseJoinColumns = @JoinColumn(name = &quot;course_id&quot;))
                private Set<Course> courses;
            </code>
        </pre>
</div>
<div class="style2">
  <h3>4. How do you use <code>@OneToMany</code> with a <code>mappedBy</code> attribute?</h3>
  <p><strong>Answer:</strong> The <code>mappedBy</code> attribute is used on the non-owning side of a relationship (in this case, <code>@OneToMany</code>) to define the owner of the relationship. It prevents the creation of an extra join table.</p>
  <pre>
            <code>
                @OneToMany(mappedBy = &quot;employee&quot;)
                private Set<Task> tasks;
            </code>
        </pre>
</div>
<div class="style2">
  <h3>5. How do you implement optimistic locking in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> You can implement optimistic locking by adding a version field annotated with <code>@Version</code>. This ensures that no one modifies the entity concurrently while it is being updated.</p>
  <pre>
            <code>
                @Entity
                public class Product {
                    @Id
                    private Long id;
                    @Version
                    private Long version;
                }
            </code>
        </pre>
</div>
<div class="style2">
  <h3>6. How do you handle custom native SQL queries with named parameters?</h3>
  <p><strong>Answer:</strong> In Spring Data JPA, you can create a native SQL query using <code>@Query</code> with named parameters. Named parameters are referenced by the parameter name prefixed with a colon.</p>
  <pre>
            <code>
                @Query(value = &quot;SELECT * FROM employee WHERE salary &gt; :salary&quot;, nativeQuery = true)
                List<Employee> findEmployeesBySalary(@Param(&quot;salary&quot;) BigDecimal salary);
            </code>
        </pre>
</div>
<div class="style2">
  <h3>7. What is a <code>Specification</code> in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> <code>Specification</code> is a way to create reusable, type-safe queries in Spring Data JPA by using the <code>Specification</code> interface. It provides a flexible approach to build dynamic queries based on business needs.</p>
  <pre>
            <code>
                Specification<Employee> spec = (root, query, criteriaBuilder) -&gt;
                    criteriaBuilder.greaterThan(root.get(&quot;salary&quot;), 5000);
                employeeRepository.findAll(spec);
            </code>
        </pre>
</div>
<div class="style2">
  <h3>8. How do you implement a custom delete query in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> To implement a custom delete query, use the <code>@Modifying</code> annotation along with <code>@Query</code>. Ensure that you have the <code>@Transactional</code> annotation to manage the transaction.</p>
  <pre>
            <code>
                @Modifying
                @Transactional
                @Query(&quot;DELETE FROM Employee e WHERE e.id = :id&quot;)
                void deleteEmployeeById(@Param(&quot;id&quot;) Long id);
            </code>
        </pre>
</div>
<div class="style2">
  <h3>9. How do you handle pagination with dynamic sorting in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> To handle dynamic sorting with pagination, use the <code>Pageable</code> interface. You can specify both the page number, size, and sort criteria dynamically.</p>
  <pre>
            <code>
                Pageable pageable = PageRequest.of(0, 10, Sort.by(&quot;name&quot;).ascending());
                Page<Employee> employees = employeeRepository.findAll(pageable);
            </code>
        </pre>
</div>
<div class="style2">
  <h3>10. What is the purpose of <code>@EntityGraph</code> in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> <code>@EntityGraph</code> is used to define a graph of entities to be eagerly loaded. It helps to avoid N+1 query problems by specifying which associations should be fetched eagerly in a query.</p>
  <pre>
            <code>
                @EntityGraph(attributePaths = &quot;orders&quot;)
                List<Employee> findAll();
            </code>
        </pre>
</div>
<p class="style1">&nbsp;</p>
<h2 class="style1">Spring Data JPA - Set 7</h2>
<div class="style2">
  <h3>1. What is the purpose of the <code>@Query</code> annotation in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> The <code>@Query</code> annotation allows you to define custom JPQL or native SQL queries for repository methods. It provides a way to write queries that can't be automatically generated by Spring Data JPA.</p>
  <pre>
            <code>
                @Query(&quot;SELECT e FROM Employee e WHERE e.salary &gt; :salary&quot;)
                List<Employee> findEmployeesBySalary(@Param(&quot;salary&quot;) BigDecimal salary);
            </code>
        </pre>
</div>
<div class="style2">
  <h3>2. How do you create a custom repository method using <code>@Query</code>?</h3>
  <p><strong>Answer:</strong> You can define a custom repository method by annotating the method with <code>@Query</code> and providing a JPQL or SQL query. The method parameters are mapped to the query parameters using <code>@Param</code>.</p>
  <pre>
            <code>
                @Query(&quot;SELECT e FROM Employee e WHERE e.department = :department&quot;)
                List<Employee> findEmployeesByDepartment(@Param(&quot;department&quot;) String department);
            </code>
        </pre>
</div>
<div class="style2">
  <h3>3. What is the role of <code>Spring Data JPA</code> in handling database operations?</h3>
  <p><strong>Answer:</strong> Spring Data JPA simplifies database operations by providing repository interfaces that extend <code>JpaRepository</code> or <code>CrudRepository</code>. These interfaces come with predefined methods for common CRUD operations, reducing boilerplate code.</p>
</div>
<div class="style2">
  <h3>4. How do you define a one-to-one relationship in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> A <code>@OneToOne</code> relationship is defined between two entities where each entity is associated with exactly one instance of the other. You can also define cascading behaviors and fetch strategies.</p>
  <pre>
            <code>
                @OneToOne
                @JoinColumn(name = &quot;address_id&quot;)
                private Address address;
            </code>
        </pre>
</div>
<div class="style2">
  <h3>5. How do you prevent SQL injection when using native queries in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> To prevent SQL injection, always use parameterized queries in Spring Data JPA by binding variables using <code>@Param</code> and never concatenating user input directly into queries.</p>
  <pre>
            <code>
                @Query(&quot;SELECT e FROM Employee e WHERE e.name = :name&quot;)
                Employee findEmployeeByName(@Param(&quot;name&quot;) String name);
            </code>
        </pre>
</div>
<div class="style2">
  <h3>6. What is the difference between <code>findAll()</code> and <code>findAll(Sort sort)</code> methods in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> The <code>findAll()</code> method retrieves all entities from the database without any sorting. The <code>findAll(Sort sort)</code> method retrieves all entities but allows sorting based on the specified criteria.</p>
  <pre>
            <code>
                List<Employee> employees = employeeRepository.findAll(Sort.by(&quot;name&quot;).ascending());
            </code>
        </pre>
</div>
<div class="style2">
  <h3>7. How do you use the <code>@ElementCollection</code> annotation in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> The <code>@ElementCollection</code> is used to store a collection of basic types or embeddable objects in a separate table. It is typically used when the collection is not a full-fledged entity.</p>
  <pre>
            <code>
                @ElementCollection
                @CollectionTable(name = &quot;employee_phones&quot;, joinColumns = @JoinColumn(name = &quot;employee_id&quot;))
                @Column(name = &quot;phone&quot;)
                private Set<String> phones;
            </code>
        </pre>
</div>
<div class="style2">
  <h3>8. What is the difference between <code>@Query</code> and <code>@Modifying</code> annotations?</h3>
  <p><strong>Answer:</strong> The <code>@Query</code> annotation is used to define custom queries, while <code>@Modifying</code> is used to indicate that the query will modify the database (e.g., <code>DELETE</code>, <code>UPDATE</code>, etc.). <code>@Modifying</code> should be used with <code>@Transactional</code> to ensure the changes are committed.</p>
  <pre>
            <code>
                @Modifying
                @Transactional
                @Query(&quot;DELETE FROM Employee e WHERE e.id = :id&quot;)
                void deleteEmployeeById(@Param(&quot;id&quot;) Long id);
            </code>
        </pre>
</div>
<div class="style2">
  <h3>9. How do you implement pagination using Spring Data JPA?</h3>
  <p><strong>Answer:</strong> Pagination in Spring Data JPA can be done by using the <code>Pageable</code> interface, which allows you to specify the page size, page number, and sort criteria. The repository method will return a <code>Page</code> object containing the results.</p>
  <pre>
            <code>
                Pageable pageable = PageRequest.of(0, 10, Sort.by(&quot;name&quot;).ascending());
                Page<Employee> employees = employeeRepository.findAll(pageable);
            </code>
        </pre>
</div>
<div class="style2">
  <h3>10. How do you create a custom query method in Spring Data JPA based on field names?</h3>
  <p><strong>Answer:</strong> Spring Data JPA allows you to define query methods based on field names using the repository's method naming convention. It automatically generates queries by interpreting the method name.</p>
  <pre>
            <code>
                List<Employee> findByDepartmentAndSalaryGreaterThan(String department, BigDecimal salary);
            </code>
        </pre>
</div>
<p class="style1">&nbsp;</p>
<h2 class="style1">Spring Data JPA - Set 8</h2>
<div class="style2">
  <h3>1. What is the purpose of the <code>JpaRepository</code> interface?</h3>
  <p><strong>Answer:</strong> The <code>JpaRepository</code> interface is part of Spring Data JPA and provides several methods for CRUD operations, pagination, and sorting on entities. It simplifies database interactions by eliminating boilerplate code for common tasks.</p>
  <pre>
            <code>
                public interface EmployeeRepository extends JpaRepository {
                    List<Employee> findByDepartment(String department);
                }
            </code>
        </pre>
</div>
<div class="style2">
  <h3>2. How do you implement a custom query using Spring Data JPA?</h3>
  <p><strong>Answer:</strong> You can create a custom query by using the <code>@Query</code> annotation. This allows you to define a JPQL or native SQL query in the repository interface.</p>
  <pre>
            <code>
                @Query(&quot;SELECT e FROM Employee e WHERE e.salary &gt; :salary&quot;)
                List<Employee> findEmployeesBySalary(@Param(&quot;salary&quot;) BigDecimal salary);
            </code>
        </pre>
</div>
<div class="style2">
  <h3>3. How do you use <code>@Transactional</code> with Spring Data JPA?</h3>
  <p><strong>Answer:</strong> The <code>@Transactional</code> annotation ensures that the method runs within a transactional context. It can be used to control the transaction boundaries for write operations in the repository.</p>
  <pre>
            <code>
                @Transactional
                public void updateEmployeeSalary(Long employeeId, BigDecimal newSalary) {
                    Employee employee = employeeRepository.findById(employeeId).orElseThrow();
                    employee.setSalary(newSalary);
                    employeeRepository.save(employee);
                }
            </code>
        </pre>
</div>
<div class="style2">
  <h3>4. How do you handle multiple entities in a relationship using Spring Data JPA?</h3>
  <p><strong>Answer:</strong> You define the relationships using annotations like <code>@OneToMany</code>, <code>@ManyToOne</code>, or <code>@ManyToMany</code>. You can also specify cascading operations and fetch strategies.</p>
  <pre>
            <code>
                @OneToMany(mappedBy = &quot;employee&quot;)
                private Set<Task> tasks;
            </code>
        </pre>
</div>
<div class="style2">
  <h3>5. What is the use of <code>@JoinColumn</code> in entity relationships?</h3>
  <p><strong>Answer:</strong> The <code>@JoinColumn</code> annotation is used to specify the column that will be used to join two tables in a relationship. It helps define the foreign key in the database schema.</p>
  <pre>
            <code>
                @ManyToOne
                @JoinColumn(name = &quot;department_id&quot;)
                private Department department;
            </code>
        </pre>
</div>
<div class="style2">
  <h3>6. How do you use <code>Pageable</code> to handle pagination in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> You can pass a <code>Pageable</code> object to repository methods to handle pagination. The <code>Pageable</code> defines the page number, size, and sorting criteria.</p>
  <pre>
            <code>
                Pageable pageable = PageRequest.of(0, 10, Sort.by(&quot;name&quot;));
                Page<Employee> page = employeeRepository.findAll(pageable);
            </code>
        </pre>
</div>
<div class="style2">
  <h3>7. What is the difference between <code>save()</code> and <code>saveAll()</code> in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> The <code>save()</code> method is used to save a single entity, while <code>saveAll()</code> is used to save multiple entities in a batch operation.</p>
  <pre>
            <code>
                employeeRepository.save(employee);  // Save one employee
                employeeRepository.saveAll(employees);  // Save multiple employees
            </code>
        </pre>
</div>
<div class="style2">
  <h3>8. How do you implement a many-to-many relationship in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> A many-to-many relationship is defined using <code>@ManyToMany</code> annotation on both sides of the relationship. The join table is typically automatically created unless explicitly defined.</p>
  <pre>
            <code>
                @ManyToMany
                @JoinTable(
                    name = &quot;employee_project&quot;,
                    joinColumns = @JoinColumn(name = &quot;employee_id&quot;),
                    inverseJoinColumns = @JoinColumn(name = &quot;project_id&quot;)
                )
                private Set<Project> projects;
            </code>
        </pre>
</div>
<div class="style2">
  <h3>9. How do you map a one-to-many relationship in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> You use the <code>@OneToMany</code> annotation on the parent entity and the <code>@ManyToOne</code> annotation on the child entity.</p>
  <pre>
            <code>
                @OneToMany(mappedBy = &quot;employee&quot;)
                private Set<Task> tasks;
            </code>
        </pre>
</div>
<div class="style2">
  <h3>10. What is the purpose of the <code>@Entity</code> annotation in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> The <code>@Entity</code> annotation is used to mark a Java class as a JPA entity, which means it will be mapped to a table in the database. The class must have a no-argument constructor and a primary key.</p>
  <pre>
            <code>
                @Entity
                public class Employee {
                    @Id
                    private Long id;
                    private String name;
                    private BigDecimal salary;
                }
            </code>
        </pre>
</div>
<p class="style1">&nbsp;</p>
<h2 class="style1">Spring Data JPA - Set 9</h2>
<div class="style2">
  <h3>1. How can you define a custom query with pagination in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> You can define a custom query in the repository using the <code>@Query</code> annotation and return a <code>Page</code> object to support pagination.</p>
  <pre>
            <code>
                @Query(&quot;SELECT e FROM Employee e WHERE e.salary &gt; :salary&quot;)
                Page<Employee> findEmployeesBySalaryGreaterThan(@Param(&quot;salary&quot;) BigDecimal salary, Pageable pageable);
            </code>
        </pre>
</div>
<div class="style2">
  <h3>2. How do you map a unidirectional one-to-many relationship?</h3>
  <p><strong>Answer:</strong> A unidirectional one-to-many relationship is mapped by using <code>@OneToMany</code> on the parent entity and specifying the <code>mappedBy</code> attribute.</p>
  <pre>
            <code>
                @Entity
                public class Department {
                    @Id
                    private Long id;
                    private String name;
                
                    @OneToMany(mappedBy = &quot;department&quot;)
                    private Set<Employee> employees;
                }
            </code>
        </pre>
</div>
<div class="style2">
  <h3>3. How do you handle cascading operations in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> Cascading operations can be handled using the <code>@Cascade</code> annotation or by specifying <code>cascade = CascadeType</code> in the relationship annotations like <code>@OneToMany</code>, <code>@ManyToOne</code>.</p>
  <pre>
            <code>
                @OneToMany(cascade = CascadeType.ALL)
                private Set<Task> tasks;
            </code>
        </pre>
</div>
<div class="style2">
  <h3>4. What is the <code>@QueryHint</code> annotation used for in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> The <code>@QueryHint</code> annotation is used to provide additional hints to the JPA provider when executing a query. It is mainly used for optimization and tuning purposes.</p>
  <pre>
            <code>
                @QueryHints(value = @QueryHint(name = &quot;org.hibernate.cacheable&quot;, value = &quot;true&quot;))
                List<Employee> findByDepartment(String department);
            </code>
        </pre>
</div>
<div class="style2">
  <h3>5. How do you define a native SQL query in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> You can define a native SQL query by using the <code>@Query</code> annotation and setting <code>nativeQuery = true</code>.</p>
  <pre>
            <code>
                @Query(value = &quot;SELECT * FROM employees WHERE department = :department&quot;, nativeQuery = true)
                List<Employee> findEmployeesByDepartment(@Param(&quot;department&quot;) String department);
            </code>
        </pre>
</div>
<div class="style2">
  <h3>6. How do you perform a batch insert in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> A batch insert can be achieved by setting <code>hibernate.jdbc.batch_size</code> and using <code>@Modifying</code> with <code>@Query</code> for custom insert queries.</p>
  <pre>
            <code>
                @Modifying
                @Query(&quot;INSERT INTO Employee (name, salary) VALUES (:name, :salary)&quot;)
                void batchInsertEmployees(@Param(&quot;name&quot;) String name, @Param(&quot;salary&quot;) BigDecimal salary);
            </code>
        </pre>
</div>
<div class="style2">
  <h3>7. How do you implement custom repository methods with Spring Data JPA?</h3>
  <p><strong>Answer:</strong> Custom repository methods can be implemented by creating an interface that extends <code>JpaRepository</code> and defining your custom methods with the <code>@Query</code> annotation or custom logic in the implementation class.</p>
  <pre>
            <code>
                public interface EmployeeRepositoryCustom {
                    List<Employee> findEmployeesWithSalaryGreaterThan(BigDecimal salary);
                }

                public class EmployeeRepositoryCustomImpl implements EmployeeRepositoryCustom {
                    @Override
                    public List<Employee> findEmployeesWithSalaryGreaterThan(BigDecimal salary) {
                        // Custom logic
                    }
                }
            </code>
        </pre>
</div>
<div class="style2">
  <h3>8. What is the difference between <code>findAll</code> and <code>findById</code> methods in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> The <code>findAll</code> method retrieves all records from the database, whereas <code>findById</code> is used to retrieve a single record based on its primary key.</p>
  <pre>
            <code>
                List<Employee> employees = employeeRepository.findAll();  // Retrieve all records
                Optional<Employee> employee = employeeRepository.findById(1L);  // Retrieve by ID
            </code>
        </pre>
</div>
<div class="style2">
  <h3>9. How do you implement a custom query method with parameters in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> You define a custom method in the repository interface and use the <code>@Query</code> annotation to specify the query with named or positional parameters.</p>
  <pre>
            <code>
                @Query(&quot;SELECT e FROM Employee e WHERE e.department = :department AND e.salary &gt; :salary&quot;)
                List<Employee> findByDepartmentAndSalaryGreaterThan(@Param(&quot;department&quot;) String department, @Param(&quot;salary&quot;) BigDecimal salary);
            </code>
        </pre>
</div>
<div class="style2">
  <h3>10. What is the purpose of the <code>@EntityGraph</code> annotation?</h3>
  <p><strong>Answer:</strong> The <code>@EntityGraph</code> annotation is used to define a graph of entity attributes to be fetched eagerly when performing a query. It helps optimize fetching strategies for related entities.</p>
  <pre>
            <code>
                @EntityGraph(attributePaths = {&quot;tasks&quot;})
                List<Employee> findByDepartment(String department);
            </code>
        </pre>
</div>
<p class="style1">&nbsp;</p>
<h2 class="style1">Spring Data JPA - Set 10</h2>
<div class="style2">
  <h3>1. How can you define a projection in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> A projection is defined by using an interface or DTO class with getter methods that match the names of the entity's properties you wish to retrieve.</p>
  <pre>
            <code>
                public interface EmployeeProjection {
                    String getName();
                    BigDecimal getSalary();
                }
                List<EmployeeProjection> findByDepartment(String department);
            </code>
        </pre>
</div>
<div class="style2">
  <h3>2. How do you implement the &quot;one-to-one&quot; relationship in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> The <code>@OneToOne</code> annotation is used to define the &quot;one-to-one&quot; relationship between two entities, and the <code>mappedBy</code> attribute is used to specify the inverse side of the relationship.</p>
  <pre>
            <code>
                @Entity
                public class Employee {
                    @Id
                    private Long id;
                    private String name;
                
                    @OneToOne
                    private Address address;
                }
            </code>
        </pre>
</div>
<div class="style2">
  <h3>3. What is the purpose of the <code>@ManyToMany</code> annotation in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> The <code>@ManyToMany</code> annotation defines a &quot;many-to-many&quot; relationship between two entities, where both sides can have multiple associated entities.</p>
  <pre>
            <code>
                @ManyToMany
                @JoinTable(
                    name = &quot;employee_project&quot;,
                    joinColumns = @JoinColumn(name = &quot;employee_id&quot;),
                    inverseJoinColumns = @JoinColumn(name = &quot;project_id&quot;)
                )
                private Set<Project> projects;
            </code>
        </pre>
</div>
<div class="style2">
  <h3>4. What is the difference between <code>fetch</code> and <code>lazy</code> loading in Spring Data JPA?</h3>
  <p><strong>Answer:</strong> <code>fetch</code> is an attribute in <code>@ManyToOne</code>, <code>@OneToMany</code>, or <code>@OneToOne</code> to control whether related entities are fetched eagerly (<code>FetchType.EAGER</code>) or lazily (<code>FetchType.LAZY</code>).</p>
  <pre>
            <code>
                @ManyToOne(fetch = FetchType.LAZY)
                private Department department;
            </code>
        </pre>
</div>
<div class="style2">
  <h3>5. What is the role of the <code>@JoinColumn</code> annotation?</h3>
  <p><strong>Answer:</strong> The <code>@JoinColumn</code> annotation is used to specify the column that will be used to join an association between two entities in a relationship mapping (e.g., <code>@ManyToOne</code>, <code>@OneToMany</code>).</p>
  <pre>
            <code>
                @ManyToOne
                @JoinColumn(name = &quot;department_id&quot;)
                private Department department;
            </code>
        </pre>
</div>
<div class="style2">
  <h3>6. How do you create a derived query method for finding entities by a specific field?</h3>
  <p><strong>Answer:</strong> You create a method in the repository interface where the name follows a specific convention, such as <code>findBy</code> followed by the field name (capitalized).</p>
  <pre>
            <code>
                List<Employee> findByDepartment(String department);
            </code>
        </pre>
</div>
<div class="style2">
  <h3>7. What is a DTO (Data Transfer Object) and how do you use it with Spring Data JPA?</h3>
  <p><strong>Answer:</strong> A DTO is an object that carries data between processes. In Spring Data JPA, you can return DTOs instead of entities for custom queries to optimize performance and reduce unnecessary data exposure.</p>
  <pre>
            <code>
                public class EmployeeDTO {
                    private String name;
                    private BigDecimal salary;
                    // Getters and setters
                }
                @Query(&quot;SELECT new com.example.dto.EmployeeDTO(e.name, e.salary) FROM Employee e&quot;)
                List<EmployeeDTO> findEmployeeDTOs();
            </code>
        </pre>
</div>
<div class="style2">
  <h3>8. How do you fetch a related entity in the same query?</h3>
  <p><strong>Answer:</strong> You can fetch related entities in the same query by using <code>fetch</code> in a <code>JOIN</code> clause or using <code>@EntityGraph</code> to specify which attributes to eagerly load.</p>
  <pre>
            <code>
                @EntityGraph(attributePaths = {&quot;address&quot;})
                List<Employee> findAllWithAddress();
            </code>
        </pre>
</div>
<div class="style2">
  <h3>9. How do you specify an alias in a JPQL query?</h3>
  <p><strong>Answer:</strong> You can specify an alias for an entity in JPQL by using the <code>AS</code> keyword in the query, which allows you to reference the entity by its alias.</p>
  <pre>
            <code>
                @Query(&quot;SELECT e FROM Employee e WHERE e.department = :department&quot;)
                List<Employee> findEmployeesByDepartment(@Param(&quot;department&quot;) String department);
            </code>
        </pre>
</div>
<div class="style2">
  <h3>10. What is the function of the <code>@EnableJpaRepositories</code> annotation?</h3>
  <p><strong>Answer:</strong> The <code>@EnableJpaRepositories</code> annotation is used to enable the scanning of Spring Data JPA repositories in the application, allowing Spring to create implementations for repository interfaces.</p>
  <pre>
            <code>
                @EnableJpaRepositories(basePackages = &quot;com.example.repository&quot;)
                public class AppConfig {
                    // Configuration class
                }
            </code>
        </pre>
</div>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
</body>
</html>
