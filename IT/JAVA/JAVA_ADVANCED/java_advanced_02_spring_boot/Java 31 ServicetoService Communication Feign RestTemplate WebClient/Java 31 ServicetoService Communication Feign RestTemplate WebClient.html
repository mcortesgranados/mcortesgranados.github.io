<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Untitled Document</title>
<style type="text/css">
<!--
.answer {            margin-bottom: 20px;
}
.question {            margin-bottom: 10px;
}
.style1 {font-family: Arial, Helvetica, sans-serif}
.style2 {margin-bottom: 10px; font-family: Arial, Helvetica, sans-serif; }
.style3 {font-family: Arial, Helvetica, sans-serif; font-weight: bold; }
-->
</style>
</head>

<body>
<h1 class="style1">Set 1 - Service-to-Service Communication (Feign, RestTemplate, WebClient)</h1>
<p class="style3"><a href="Java 31 ServicetoService Communication Feign RestTemplate WebClient 01.mp3" target="_blank">Audio 1</a></p>
<div class="style2"> <b>Q1: What is the difference between Feign and RestTemplate in Spring?</b>
    <div class="answer">
      <p>Feign is a declarative web service client that integrates with Spring Cloud, allowing you to create HTTP clients with annotations. RestTemplate, on the other hand, is a more traditional Spring-based approach for making HTTP requests to remote services. Feign is typically easier to use and less boilerplate-heavy than RestTemplate.</p>
      <pre><code>@FeignClient(name = &quot;user-service&quot;) 
public interface UserClient { 
    @RequestMapping(&quot;/users/{id}&quot;) 
    User getUser(@PathVariable(&quot;id&quot;) String id); 
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q2: How do you use RestTemplate to call a REST API in Java?</b>
    <div class="answer">
      <p>In RestTemplate, you can use the <code>getForObject()</code> or <code>postForObject()</code> methods to call a REST API. You need to create a RestTemplate bean, which will be used for communication with the API.</p>
      <pre><code>RestTemplate restTemplate = new RestTemplate();
String url = &quot;http://example.com/api/users/1&quot;;
User user = restTemplate.getForObject(url, User.class);</code></pre>
    </div>
</div>
<div class="style2"> <b>Q3: How does WebClient differ from RestTemplate in Spring?</b>
    <div class="answer">
      <p>WebClient is the non-blocking, reactive alternative to RestTemplate. It supports asynchronous communication and allows for a more efficient handling of requests, especially in reactive applications. RestTemplate is blocking and synchronous, while WebClient provides better scalability and performance in modern applications.</p>
      <pre><code>WebClient webClient = WebClient.create();
Mono<User> userMono = webClient.get()
        .uri(&quot;http://example.com/api/users/1&quot;)
        .retrieve()
        .bodyToMono(User.class);</code></pre>
    </div>
</div>
<div class="style2"> <b>Q4: What are the advantages of using Feign in microservice architectures?</b>
    <div class="answer">
      <p>Feign simplifies service-to-service communication by providing declarative HTTP client interfaces. It reduces boilerplate code, integrates well with Spring Cloud, and automatically handles error responses, retries, and load balancing when used with Spring Cloud Netflix (Eureka, Ribbon). It also supports configuration via annotations, making it easier to maintain and modify.</p>
    </div>
</div>
<div class="style2"> <b>Q5: How do you handle error responses with RestTemplate in Java?</b>
    <div class="answer">
      <p>In RestTemplate, you can handle error responses by using an <code>HttpErrorHandler</code> or catching exceptions such as <code>HttpClientErrorException</code> and <code>HttpServerErrorException</code> to capture and process error details.</p>
      <pre><code>try {
    User user = restTemplate.getForObject(url, User.class);
} catch (HttpClientErrorException e) {
    // Handle client-side errors
} catch (HttpServerErrorException e) {
    // Handle server-side errors
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q6: How do you create a Feign client in Spring Boot?</b>
    <div class="answer">
      <p>To create a Feign client in Spring Boot, you need to annotate your interface with <code>@FeignClient</code> and provide the service name. You can then define the endpoints in the interface using Spring MVC annotations such as <code>@RequestMapping</code>.</p>
      <pre><code>@FeignClient(name = &quot;user-service&quot;)
public interface UserClient {
    @RequestMapping(&quot;/users/{id}&quot;)
    User getUser(@PathVariable(&quot;id&quot;) String id);
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q7: How do you perform asynchronous HTTP requests with WebClient in Spring?</b>
    <div class="answer">
      <p>WebClient supports asynchronous HTTP requests using <code>Mono</code> and <code>Flux</code> types. You can perform an asynchronous request by invoking the <code>retrieve()</code> method and handling the response asynchronously using <code>subscribe()</code>.</p>
      <pre><code>webClient.get()
    .uri(&quot;http://example.com/api/users/1&quot;)
    .retrieve()
    .bodyToMono(User.class)
    .subscribe(user -&gt; System.out.println(user.getName()));</code></pre>
    </div>
</div>
<div class="style2"> <b>Q8: How do you configure timeouts for WebClient in Spring?</b>
    <div class="answer">
      <p>You can configure timeouts for WebClient by using a custom <code>ClientHttpConnector</code> that applies connection and response timeouts. This is typically done with <code>ReactorNettyHttpClient</code> in Spring WebFlux.</p>
      <pre><code>ConnectionProvider provider = ConnectionProvider.builder(&quot;custom&quot;)
    .maxIdleTime(Duration.ofSeconds(30))
    .maxLifeTime(Duration.ofMinutes(5))
    .build();

HttpClient httpClient = HttpClient.create(provider)
    .responseTimeout(Duration.ofSeconds(10));

WebClient webClient = WebClient.builder()
    .clientConnector(new ReactorClientHttpConnector(httpClient))
    .build();</code></pre>
    </div>
</div>
<div class="style2"> <b>Q9: What is the purpose of the <code>@RequestMapping</code> annotation in Feign?</b>
    <div class="answer">
      <p>The <code>@RequestMapping</code> annotation in Feign is used to map a method in the Feign client interface to a REST endpoint. It specifies the HTTP method (GET, POST, PUT, DELETE) and the URL path for the request.</p>
      <pre><code>@FeignClient(name = &quot;user-service&quot;)
public interface UserClient {
    @RequestMapping(method = RequestMethod.GET, value = &quot;/users/{id}&quot;)
    User getUser(@PathVariable(&quot;id&quot;) String id);
}</code></pre>
    </div>
</div>
<h1 class="style1">Set 2 - Service-to-Service Communication (Feign, RestTemplate, WebClient)</h1>
<div class="style2"> <b>Q10: How do you configure a custom error handler in RestTemplate?</b>
    <div class="answer">
      <p>You can configure a custom error handler by implementing the <code>ResponseErrorHandler</code> interface and setting it on a <code>RestTemplate</code> instance using <code>setErrorHandler()</code>.</p>
      <pre><code>public class CustomErrorHandler implements ResponseErrorHandler {
    @Override
    public boolean hasError(ClientHttpResponse response) throws IOException {
        return (response.getStatusCode().series() == HttpStatus.Series.CLIENT_ERROR || 
                response.getStatusCode().series() == HttpStatus.Series.SERVER_ERROR);
    }

    @Override
    public void handleError(ClientHttpResponse response) throws IOException {
        // Handle error based on response status
    }
}

RestTemplate restTemplate = new RestTemplate();
restTemplate.setErrorHandler(new CustomErrorHandler());</code></pre>
    </div>
</div>
<div class="style2"> <b>Q11: What is the benefit of using WebClient for service-to-service communication?</b>
    <div class="answer">
      <p>WebClient provides several benefits, such as support for non-blocking, reactive programming. It can handle large-scale, concurrent requests with better performance, as it allows for asynchronous communication and is ideal for reactive applications.</p>
    </div>
</div>
<div class="style2"> <b>Q12: How can you use Feign with Spring Cloud for service discovery?</b>
    <div class="answer">
      <p>You can use Feign with Spring Cloud by combining it with a service discovery tool like Eureka. Feign will automatically resolve service names through the service registry to communicate with other services in the system.</p>
      <pre><code>@EnableFeignClients
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}

@FeignClient(name = &quot;user-service&quot;)
public interface UserClient {
    @RequestMapping(&quot;/users/{id}&quot;)
    User getUser(@PathVariable(&quot;id&quot;) String id);
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q13: What is the difference between Mono and Flux in WebClient?</b>
    <div class="answer">
      <p><code>Mono</code> is a reactive type that represents a single or empty asynchronous value. <code>Flux</code> is used for representing a sequence of asynchronous values. WebClient uses these types to handle single or multiple responses from a service.</p>
      <pre><code>Mono<User> userMono = webClient.get()
    .uri(&quot;http://example.com/api/users/1&quot;)
    .retrieve()
    .bodyToMono(User.class);

Flux<User> usersFlux = webClient.get()
    .uri(&quot;http://example.com/api/users&quot;)
    .retrieve()
    .bodyToFlux(User.class);</code></pre>
    </div>
</div>
<div class="style2"> <b>Q14: How do you handle retries in Feign clients?</b>
    <div class="answer">
      <p>You can enable automatic retries in Feign by using Spring Cloud Netflix's <code>Retryer</code> class. You can configure the retry policy using the <code>@FeignClient</code> annotation.</p>
      <pre><code>@FeignClient(name = &quot;user-service&quot;, configuration = RetryConfig.class)
public interface UserClient {
    @RequestMapping(&quot;/users/{id}&quot;)
    User getUser(@PathVariable(&quot;id&quot;) String id);
}

@Configuration
public class RetryConfig {
    @Bean
    public Retryer retryer() {
        return new Retryer.Default(100, 1000, 3);  // Initial, max interval, max attempts
    }
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q15: How can you integrate WebClient with a custom authentication header?</b>
    <div class="answer">
      <p>You can add custom authentication headers to WebClient requests by using the <code>header()</code> method to set authentication tokens or other headers.</p>
      <pre><code>webClient.get()
    .uri(&quot;http://example.com/api/users/1&quot;)
    .header(&quot;Authorization&quot;, &quot;Bearer token_value&quot;)
    .retrieve()
    .bodyToMono(User.class);</code></pre>
    </div>
</div>
<div class="style2"> <b>Q16: What is the role of <code>WebClient.Builder</code> in service-to-service communication?</b>
    <div class="answer">
      <p><code>WebClient.Builder</code> allows you to customize WebClient instances. You can set base URLs, add filters, or configure default headers and codecs before creating the WebClient instance.</p>
      <pre><code>WebClient webClient = WebClient.builder()
    .baseUrl(&quot;http://example.com&quot;)
    .defaultHeader(&quot;Authorization&quot;, &quot;Bearer token_value&quot;)
    .build();</code></pre>
    </div>
</div>
<div class="style2"> <b>Q17: How does RestTemplate handle JSON response mapping?</b>
    <div class="answer">
      <p>RestTemplate uses <code>HttpMessageConverter</code> to map JSON responses to Java objects. By default, it uses <code>MappingJackson2HttpMessageConverter</code> for JSON, which automatically deserializes JSON responses into Java objects.</p>
      <pre><code>RestTemplate restTemplate = new RestTemplate();
User user = restTemplate.getForObject(&quot;http://example.com/api/users/1&quot;, User.class);</code></pre>
    </div>
</div>
<div class="style2"> <b>Q18: Can you perform file uploads with Feign? How?</b>
    <div class="answer">
      <p>Yes, you can perform file uploads with Feign by using the <code>MultipartFile</code> class in the Feign client interface. You need to use the <code>@RequestPart</code> annotation to send the file as part of the multipart request.</p>
      <pre><code>@FeignClient(name = &quot;file-service&quot;)
public interface FileClient {
    @RequestMapping(method = RequestMethod.POST, value = &quot;/upload&quot;)
    String uploadFile(@RequestPart(&quot;file&quot;) MultipartFile file);
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q19: How do you enable synchronous calls with WebClient?</b>
    <div class="answer">
      <p>To make synchronous calls with WebClient, you can use the <code>block()</code> method, which blocks the calling thread until the response is received.</p>
      <pre><code>Mono<User> userMono = webClient.get()
    .uri(&quot;http://example.com/api/users/1&quot;)
    .retrieve()
    .bodyToMono(User.class);

User user = userMono.block(); // Blocks the thread until the response is received</code></pre>
    </div>
</div>
<p class="style1">&nbsp;</p>
<h1 class="style1">Set 3 - Service-to-Service Communication (Feign, RestTemplate, WebClient)</h1>
<div class="style2"> <b>Q20: How can you perform asynchronous communication using RestTemplate?</b>
    <div class="answer">
      <p>RestTemplate does not support asynchronous communication out of the box. However, you can wrap the <code>RestTemplate</code> calls in a <code>Future</code> or <code>CompletableFuture</code> to achieve asynchronous behavior.</p>
      <pre><code>ExecutorService executor = Executors.newFixedThreadPool(1);
Callable<User> task = () -&gt; restTemplate.getForObject(&quot;http://example.com/api/users/1&quot;, User.class);
Future<User> future = executor.submit(task);
User user = future.get();</code></pre>
    </div>
</div>
<div class="style2"> <b>Q21: How can you perform asynchronous communication using WebClient?</b>
    <div class="answer">
      <p>WebClient supports asynchronous communication out of the box by returning <code>Mono</code> or <code>Flux</code>, which represent asynchronous results.</p>
      <pre><code>Mono<User> userMono = webClient.get()
    .uri(&quot;http://example.com/api/users/1&quot;)
    .retrieve()
    .bodyToMono(User.class);

// To trigger the call asynchronously
userMono.subscribe(user -&gt; System.out.println(user.getName()));</code></pre>
    </div>
</div>
<div class="style2"> <b>Q22: How do you handle timeouts in WebClient?</b>
    <div class="answer">
      <p>You can configure timeouts in WebClient using the <code>baseUrl()</code> and <code>timeout()</code> methods, or by customizing the underlying <code>HttpClient</code> configuration.</p>
      <pre><code>WebClient webClient = WebClient.builder()
    .clientConnector(new ReactorClientHttpConnector(
        HttpClient.create().responseTimeout(Duration.ofSeconds(5))))
    .baseUrl(&quot;http://example.com&quot;)
    .build();</code></pre>
    </div>
</div>
<div class="style2"> <b>Q23: How do you handle retries with WebClient?</b>
    <div class="answer">
      <p>WebClient does not have built-in retry functionality, but you can use <code>Retry</code> from the <code>reactor-extra</code> library to add retries.</p>
      <pre><code>WebClient webClient = WebClient.builder()
    .clientConnector(new ReactorClientHttpConnector(
        HttpClient.create()
            .retry(3))) // Retry 3 times
    .baseUrl(&quot;http://example.com&quot;)
    .build();</code></pre>
    </div>
</div>
<div class="style2"> <b>Q24: What is the difference between synchronous and asynchronous communication in WebClient?</b>
    <div class="answer">
      <p>Synchronous communication blocks the calling thread until the response is received, while asynchronous communication returns control to the calling thread immediately and processes the response when it is available.</p>
      <pre><code>// Synchronous
User user = webClient.get()
    .uri(&quot;http://example.com/api/users/1&quot;)
    .retrieve()
    .bodyToMono(User.class)
    .block();

// Asynchronous
webClient.get()
    .uri(&quot;http://example.com/api/users/1&quot;)
    .retrieve()
    .bodyToMono(User.class)
    .subscribe(user -&gt; System.out.println(user.getName()));</code></pre>
    </div>
</div>
<div class="style2"> <b>Q25: How can you make service calls with multiple paths using WebClient?</b>
    <div class="answer">
      <p>You can use placeholders in the URI and bind them using <code>uri()</code> method with <code>uriVariables</code>.</p>
      <pre><code>webClient.get()
    .uri(&quot;http://example.com/api/users/{id}/details&quot;, 1)
    .retrieve()
    .bodyToMono(User.class);</code></pre>
    </div>
</div>
<div class="style2"> <b>Q26: How do you use Feign with authentication headers?</b>
    <div class="answer">
      <p>In Feign, you can use a request interceptor to add authentication headers to your requests.</p>
      <pre><code>@Configuration
public class FeignConfig {
    @Bean
    public RequestInterceptor requestInterceptor() {
        return requestTemplate -&gt; requestTemplate.header(&quot;Authorization&quot;, &quot;Bearer token_value&quot;);
    }
}

@FeignClient(name = &quot;user-service&quot;, configuration = FeignConfig.class)
public interface UserClient {
    @RequestMapping(&quot;/users/{id}&quot;)
    User getUser(@PathVariable(&quot;id&quot;) String id);
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q27: How do you configure a timeout in Feign?</b>
    <div class="answer">
      <p>You can configure timeouts in Feign by setting <code>connectTimeout</code> and <code>readTimeout</code> in the <code>Feign.Builder</code>.</p>
      <pre><code>@Bean
public Request.Options options() {
    return new Request.Options(5000, TimeUnit.MILLISECONDS, 5000, TimeUnit.MILLISECONDS, true);
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q28: How do you log requests and responses in Feign?</b>
    <div class="answer">
      <p>Feign allows you to log requests and responses using a <code>Logger</code> implementation.</p>
      <pre><code>@Bean
Logger.Level feignLoggerLevel() {
    return Logger.Level.FULL;
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q29: What is the default logging level in Feign?</b>
    <div class="answer">
      <p>The default logging level in Feign is <code>NONE</code>, meaning it does not log requests or responses unless explicitly configured.</p>
    </div>
</div>
<p class="style1">&nbsp;</p>
<h1 class="style1">Set 4 - Service-to-Service Communication (Feign, RestTemplate, WebClient)</h1>
<div class="style2"> <b>Q30: How do you handle retries in Feign?</b>
    <div class="answer">
      <p>You can enable retries in Feign by configuring a retryer in the Feign client. The default retryer retries up to 5 times with an increasing delay.</p>
      <pre><code>@FeignClient(name = &quot;user-service&quot;, retryer = Retryer.NEVER_RETRY)
public interface UserClient {
    @RequestMapping(&quot;/users/{id}&quot;)
    User getUser(@PathVariable(&quot;id&quot;) String id);
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q31: How do you configure Feign for custom error handling?</b>
    <div class="answer">
      <p>You can configure a custom error decoder to handle errors in Feign.</p>
      <pre><code>@Bean
public ErrorDecoder errorDecoder() {
    return new CustomErrorDecoder();
}

public class CustomErrorDecoder implements ErrorDecoder {
    @Override
    public Exception decode(String methodKey, Response response) {
        if (response.status() == 404) {
            return new CustomNotFoundException(&quot;Not Found&quot;);
        }
        return new Exception(&quot;Generic error&quot;);
    }
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q32: How can you use WebClient to handle a POST request?</b>
    <div class="answer">
      <p>WebClient can be used for sending a POST request by specifying the request body and calling the <code>post()</code> method.</p>
      <pre><code>webClient.post()
    .uri(&quot;http://example.com/api/users&quot;)
    .bodyValue(new User(&quot;John&quot;, &quot;Doe&quot;))
    .retrieve()
    .bodyToMono(User.class)
    .subscribe(response -&gt; System.out.println(response.getName()));</code></pre>
    </div>
</div>
<div class="style2"> <b>Q33: How do you handle request headers in WebClient?</b>
    <div class="answer">
      <p>In WebClient, you can add request headers by using the <code>header()</code> method.</p>
      <pre><code>webClient.get()
    .uri(&quot;http://example.com/api/users&quot;)
    .header(&quot;Authorization&quot;, &quot;Bearer token&quot;)
    .retrieve()
    .bodyToMono(User.class)
    .subscribe(user -&gt; System.out.println(user.getName()));</code></pre>
    </div>
</div>
<div class="style2"> <b>Q34: What is the role of WebClient’s retrieve() method?</b>
    <div class="answer">
      <p>The <code>retrieve()</code> method in WebClient is used to start the actual HTTP request. It returns a <code>ResponseSpec</code>, which is used to specify how to handle the response (e.g., mapping it to a Java object).</p>
      <pre><code>webClient.get()
    .uri(&quot;http://example.com/api/users&quot;)
    .retrieve()
    .bodyToMono(User.class)
    .subscribe(user -&gt; System.out.println(user.getName()));</code></pre>
    </div>
</div>
<div class="style2"> <b>Q35: How can you configure Feign with Spring Cloud to work with Eureka?</b>
    <div class="answer">
      <p>You can use Spring Cloud Feign with Eureka by enabling Feign clients in your Spring Boot application and specifying the service name to interact with.</p>
      <pre><code>@EnableFeignClients
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);

    }
}

@FeignClient(&quot;user-service&quot;)
public interface UserClient {
    @RequestMapping(&quot;/users/{id}&quot;)
    User getUser(@PathVariable(&quot;id&quot;) String id);
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q36: How do you log request/response headers in WebClient?</b>
    <div class="answer">
      <p>In WebClient, you can log request/response headers by using a custom <code>ExchangeFilterFunction</code> that logs the headers.</p>
      <pre><code>ExchangeFilterFunction logRequest = ExchangeFilterFunction.ofRequestProcessor(clientRequest -&gt; {
    System.out.println(&quot;Request: &quot; + clientRequest.headers());
    return Mono.just(clientRequest);
});

ExchangeFilterFunction logResponse = ExchangeFilterFunction.ofResponseProcessor(clientResponse -&gt; {
    System.out.println(&quot;Response: &quot; + clientResponse.headers());
    return Mono.just(clientResponse);
});

WebClient webClient = WebClient.builder()
    .filter(logRequest)
    .filter(logResponse)
    .baseUrl(&quot;http://example.com&quot;)
    .build();</code></pre>
    </div>
</div>
<div class="style2"> <b>Q37: How do you handle content type in WebClient?</b>
    <div class="answer">
      <p>In WebClient, you can specify the content type of the request by using the <code>contentType()</code> method.</p>
      <pre><code>webClient.post()
    .uri(&quot;http://example.com/api/users&quot;)
    .contentType(MediaType.APPLICATION_JSON)
    .bodyValue(new User(&quot;John&quot;, &quot;Doe&quot;))
    .retrieve()
    .bodyToMono(User.class)
    .subscribe(response -&gt; System.out.println(response.getName()));</code></pre>
    </div>
</div>
<div class="style2"> <b>Q38: How can you handle different response types with Feign?</b>
    <div class="answer">
      <p>You can handle different response types in Feign by specifying the return type and using Spring’s <code>ResponseEntity</code> for more control over the response.</p>
      <pre><code>@FeignClient(&quot;user-service&quot;)
public interface UserClient {
    @RequestMapping(&quot;/users/{id}&quot;)
    ResponseEntity<User> getUser(@PathVariable(&quot;id&quot;) String id);
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q39: How do you use Feign for service discovery with Ribbon?</b>
    <div class="answer">
      <p>In Spring Cloud, Feign and Ribbon work together for client-side load balancing. Feign will interact with Eureka for service discovery, and Ribbon will handle the load balancing.</p>
      <pre><code>@EnableFeignClients
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}

@FeignClient(name = &quot;user-service&quot;)
public interface UserClient {
    @RequestMapping(&quot;/users/{id}&quot;)
    User getUser(@PathVariable(&quot;id&quot;) String id);
}</code></pre>
    </div>
</div>
<p class="style1">&nbsp;</p>
<h1 class="style1">Set 5 - Service-to-Service Communication (Feign, RestTemplate, WebClient)</h1>
<div class="style2"> <b>Q40: How do you make a GET request with RestTemplate?</b>
    <div class="answer">
      <p>In RestTemplate, you can make a GET request by using the <code>getForObject()</code> method.</p>
      <pre><code>RestTemplate restTemplate = new RestTemplate();
String url = &quot;http://example.com/api/users/{id}&quot;;
User user = restTemplate.getForObject(url, User.class, &quot;123&quot;);</code></pre>
    </div>
</div>
<div class="style2"> <b>Q41: How do you use RestTemplate to post JSON data to an endpoint?</b>
    <div class="answer">
      <p>You can send JSON data in a POST request using RestTemplate by using the <code>postForObject()</code> method and setting the body.</p>
      <pre><code>RestTemplate restTemplate = new RestTemplate();
String url = &quot;http://example.com/api/users&quot;;
User user = new User(&quot;John&quot;, &quot;Doe&quot;);
User createdUser = restTemplate.postForObject(url, user, User.class);</code></pre>
    </div>
</div>
<div class="style2"> <b>Q42: How do you configure WebClient with a base URL?</b>
    <div class="answer">
      <p>You can configure WebClient with a base URL using the <code>baseUrl()</code> method while building the WebClient instance.</p>
      <pre><code>WebClient webClient = WebClient.builder()
    .baseUrl(&quot;http://example.com&quot;)
    .build();</code></pre>
    </div>
</div>
<div class="style2"> <b>Q43: How do you handle timeouts with RestTemplate?</b>
    <div class="answer">
      <p>You can configure timeouts for RestTemplate by setting a custom <code>ClientHttpRequestFactory</code> with a timeout configuration.</p>
      <pre><code>int timeout = 5000; // 5 seconds
HttpComponentsClientHttpRequestFactory factory = new HttpComponentsClientHttpRequestFactory();
RequestConfig requestConfig = RequestConfig.custom()
    .setConnectTimeout(timeout)
    .setSocketTimeout(timeout)
    .build();
HttpClient httpClient = HttpClients.custom()
    .setDefaultRequestConfig(requestConfig)
    .build();
factory.setHttpClient(httpClient);
RestTemplate restTemplate = new RestTemplate(factory);</code></pre>
    </div>
</div>
<div class="style2"> <b>Q44: How can you set a custom error decoder in Feign?</b>
    <div class="answer">
      <p>Feign allows you to set a custom error decoder to handle specific error conditions. You can create your custom decoder and configure it using the <code>errorDecoder()</code> bean.</p>
      <pre><code>@Bean
public ErrorDecoder errorDecoder() {
    return new CustomErrorDecoder();
}

public class CustomErrorDecoder implements ErrorDecoder {
    @Override
    public Exception decode(String methodKey, Response response) {
        if (response.status() == 404) {
            return new NotFoundException(&quot;Resource not found&quot;);
        }
        return new Exception(&quot;Generic error&quot;);
    }
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q45: What is the purpose of WebClient's exchange() method?</b>
    <div class="answer">
      <p>The <code>exchange()</code> method in WebClient allows for more control over the response, including access to the full <code>ClientResponse</code>.</p>
      <pre><code>webClient.get()
    .uri(&quot;http://example.com/api/users&quot;)
    .exchange()
    .flatMap(response -&gt; response.bodyToMono(User.class))
    .subscribe(user -&gt; System.out.println(user.getName()));</code></pre>
    </div>
</div>
<div class="style2"> <b>Q46: How do you handle exceptions with RestTemplate?</b>
    <div class="answer">
      <p>RestTemplate can throw different exceptions like <code>HttpClientErrorException</code> or <code>HttpServerErrorException</code>. You can handle these exceptions using a try-catch block.</p>
      <pre><code>try {
    User user = restTemplate.getForObject(url, User.class);
} catch (HttpClientErrorException e) {
    // handle client error
} catch (HttpServerErrorException e) {
    // handle server error
} catch (Exception e) {
    // handle generic error
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q47: What is the main difference between Feign and RestTemplate?</b>
    <div class="answer">
      <p>The main difference is that Feign is declarative and allows you to define client interfaces for HTTP calls, while RestTemplate is a more imperative way of making HTTP requests programmatically.</p>
      <pre><code>@FeignClient(&quot;user-service&quot;)
public interface UserClient {
    @RequestMapping(&quot;/users/{id}&quot;)
    User getUser(@PathVariable(&quot;id&quot;) String id);
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q48: How do you configure the WebClient timeout settings?</b>
    <div class="answer">
      <p>You can configure timeout settings in WebClient by using a <code>HttpClient</code> with custom timeout configurations.</p>
      <pre><code>Duration timeout = Duration.ofSeconds(5);
WebClient.builder()
    .clientConnector(new ReactorClientHttpConnector(
        HttpClient.create()
            .responseTimeout(timeout)
            .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)
    ))
    .baseUrl(&quot;http://example.com&quot;)
    .build();</code></pre>
    </div>
</div>
<div class="style2"> <b>Q49: How do you call a REST API asynchronously with WebClient?</b>
    <div class="answer">
      <p>You can make asynchronous calls with WebClient by using the <code>subscribe()</code> method or returning a <code>Mono</code> or <code>Flux</code>.</p>
      <pre><code>webClient.get()
    .uri(&quot;http://example.com/api/users&quot;)
    .retrieve()
    .bodyToMono(User.class)
    .subscribe(user -&gt; System.out.println(user.getName()));</code></pre>
    </div>
</div>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<h1 class="style1">Set 6 - Service-to-Service Communication (Feign, RestTemplate, WebClient)</h1>
<div class="style2"> <b>Q50: How do you create a Feign client interface in Spring?</b>
    <div class="answer">
      <p>To create a Feign client interface, you annotate the interface with <code>@FeignClient</code> and define the methods for API calls.</p>
      <pre><code>@FeignClient(&quot;user-service&quot;)
public interface UserClient {
    @GetMapping(&quot;/users/{id}&quot;)
    User getUser(@PathVariable(&quot;id&quot;) String id);
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q51: How do you make a PUT request using WebClient?</b>
    <div class="answer">
      <p>You can make a PUT request using WebClient by calling <code>put()</code> and passing the body of the request.</p>
      <pre><code>WebClient webClient = WebClient.create();
webClient.put()
    .uri(&quot;http://example.com/api/users/{id}&quot;, 123)
    .bodyValue(updatedUser)
    .retrieve()
    .bodyToMono(User.class)
    .subscribe(user -&gt; System.out.println(user));</code></pre>
    </div>
</div>
<div class="style2"> <b>Q52: How do you configure Feign to use a custom logger?</b>
    <div class="answer">
      <p>Feign allows you to set a custom logger by specifying a <code>Logger.Level</code> in the <code>@FeignClient</code> annotation or configuration.</p>
      <pre><code>@FeignClient(name = &quot;user-service&quot;, configuration = CustomFeignConfig.class)
public interface UserClient {
    @GetMapping(&quot;/users/{id}&quot;)
    User getUser(@PathVariable(&quot;id&quot;) String id);
}

@Configuration
public class CustomFeignConfig {
    @Bean
    public Logger.Level feignLoggerLevel() {
        return Logger.Level.FULL;
    }
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q53: How do you handle HTTP errors in WebClient?</b>
    <div class="answer">
      <p>In WebClient, you can handle HTTP errors by using the <code>onStatus()</code> method to check for specific response statuses.</p>
      <pre><code>webClient.get()
    .uri(&quot;http://example.com/api/users&quot;)
    .retrieve()
    .onStatus(HttpStatus::is4xxClientError, response -&gt; Mono.error(new CustomClientException(&quot;Client error&quot;)))
    .onStatus(HttpStatus::is5xxServerError, response -&gt; Mono.error(new CustomServerException(&quot;Server error&quot;)))
    .bodyToMono(User.class)
    .subscribe(user -&gt; System.out.println(user));</code></pre>
    </div>
</div>
<div class="style2"> <b>Q54: How do you perform basic authentication using RestTemplate?</b>
    <div class="answer">
      <p>To perform basic authentication with RestTemplate, you need to set the <code>Authorization</code> header using <code>HttpHeaders</code>.</p>
      <pre><code>HttpHeaders headers = new HttpHeaders();
headers.setBasicAuth(&quot;username&quot;, &quot;password&quot;);
HttpEntity<String> entity = new HttpEntity&lt;&gt;(headers);
RestTemplate restTemplate = new RestTemplate();
String url = &quot;http://example.com/api/users&quot;;
ResponseEntity<User> response = restTemplate.exchange(url, HttpMethod.GET, entity, User.class);</code></pre>
    </div>
</div>
<div class="style2"> <b>Q55: How can you log requests and responses in Feign?</b>
    <div class="answer">
      <p>You can log requests and responses in Feign by configuring the <code>Logger</code> class and setting the <code>Logger.Level</code>.</p>
      <pre><code>Logger.Level feignLoggerLevel = Logger.Level.FULL;
@FeignClient(name = &quot;user-service&quot;, configuration = FeignConfig.class)
public interface UserClient {
    @RequestMapping(&quot;/users/{id}&quot;)
    User getUser(@PathVariable(&quot;id&quot;) String id);
}

@Configuration
public class FeignConfig {
    @Bean
    public Logger.Level feignLoggerLevel() {
        return Logger.Level.FULL;
    }
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q56: How do you pass query parameters in WebClient?</b>
    <div class="answer">
      <p>You can pass query parameters in WebClient by using the <code>uri()</code> method with <code>UriComponentsBuilder</code> or by directly specifying the parameters in the URI string.</p>
      <pre><code>WebClient webClient = WebClient.create();
webClient.get()
    .uri(&quot;http://example.com/api/users?age={age}&amp;city={city}&quot;, 30, &quot;New York&quot;)
    .retrieve()
    .bodyToMono(User.class)
    .subscribe(user -&gt; System.out.println(user));</code></pre>
    </div>
</div>
<div class="style2"> <b>Q57: How do you send a JSON payload with a PUT request using RestTemplate?</b>
    <div class="answer">
      <p>You can send a JSON payload with a PUT request by creating an <code>HttpEntity</code> with the body and sending it using <code>exchange()</code>.</p>
      <pre><code>HttpHeaders headers = new HttpHeaders();
headers.setContentType(MediaType.APPLICATION_JSON);
HttpEntity<User> entity = new HttpEntity&lt;&gt;(updatedUser, headers);
RestTemplate restTemplate = new RestTemplate();
String url = &quot;http://example.com/api/users/{id}&quot;;
restTemplate.exchange(url, HttpMethod.PUT, entity, User.class, &quot;123&quot;);</code></pre>
    </div>
</div>
<div class="style2"> <b>Q58: What is the advantage of using Feign over RestTemplate?</b>
    <div class="answer">
      <p>Feign provides a declarative way to make HTTP requests, which is more concise and easier to maintain compared to RestTemplate's imperative approach.</p>
      <pre><code>@FeignClient(&quot;user-service&quot;)
public interface UserClient {
    @GetMapping(&quot;/users/{id}&quot;)
    User getUser(@PathVariable(&quot;id&quot;) String id);
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q59: How do you perform a synchronous REST call with WebClient?</b>
    <div class="answer">
      <p>WebClient calls are asynchronous by default, but you can block the thread to perform a synchronous call by using <code>block()</code>.</p>
      <pre><code>User user = webClient.get()
    .uri(&quot;http://example.com/api/users&quot;)
    .retrieve()
    .bodyToMono(User.class)
    .block();</code></pre>
    </div>
</div>
<div class="style2"> <b>Q60: How do you implement retry logic with WebClient?</b>
    <div class="answer">
      <p>To implement retry logic with WebClient, you can use <code>retryWhen()</code> and specify the retry conditions.</p>
      <pre><code>webClient.get()
    .uri(&quot;http://example.com/api/users&quot;)
    .retrieve()
    .bodyToMono(User.class)
    .retryWhen(Retry.fixedDelay(3, Duration.ofSeconds(1)))
    .subscribe(user -&gt; System.out.println(user));</code></pre>
    </div>
</div>
<p class="style1">&nbsp;</p>
<h1 class="style1">Set 7 - Service-to-Service Communication (Feign, RestTemplate, WebClient)</h1>
<div class="style2"> <b>Q61: How do you configure RestTemplate to handle timeouts?</b>
    <div class="answer">
      <p>You can configure timeouts for RestTemplate using <code>HttpClient</code> and setting the connection and read timeouts.</p>
      <pre><code>RequestConfig requestConfig = RequestConfig.custom()
    .setConnectTimeout(5000) // 5 seconds
    .setSocketTimeout(5000) // 5 seconds
    .build();

CloseableHttpClient httpClient = HttpClients.custom()
    .setDefaultRequestConfig(requestConfig)
    .build();

HttpComponentsClientHttpRequestFactory factory = new HttpComponentsClientHttpRequestFactory(httpClient);
RestTemplate restTemplate = new RestTemplate(factory);</code></pre>
    </div>
</div>
<div class="style2"> <b>Q62: How do you send a POST request with JSON payload using Feign?</b>
    <div class="answer">
      <p>To send a POST request with a JSON payload using Feign, you annotate the method with <code>@PostMapping</code> and use <code>RequestBody</code> for the data.</p>
      <pre><code>@FeignClient(&quot;user-service&quot;)
public interface UserClient {
    @PostMapping(&quot;/users&quot;)
    User createUser(@RequestBody User user);
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q63: How do you enable logging for RestTemplate requests?</b>
    <div class="answer">
      <p>You can enable logging for RestTemplate by using a <code>RequestLoggingInterceptor</code> and adding it to the <code>RestTemplate</code>.</p>
      <pre><code>RequestLoggingInterceptor loggingInterceptor = new RequestLoggingInterceptor();
RestTemplate restTemplate = new RestTemplate();
restTemplate.getInterceptors().add(loggingInterceptor);</code></pre>
    </div>
</div>
<div class="style2"> <b>Q64: How do you handle responses with different content types in WebClient?</b>
    <div class="answer">
      <p>WebClient allows you to handle different content types by using the <code>accept()</code> method to specify the expected content type for the response.</p>
      <pre><code>webClient.get()
    .uri(&quot;http://example.com/api/users&quot;)
    .accept(MediaType.APPLICATION_JSON)
    .retrieve()
    .bodyToMono(User.class)
    .subscribe(user -&gt; System.out.println(user));</code></pre>
    </div>
</div>
<div class="style2"> <b>Q65: How do you use a custom error decoder with Feign?</b>
    <div class="answer">
      <p>To use a custom error decoder with Feign, you create a class that implements <code>ErrorDecoder</code> and provide it in the Feign configuration.</p>
      <pre><code>public class CustomErrorDecoder implements ErrorDecoder {
    @Override
    public Exception decode(String methodKey, Response response) {
        if (response.status() == 404) {
            return new NotFoundException(&quot;Resource not found&quot;);
        }
        return new Exception(&quot;Generic error&quot;);
    }
}

@FeignClient(name = &quot;user-service&quot;, configuration = CustomFeignConfig.class)
public interface UserClient {
    @GetMapping(&quot;/users/{id}&quot;)
    User getUser(@PathVariable(&quot;id&quot;) String id);
}

@Configuration
public class CustomFeignConfig {
    @Bean
    public ErrorDecoder errorDecoder() {
        return new CustomErrorDecoder();
    }
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q66: How do you use RestTemplate with OAuth2 authentication?</b>
    <div class="answer">
      <p>To use RestTemplate with OAuth2 authentication, you need to set the <code>Authorization</code> header with the access token.</p>
      <pre><code>HttpHeaders headers = new HttpHeaders();
headers.set(&quot;Authorization&quot;, &quot;Bearer &quot; + accessToken);
HttpEntity<String> entity = new HttpEntity&lt;&gt;(headers);
RestTemplate restTemplate = new RestTemplate();
ResponseEntity<String> response = restTemplate.exchange(&quot;http://example.com/api/resource&quot;, HttpMethod.GET, entity, String.class);</code></pre>
    </div>
</div>
<div class="style2"> <b>Q67: How do you handle retries in Feign?</b>
    <div class="answer">
      <p>Feign supports retry functionality with a <code>Retryer</code> bean that can be configured to control the retry behavior.</p>
      <pre><code>@Bean
public Retryer feignRetryer() {
    return new Retryer.Default(100, 1000, 3);
}

@FeignClient(name = &quot;user-service&quot;, configuration = RetryConfig.class)
public interface UserClient {
    @GetMapping(&quot;/users/{id}&quot;)
    User getUser(@PathVariable(&quot;id&quot;) String id);
}

@Configuration
public class RetryConfig {
    @Bean
    public Retryer retryer() {
        return new Retryer.Default(100, 1000, 3); // retry 3 times with exponential backoff
    }
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q68: How do you handle exceptions globally with RestTemplate?</b>
    <div class="answer">
      <p>To handle exceptions globally with RestTemplate, you can define a <code>ResponseErrorHandler</code> and set it on your RestTemplate instance.</p>
      <pre><code>public class CustomErrorHandler implements ResponseErrorHandler {
    @Override
    public boolean hasError(ClientHttpResponse response) throws IOException {
        return response.getStatusCode().series() == HttpStatus.Series.CLIENT_ERROR 
                || response.getStatusCode().series() == HttpStatus.Series.SERVER_ERROR;
    }

    @Override
    public void handleError(ClientHttpResponse response) throws IOException {
        // handle the error
    }
}

RestTemplate restTemplate = new RestTemplate();
restTemplate.setErrorHandler(new CustomErrorHandler());</code></pre>
    </div>
</div>
<div class="style2"> <b>Q69: How do you authenticate with API keys in WebClient?</b>
    <div class="answer">
      <p>You can authenticate with API keys in WebClient by adding the API key to the <code>Authorization</code> or custom header.</p>
      <pre><code>webClient.get()
    .uri(&quot;http://example.com/api/users&quot;)
    .header(&quot;Api-Key&quot;, &quot;your-api-key&quot;)
    .retrieve()
    .bodyToMono(User.class)
    .subscribe(user -&gt; System.out.println(user));</code></pre>
    </div>
</div>
<div class="style2"> <b>Q70: How do you log requests and responses in WebClient?</b>
    <div class="answer">
      <p>You can log requests and responses in WebClient by using <code>filter()</code> to capture the details of the request and response.</p>
      <pre><code>WebClient webClient = WebClient.builder()
    .filter((request, next) -&gt; {
        System.out.println(&quot;Request: &quot; + request);
        return next.exchange(request).doOnTerminate(() -&gt; System.out.println(&quot;Response: &quot; + request));
    })
    .baseUrl(&quot;http://example.com&quot;)
    .build();</code></pre>
    </div>
</div>
<p class="style1">&nbsp;</p>
<h1 class="style1">Set 8 - Service-to-Service Communication (Feign, RestTemplate, WebClient)</h1>
<div class="style2"> <b>Q71: How do you configure a WebClient instance to handle a custom error response?</b>
    <div class="answer">
      <p>You can configure a WebClient instance to handle custom error responses by using the <code>onStatus()</code> method to check for the status and then handle the error.</p>
      <pre><code>WebClient webClient = WebClient.create(&quot;http://example.com&quot;);
webClient.get()
    .uri(&quot;/users&quot;)
    .retrieve()
    .onStatus(HttpStatus::is4xxClientError, response -&gt; Mono.error(new CustomClientException(&quot;Client Error&quot;)))
    .onStatus(HttpStatus::is5xxServerError, response -&gt; Mono.error(new CustomServerException(&quot;Server Error&quot;)))
    .bodyToMono(User.class)
    .subscribe(user -&gt; System.out.println(user));</code></pre>
    </div>
</div>
<div class="style2"> <b>Q72: How do you perform a GET request with RestTemplate and handle response as a list of objects?</b>
    <div class="answer">
      <p>You can use <code>RestTemplate</code> to perform a GET request and handle the response as a list of objects using <code>ParameterizedTypeReference</code>.</p>
      <pre><code>RestTemplate restTemplate = new RestTemplate();
ResponseEntity<List<User>&gt; response = restTemplate.exchange(
    &quot;http://example.com/api/users&quot;,
    HttpMethod.GET,
    null,
    new ParameterizedTypeReference<List<User>&gt;() {}
);
List<User> users = response.getBody();</code></pre>
    </div>
</div>
<div class="style2"> <b>Q73: How do you handle multipart file uploads with RestTemplate?</b>
    <div class="answer">
      <p>You can handle multipart file uploads with RestTemplate by creating a <code>MultipartBodyBuilder</code> and sending the request as a <code>multipart/form-data</code> request.</p>
      <pre><code>MultipartBodyBuilder builder = new MultipartBodyBuilder();
builder.part(&quot;file&quot;, new FileSystemResource(&quot;path/to/file&quot;));
builder.part(&quot;metadata&quot;, &quot;Some metadata&quot;);

RestTemplate restTemplate = new RestTemplate();
HttpEntity&gt; entity = new HttpEntity&lt;&gt;(builder.build());
ResponseEntity&gt; entity = new HttpEntity&lt;&gt;(builder.build());
ResponseEntity&gt; entity = new HttpEntity&lt;&gt;(builder.build());
ResponseEntity&gt; entity = new HttpEntity&lt;&gt;(builder.build());
ResponseEntity<MultiValueMap<String, Object>&gt; entity = new HttpEntity&lt;&gt;(builder.build());
ResponseEntity<String> response = restTemplate.exchange(
    &quot;http://example.com/upload&quot;,
    HttpMethod.POST,
    entity,
    String.class
);</code></pre>
    </div>
</div>
<div class="style2"> <b>Q74: How do you configure Feign to use a custom encoder for the request body?</b>
    <div class="answer">
      <p>To configure Feign to use a custom encoder, you can provide a <code>Encoder</code> bean in the Feign configuration.</p>
      <pre><code>@Configuration
public class FeignConfig {
    @Bean
    public Encoder feignEncoder() {
        return new JacksonEncoder();
    }
}

@FeignClient(name = &quot;user-service&quot;, configuration = FeignConfig.class)
public interface UserClient {
    @PostMapping(&quot;/users&quot;)
    User createUser(@RequestBody User user);
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q75: How do you make a GET request with WebClient and extract a custom header value from the response?</b>
    <div class="answer">
      <p>You can extract custom header values from the response in WebClient by using the <code>headers()</code> method to access the response headers.</p>
      <pre><code>webClient.get()
    .uri(&quot;http://example.com/api/users&quot;)
    .retrieve()
    .toEntity(User.class)
    .doOnSuccess(response -&gt; {
        String customHeader = response.getHeaders().getFirst(&quot;X-Custom-Header&quot;);
        System.out.println(&quot;Custom Header: &quot; + customHeader);
    })
    .subscribe(user -&gt; System.out.println(user));</code></pre>
    </div>
</div>
<div class="style2"> <b>Q76: How do you send a PUT request using Feign?</b>
    <div class="answer">
      <p>To send a PUT request using Feign, you use the <code>@PutMapping</code> annotation on the method, passing the request body as a parameter.</p>
      <pre><code>@FeignClient(&quot;user-service&quot;)
public interface UserClient {
    @PutMapping(&quot;/users/{id}&quot;)
    User updateUser(@PathVariable(&quot;id&quot;) String id, @RequestBody User user);
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q77: How do you set up a WebClient instance to follow redirects?</b>
    <div class="answer">
      <p>You can configure WebClient to follow redirects by setting the <code>followRedirects()</code> method in the WebClient builder.</p>
      <pre><code>WebClient webClient = WebClient.builder()
    .baseUrl(&quot;http://example.com&quot;)
    .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
    .filter((request, next) -&gt; next.exchange(request))
    .build();</code></pre>
    </div>
</div>
<div class="style2"> <b>Q78: How do you handle API rate limiting in WebClient?</b>
    <div class="answer">
      <p>To handle API rate limiting in WebClient, you can use <code>retryWhen()</code> to add retries with delays or use a custom filter to intercept rate-limiting responses.</p>
      <pre><code>webClient.get()
    .uri(&quot;http://example.com/api/endpoint&quot;)
    .retrieve()
    .onStatus(HttpStatus.TOO_MANY_REQUESTS::equals, response -&gt; Mono.error(new RateLimitExceededException(&quot;Rate limit exceeded&quot;)))
    .bodyToMono(String.class)
    .retryWhen(Retry.fixedDelay(3, Duration.ofSeconds(2)))
    .subscribe(response -&gt; System.out.println(response));</code></pre>
    </div>
</div>
<div class="style2"> <b>Q79: How do you use a custom decoder in Feign for response bodies?</b>
    <div class="answer">
      <p>To use a custom decoder in Feign, you can create a <code>Decoder</code> bean and provide it in the Feign configuration.</p>
      <pre><code>@Configuration
public class FeignConfig {
    @Bean
    public Decoder feignDecoder() {
        return new CustomDecoder();
    }
}

@FeignClient(name = &quot;user-service&quot;, configuration = FeignConfig.class)
public interface UserClient {
    @GetMapping(&quot;/users/{id}&quot;)
    User getUser(@PathVariable(&quot;id&quot;) String id);
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q80: How do you configure WebClient to handle retries?</b>
    <div class="answer">
      <p>You can configure WebClient to handle retries by using the <code>retryWhen()</code> method in the request pipeline.</p>
      <pre><code>webClient.get()
    .uri(&quot;http://example.com/api/resource&quot;)
    .retrieve()
    .bodyToMono(String.class)
    .retryWhen(Retry.backoff(3, Duration.ofSeconds(2)))
    .subscribe(response -&gt; System.out.println(response));</code></pre>
    </div>
</div>
<p class="style1">&nbsp;</p>
<h1 class="style1">Set 9 - Service-to-Service Communication (Feign, RestTemplate, WebClient)</h1>
<div class="style2"> <b>Q81: How do you configure a custom retry mechanism for Feign client?</b>
    <div class="answer">
      <p>You can configure a custom retry mechanism for Feign by defining a <code>Retryer</code> bean in the Feign configuration.</p>
      <pre><code>@Configuration
public class FeignConfig {
    @Bean
    public Retryer feignRetryer() {
        return new Retryer.Default(100, TimeUnit.MILLISECONDS.toMillis(1), 3);
    }
}

@FeignClient(name = &quot;user-service&quot;, configuration = FeignConfig.class)
public interface UserClient {
    @GetMapping(&quot;/users/{id}&quot;)
    User getUser(@PathVariable(&quot;id&quot;) String id);
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q82: How do you perform a POST request with RestTemplate and handle the response body?</b>
    <div class="answer">
      <p>You can perform a POST request using RestTemplate and handle the response body by passing the entity to the <code>exchange()</code> method.</p>
      <pre><code>RestTemplate restTemplate = new RestTemplate();
HttpHeaders headers = new HttpHeaders();
headers.setContentType(MediaType.APPLICATION_JSON);
HttpEntity<User> entity = new HttpEntity&lt;&gt;(new User(&quot;John&quot;, &quot;Doe&quot;), headers);

ResponseEntity<User> response = restTemplate.exchange(
    &quot;http://example.com/api/users&quot;,
    HttpMethod.POST,
    entity,
    User.class
);
User createdUser = response.getBody();</code></pre>
    </div>
</div>
<div class="style2"> <b>Q83: How do you set the timeout values for WebClient?</b>
    <div class="answer">
      <p>You can set the timeout values for WebClient using the <code>baseUrl</code> method and applying a custom <code>exchangeStrategies()</code>.</p>
      <pre><code>WebClient webClient = WebClient.builder()
    .baseUrl(&quot;http://example.com&quot;)
    .clientConnector(new ReactorClientHttpConnector(
        HttpClient.create().responseTimeout(Duration.ofSeconds(10))
    ))
    .build();</code></pre>
    </div>
</div>
<div class="style2"> <b>Q84: How can you handle invalid responses (4xx, 5xx) in WebClient?</b>
    <div class="answer">
      <p>You can handle invalid responses by using the <code>onStatus()</code> method to inspect the HTTP status code and perform custom error handling.</p>
      <pre><code>WebClient webClient = WebClient.create(&quot;http://example.com&quot;);
webClient.get()
    .uri(&quot;/api/users&quot;)
    .retrieve()
    .onStatus(HttpStatus::is4xxClientError, response -&gt; Mono.error(new CustomClientException(&quot;Client Error&quot;)))
    .onStatus(HttpStatus::is5xxServerError, response -&gt; Mono.error(new CustomServerException(&quot;Server Error&quot;)))
    .bodyToMono(User.class)
    .subscribe(user -&gt; System.out.println(user));</code></pre>
    </div>
</div>
<div class="style2"> <b>Q85: How do you authenticate using OAuth2 with WebClient?</b>
    <div class="answer">
      <p>You can authenticate using OAuth2 by setting the <code>OAuth2AuthorizedClientManager</code> in WebClient.</p>
      <pre><code>OAuth2AuthorizedClientManager authorizedClientManager = 
    new OAuth2AuthorizedClientManager(clientRegistrationRepository, authorizedClientRepository);
WebClient webClient = WebClient.builder()
    .baseUrl(&quot;http://example.com&quot;)
    .defaultHeader(HttpHeaders.AUTHORIZATION, &quot;Bearer &quot; + accessToken)
    .build();</code></pre>
    </div>
</div>
<div class="style2"> <b>Q86: How do you perform a PUT request with WebClient?</b>
    <div class="answer">
      <p>You can perform a PUT request with WebClient by using the <code>put()</code> method and passing the request body.</p>
      <pre><code>WebClient webClient = WebClient.create(&quot;http://example.com&quot;);
webClient.put()
    .uri(&quot;/api/users/{id}&quot;, 1)
    .bodyValue(new User(&quot;Jane&quot;, &quot;Doe&quot;))
    .retrieve()
    .bodyToMono(Void.class)
    .subscribe();</code></pre>
    </div>
</div>
<div class="style2"> <b>Q87: How do you set up Feign with a custom error decoder?</b>
    <div class="answer">
      <p>You can set up Feign with a custom error decoder by creating a bean of type <code>ErrorDecoder</code> in the configuration.</p>
      <pre><code>@Configuration
public class FeignConfig {
    @Bean
    public ErrorDecoder errorDecoder() {
        return new CustomErrorDecoder();
    }
}

@FeignClient(name = &quot;user-service&quot;, configuration = FeignConfig.class)
public interface UserClient {
    @GetMapping(&quot;/users/{id}&quot;)
    User getUser(@PathVariable(&quot;id&quot;) String id);
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q88: How do you handle cookies in a WebClient request?</b>
    <div class="answer">
      <p>You can handle cookies in WebClient by accessing them from the <code>CookieHandler</code> or by using a custom filter.</p>
      <pre><code>WebClient webClient = WebClient.builder()
    .clientConnector(new ReactorClientHttpConnector(HttpClient.create().cookieHandler(new CookieManager())))
    .build();</code></pre>
    </div>
</div>
<div class="style2"> <b>Q89: How do you perform an asynchronous request using RestTemplate?</b>
    <div class="answer">
      <p>RestTemplate is blocking by default, but you can perform asynchronous requests using <code>AsyncRestTemplate</code>.</p>
      <pre><code>AsyncRestTemplate asyncRestTemplate = new AsyncRestTemplate();
ListenableFuture<ResponseEntity<User>&gt; future = asyncRestTemplate.exchange(
    &quot;http://example.com/api/users&quot;,
    HttpMethod.GET,
    null,
    User.class
);
future.addCallback(result -&gt; System.out.println(result.getBody()), ex -&gt; ex.printStackTrace());</code></pre>
    </div>
</div>
<div class="style2"> <b>Q90: How do you create a Feign client with basic authentication?</b>
    <div class="answer">
      <p>You can create a Feign client with basic authentication by using <code>RequestInterceptor</code> to add an authorization header.</p>
      <pre><code>@Configuration
public class FeignConfig {
    @Bean
    public RequestInterceptor requestInterceptor() {
        return requestTemplate -&gt; requestTemplate.header(HttpHeaders.AUTHORIZATION, &quot;Basic &quot; + encodedCredentials);
    }
}

@FeignClient(name = &quot;user-service&quot;, configuration = FeignConfig.class)
public interface UserClient {
    @GetMapping(&quot;/users/{id}&quot;)
    User getUser(@PathVariable(&quot;id&quot;) String id);
}</code></pre>
    </div>
</div>
<h1 class="style1">Set 10 - Service-to-Service Communication (Feign, RestTemplate, WebClient)</h1>
<div class="style2"> <b>Q91: How can you define timeouts for Feign clients?</b>
    <div class="answer">
      <p>You can define timeouts for Feign clients by configuring <code>okhttp3</code> with custom timeouts.</p>
      <pre><code>@Configuration
public class FeignConfig {
    @Bean
    public OkHttpClient okHttpClient() {
        return new OkHttpClient.Builder()
                .connectTimeout(5, TimeUnit.SECONDS)
                .readTimeout(10, TimeUnit.SECONDS)
                .build();
    }
}

@FeignClient(name = &quot;user-service&quot;, configuration = FeignConfig.class)
public interface UserClient {
    @GetMapping(&quot;/users/{id}&quot;)
    User getUser(@PathVariable(&quot;id&quot;) String id);
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q92: How do you use WebClient with a custom exchange filter function?</b>
    <div class="answer">
      <p>You can add a custom filter to WebClient using the <code>filter()</code> method to modify the request and response.</p>
      <pre><code>WebClient webClient = WebClient.builder()
    .filter((request, next) -&gt; {
        System.out.println(&quot;Request URI: &quot; + request.uri());
        return next.exchange(request);
    })
    .baseUrl(&quot;http://example.com&quot;)
    .build();</code></pre>
    </div>
</div>
<div class="style2"> <b>Q93: How do you create a fallback mechanism in Feign?</b>
    <div class="answer">
      <p>You can create a fallback mechanism in Feign by using the <code>fallback</code> attribute in the Feign client declaration.</p>
      <pre><code>@FeignClient(name = &quot;user-service&quot;, fallback = UserClientFallback.class)
public interface UserClient {
    @GetMapping(&quot;/users/{id}&quot;)
    User getUser(@PathVariable(&quot;id&quot;) String id);
}

@Component
public class UserClientFallback implements UserClient {
    @Override
    public User getUser(String id) {
        return new User(&quot;Fallback&quot;, &quot;User&quot;);
    }
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q94: How can you add headers to every WebClient request?</b>
    <div class="answer">
      <p>You can add headers to every WebClient request by using the <code>defaultHeader()</code> method.</p>
      <pre><code>WebClient webClient = WebClient.builder()
    .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
    .baseUrl(&quot;http://example.com&quot;)
    .build();
webClient.get()
    .uri(&quot;/api/users&quot;)
    .retrieve()
    .bodyToMono(User.class)
    .subscribe();</code></pre>
    </div>
</div>
<div class="style2"> <b>Q95: How do you implement service discovery with Feign and Spring Cloud?</b>
    <div class="answer">
      <p>You can implement service discovery with Feign and Spring Cloud by using <code>@EnableFeignClients</code> and <code>@EnableDiscoveryClient</code> annotations, and setting up an application that integrates with Eureka or Consul.</p>
      <pre><code>@SpringBootApplication
@EnableFeignClients
@EnableDiscoveryClient
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}

@FeignClient(name = &quot;user-service&quot;)
public interface UserClient {
    @GetMapping(&quot;/users/{id}&quot;)
    User getUser(@PathVariable(&quot;id&quot;) String id);
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q96: How do you handle retries with WebClient?</b>
    <div class="answer">
      <p>You can handle retries with WebClient by using the <code>retry</code> operator from Project Reactor.</p>
      <pre><code>webClient.get()
    .uri(&quot;/api/users&quot;)
    .retrieve()
    .bodyToMono(User.class)
    .retry(3)  // Retries 3 times before failing
    .subscribe(user -&gt; System.out.println(user));</code></pre>
    </div>
</div>
<div class="style2"> <b>Q97: How do you log request and response details in WebClient?</b>
    <div class="answer">
      <p>You can log request and response details in WebClient by using the <code>exchangeStrategies()</code> method or by adding a custom logging filter.</p>
      <pre><code>WebClient webClient = WebClient.builder()
    .filter((request, next) -&gt; {
        System.out.println(&quot;Request URI: &quot; + request.uri());
        return next.exchange(request).doOnTerminate(() -&gt; System.out.println(&quot;Request completed&quot;));
    })
    .baseUrl(&quot;http://example.com&quot;)
    .build();</code></pre>
    </div>
</div>
<div class="style2"> <b>Q98: How can you implement OAuth2 token management in Feign?</b>
    <div class="answer">
      <p>You can implement OAuth2 token management in Feign by using <code>RequestInterceptor</code> to attach the token to every request.</p>
      <pre><code>@Configuration
public class FeignConfig {
    @Bean
    public RequestInterceptor oauthRequestInterceptor() {
        return requestTemplate -&gt; requestTemplate.header(HttpHeaders.AUTHORIZATION, &quot;Bearer &quot; + getOAuth2Token());
    }
}

@FeignClient(name = &quot;user-service&quot;, configuration = FeignConfig.class)
public interface UserClient {
    @GetMapping(&quot;/users/{id}&quot;)
    User getUser(@PathVariable(&quot;id&quot;) String id);
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q99: How do you validate input data before making a REST request using Feign?</b>
    <div class="answer">
      <p>You can validate input data by using custom logic or annotations before making a request with Feign.</p>
      <pre><code>@FeignClient(name = &quot;user-service&quot;)
public interface UserClient {
    @PostMapping(&quot;/users&quot;)
    void createUser(@Valid @RequestBody User user);
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q100: How do you configure a timeout for RestTemplate?</b>
    <div class="answer">
      <p>You can configure a timeout for RestTemplate by using a <code>SimpleClientHttpRequestFactory</code> with custom timeouts.</p>
      <pre><code>int timeout = 5000;
SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();
factory.setConnectTimeout(timeout);
factory.setReadTimeout(timeout);
RestTemplate restTemplate = new RestTemplate(factory);</code></pre>
    </div>
</div>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
</body>
</html>
