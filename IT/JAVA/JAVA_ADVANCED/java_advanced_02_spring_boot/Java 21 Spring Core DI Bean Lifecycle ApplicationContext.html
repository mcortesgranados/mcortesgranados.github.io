<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Untitled Document</title>
<style type="text/css">
<!--
.question {            margin-bottom: 20px;
}
-->
</style>
</head>

<body>	
<h2>Spring Core (DI, Bean Lifecycle, ApplicationContext) - Set 1</h2>
<div class="question">
  <h3>1. What is Dependency Injection (DI) in Spring?</h3>
  <p><strong>Answer:</strong> Dependency Injection is a design pattern used to implement Inversion of Control (IoC) in Spring. It allows Spring to manage the creation and injection of dependent objects into a class, which promotes loose coupling and enhances testability. DI can be performed through constructor injection, setter injection, or field injection.</p>
</div>
<div class="question">
  <h3>2. What are the types of Dependency Injection in Spring?</h3>
  <p><strong>Answer:</strong> Spring supports three types of Dependency Injection: </p>
  <ul>
    <li><strong>Constructor Injection:</strong> Dependencies are provided through the constructor of the class.</li>
    <li><strong>Setter Injection:</strong> Dependencies are provided through setter methods of the class.</li>
    <li><strong>Field Injection:</strong> Dependencies are injected directly into fields using annotations like <code>@Autowired</code>.</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>3. What is the purpose of the <code>@Autowired</code> annotation in Spring?</h3>
  <p><strong>Answer:</strong> The <code>@Autowired</code> annotation is used to automatically wire beans in Spring. It allows Spring to resolve and inject collaborating beans into the bean that requires them, eliminating the need for explicit configuration in XML or Java-based configuration.</p>
</div>
<div class="question">
  <h3>4. What is the difference between <code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, and <code>@Controller</code> annotations in Spring?</h3>
  <p><strong>Answer:</strong> These annotations are all specializations of <code>@Component</code> in Spring, which are used to mark a class as a Spring bean: </p>
  <ul>
    <li><strong>@Component:</strong> A generic stereotype for any Spring-managed component.</li>
    <li><strong>@Service:</strong> Used for service-layer beans, typically business service logic.</li>
    <li><strong>@Repository:</strong> Used for Data Access Object (DAO) beans, typically dealing with database operations.</li>
    <li><strong>@Controller:</strong> Used for Spring MVC controller beans, handling HTTP requests in web applications.</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>5. What is the role of <code>ApplicationContext</code> in Spring?</h3>
  <p><strong>Answer:</strong> The <code>ApplicationContext</code> is the central interface to the Spring IoC container. It provides the necessary functionality for bean management, including creation, configuration, and lifecycle management. It also supports event propagation, declarative mechanisms, and various types of bean scopes (singleton, prototype, etc.). The <code>ApplicationContext</code> is a more feature-rich version of <code>BeanFactory</code>.</p>
</div>
<div class="question">
  <h3>6. What are the different types of <code>ApplicationContext</code> in Spring?</h3>
  <p><strong>Answer:</strong> The main types of <code>ApplicationContext</code> are: </p>
  <ul>
    <li><strong>ClassPathXmlApplicationContext:</strong> Loads Spring beans from an XML configuration file.</li>
    <li><strong>AnnotationConfigApplicationContext:</strong> Loads Spring beans from annotated classes (Java-based configuration).</li>
    <li><strong>GenericWebApplicationContext:</strong> A generic context for web applications, supporting annotation-based configuration.</li>
    <li><strong>GenericApplicationContext:</strong> A general-purpose <code>ApplicationContext</code> with support for annotation-based configuration.</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>7. What is the bean lifecycle in Spring?</h3>
  <p><strong>Answer:</strong> The Spring bean lifecycle follows several stages: </p>
  <ol>
    <li>Instantiation: The bean is created.</li>
    <li>Populate properties: Spring injects dependencies into the bean.</li>
    <li>Set Bean Name: The bean's name is set if it implements <code>BeanNameAware</code>.</li>
    <li>Set Bean Factory: The bean factory is provided if the bean implements <code>BeanFactoryAware</code>.</li>
    <li>Pre-initialization: If a <code>BeanPostProcessor</code> is defined, it can modify the bean before initialization.</li>
    <li>Initialization: If a <code>init-method</code> is configured, it will be called.</li>
    <li>Post-initialization: If a <code>BeanPostProcessor</code> is defined, it can modify the bean after initialization.</li>
    <li>Destruction: If the bean implements <code>DisposableBean</code>, the <code>destroy()</code> method is called when the context is closed.</li>
  </ol>
  </p>
</div>
<div class="question">
  <h3>8. What are BeanPostProcessors in Spring?</h3>
  <p><strong>Answer:</strong> <code>BeanPostProcessor</code> is an interface in Spring that allows custom modification of new bean instances, such as applying specific logic before or after the bean’s initialization. The <code>postProcessBeforeInitialization</code> and <code>postProcessAfterInitialization</code> methods are called during the bean lifecycle.</p>
</div>
<div class="question">
  <h3>9. What is the difference between <code>BeanFactory</code> and <code>ApplicationContext</code>?</h3>
  <p><strong>Answer:</strong> <code>BeanFactory</code> is the simplest container in Spring and is responsible for managing beans. However, it lacks many advanced features such as event propagation and AOP support. <code>ApplicationContext</code> extends <code>BeanFactory</code> and provides additional features, including message resource handling, event propagation, and automatic bean initialization for specific roles like web applications.</p>
</div>
<div class="question">
  <h3>10. What is the use of the <code>@PostConstruct</code> annotation in Spring?</h3>
  <p><strong>Answer:</strong> The <code>@PostConstruct</code> annotation is used to mark a method that should be executed after the bean’s dependencies have been injected and before the bean is used. It is typically used for any initialization logic that must occur after the bean has been created and its properties set.</p>
</div>
<p>&nbsp;</p>
<h2>Spring Core (DI, Bean Lifecycle, ApplicationContext) - Set 2</h2>
<div class="question">
  <h3>1. What is the difference between <code>@Autowired</code> and <code>@Inject</code> annotations?</h3>
  <p><strong>Answer:</strong> Both <code>@Autowired</code> and <code>@Inject</code> are used for dependency injection, but: </p>
  <ul>
    <li><code>@Autowired</code> is a Spring-specific annotation, while <code>@Inject</code> is part of the Java dependency injection specification (JSR-330).</li>
    <li><code>@Autowired</code> provides more features such as specifying required/optional dependencies using <code>required</code> attribute.</li>
    <li><code>@Inject</code> behaves similarly to <code>@Autowired</code> but is more portable across other DI frameworks.</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>2. What is the significance of the <code>@Bean</code> annotation in Spring?</h3>
  <p><strong>Answer:</strong> The <code>@Bean</code> annotation is used in Java-based configuration classes to declare a bean. It is used to explicitly define a bean in the <code>ApplicationContext</code>, allowing Spring to manage it. It is often used for third-party library beans or more complex bean definitions that cannot be represented using <code>@Component</code>.</p>
</div>
<div class="question">
  <h3>3. What is the difference between singleton and prototype scopes in Spring?</h3>
  <p><strong>Answer:</strong> The scope of a Spring bean defines its lifecycle within the container. The two most common scopes are: </p>
  <ul>
    <li><strong>Singleton:</strong> A bean is created once and shared throughout the Spring container. It is the default scope in Spring.</li>
    <li><strong>Prototype:</strong> A new instance of the bean is created every time it is requested from the container.</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>4. What is the use of <code>@Qualifier</code> annotation in Spring?</h3>
  <p><strong>Answer:</strong> The <code>@Qualifier</code> annotation is used to resolve ambiguity when multiple beans of the same type exist in the Spring container. It is used along with <code>@Autowired</code> to specify which bean to inject when there are multiple candidates.</p>
</div>
<div class="question">
  <h3>5. What is the <code>BeanFactory</code> in Spring?</h3>
  <p><strong>Answer:</strong> <code>BeanFactory</code> is the simplest container in Spring that manages beans. It is responsible for the creation and lifecycle of beans, but it lacks many advanced features such as event propagation and automatic configuration. It is generally used in non-web applications where the full features of <code>ApplicationContext</code> are not required.</p>
</div>
<div class="question">
  <h3>6. What is <code>BeanFactoryAware</code> and <code>ApplicationContextAware</code> interfaces in Spring?</h3>
  <p><strong>Answer:</strong> The <code>BeanFactoryAware</code> and <code>ApplicationContextAware</code> interfaces allow a bean to be aware of the <code>BeanFactory</code> or <code>ApplicationContext</code> that created it. These interfaces provide the <code>setBeanFactory()</code> and <code>setApplicationContext()</code> methods to access the factory and context objects, respectively.</p>
</div>
<div class="question">
  <h3>7. What is the role of <code>@Scope</code> annotation in Spring?</h3>
  <p><strong>Answer:</strong> The <code>@Scope</code> annotation is used to specify the scope of a bean. Common scopes include: </p>
  <ul>
    <li><strong>singleton:</strong> The bean is created once and shared.</li>
    <li><strong>prototype:</strong> A new instance is created for each request.</li>
    <li><strong>request:</strong> A new bean is created for each HTTP request (used in web applications).</li>
    <li><strong>session:</strong> A new bean is created for each HTTP session (used in web applications).</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>8. How does Spring handle circular dependencies?</h3>
  <p><strong>Answer:</strong> Spring can handle circular dependencies when beans depend on each other. This can be resolved in two ways: </p>
  <ul>
    <li>By using setter injection (Spring can inject the dependency later in the bean lifecycle).</li>
    <li>By using <code>@Lazy</code> annotation, which delays the initialization of a bean until it is needed.</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>9. What is the <code>PostConstruct</code> annotation used for?</h3>
  <p><strong>Answer:</strong> The <code>@PostConstruct</code> annotation is used to mark a method that should be executed after the bean’s properties have been injected. It is typically used for initialization logic that requires the bean to be fully configured.</p>
</div>
<div class="question">
  <h3>10. What is the difference between <code>BeanPostProcessor</code> and <code>InitializingBean</code>?</h3>
  <p><strong>Answer:</strong> Both <code>BeanPostProcessor</code> and <code>InitializingBean</code> are used to modify beans during their initialization: </p>
  <ul>
    <li><strong>BeanPostProcessor:</strong> It provides methods to modify a bean before and after its initialization (e.g., <code>postProcessBeforeInitialization()</code> and <code>postProcessAfterInitialization()</code>).</li>
    <li><strong>InitializingBean:</strong> It is an interface that provides a single <code>afterPropertiesSet()</code> method, which is called after the bean’s properties have been set but before the bean is used.</li>
  </ul>
  </p>
</div>
<p>&nbsp;</p>
<h2>Spring Core (DI, Bean Lifecycle, ApplicationContext) - Set 3</h2>
<div class="question">
  <h3>1. What are the different types of autowiring modes in Spring?</h3>
  <p><strong>Answer:</strong> There are four autowiring modes in Spring: </p>
  <ul>
    <li><strong>No Autowiring:</strong> No autowiring is performed, and dependencies must be explicitly specified.</li>
    <li><strong>Autowire by Type (<code>autowire=&quot;byType&quot;</code>):</strong> Spring injects a bean based on its type.</li>
    <li><strong>Autowire by Name (<code>autowire=&quot;byName&quot;</code>):</strong> Spring injects a bean based on the name of the property.</li>
    <li><strong>Autowire by Constructor (<code>autowire=&quot;constructor&quot;</code>):</strong> Spring injects the bean using the constructor argument types.</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>2. How can you configure the lifecycle of a bean in Spring?</h3>
  <p><strong>Answer:</strong> The lifecycle of a bean in Spring can be configured using the following: </p>
  <ul>
    <li><strong>Initialization:</strong> Use the <code>@PostConstruct</code> annotation or the <code>afterPropertiesSet()</code> method from the <code>InitializingBean</code> interface to perform initialization logic.</li>
    <li><strong>Destruction:</strong> Use the <code>@PreDestroy</code> annotation or the <code>destroy()</code> method from the <code>DisposableBean</code> interface to clean up resources.</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>3. What are the advantages of using <code>ApplicationContext</code> over <code>BeanFactory</code>?</h3>
  <p><strong>Answer:</strong> The <code>ApplicationContext</code> interface extends <code>BeanFactory</code> and provides additional functionality such as: </p>
  <ul>
    <li>Event propagation, which allows beans to listen to events in the application.</li>
    <li>Internationalization support, which allows beans to handle localized messages.</li>
    <li>Automatic bean scanning and configuration, which simplifies the setup of Spring beans in the application.</li>
    <li>Support for multiple types of resources (e.g., file, classpath).</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>4. What is the purpose of the <code>@Lazy</code> annotation in Spring?</h3>
  <p><strong>Answer:</strong> The <code>@Lazy</code> annotation is used to indicate that the bean should be created lazily, meaning that it will only be instantiated when it is first needed (i.e., when it is requested from the container). This is useful for improving application startup time by delaying the initialization of beans that are not immediately needed.</p>
</div>
<div class="question">
  <h3>5. What is the role of <code>ApplicationContextInitializer</code>?</h3>
  <p><strong>Answer:</strong> <code>ApplicationContextInitializer</code> is used to configure the <code>ApplicationContext</code> before it is refreshed. It provides a callback mechanism for customizing the context during the startup phase, such as setting properties or environment variables. This interface is typically used in Spring Boot applications.</p>
</div>
<div class="question">
  <h3>6. What is the <code>BeanDefinition</code> in Spring?</h3>
  <p><strong>Answer:</strong> A <code>BeanDefinition</code> is an object that describes a Spring bean in terms of its properties, initialization methods, destruction methods, and other metadata. It provides the necessary information for Spring to create and manage a bean, including its scope, dependencies, and lifecycle.</p>
</div>
<div class="question">
  <h3>7. Can a Spring bean have multiple constructors? How does Spring handle it?</h3>
  <p><strong>Answer:</strong> Yes, a Spring bean can have multiple constructors. If a bean has more than one constructor, Spring will use the constructor that matches the bean’s dependency requirements. If you want to specify which constructor Spring should use, you can use the <code>@Autowired</code> annotation on the constructor, or you can configure it explicitly in the Spring configuration.</p>
</div>
<div class="question">
  <h3>8. What is the difference between <code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, and <code>@Controller</code> in Spring?</h3>
  <p><strong>Answer:</strong> These annotations are used to declare different types of Spring beans: </p>
  <ul>
    <li><code>@Component</code>: A generic stereotype for any Spring-managed bean.</li>
    <li><code>@Service</code>: A specialization of <code>@Component</code>, used to indicate that the bean is a service in the service layer.</li>
    <li><code>@Repository</code>: A specialization of <code>@Component</code>, used to indicate that the bean is a repository in the persistence layer.</li>
    <li><code>@Controller</code>: A specialization of <code>@Component</code>, used to indicate that the bean is a controller in the web layer (used in MVC).</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>9. What is the difference between <code>ApplicationContext</code> and <code>WebApplicationContext</code>?</h3>
  <p><strong>Answer:</strong> <code>ApplicationContext</code> is the central interface for accessing beans and managing their lifecycle in Spring. <code>WebApplicationContext</code> is a specialized version of <code>ApplicationContext</code> that is used for web applications. It is typically used when Spring is running in a servlet container, such as Tomcat, and provides additional functionality related to web-specific resources (e.g., request and session attributes).</p>
</div>
<div class="question">
  <h3>10. How can you inject a bean using constructor-based injection in Spring?</h3>
  <p><strong>Answer:</strong> Constructor-based injection is performed by declaring a constructor in the class with the required dependencies as arguments. Spring will automatically match the constructor arguments with the available beans in the container based on their types. You can use the <code>@Autowired</code> annotation to indicate constructor-based injection, or Spring will perform the injection automatically if there is only one constructor.</p>
</div>
<p>&nbsp;</p>
<h2>Spring Core (DI, Bean Lifecycle, ApplicationContext) - Set 4</h2>
<div class="question">
  <h3>1. What is the difference between singleton and prototype bean scopes in Spring?</h3>
  <p><strong>Answer:</strong> </p>
  <ul>
    <li><strong>Singleton:</strong> The bean is created only once during the lifecycle of the application context. It is shared across all requests, making it the default scope in Spring.</li>
    <li><strong>Prototype:</strong> A new instance of the bean is created each time it is requested from the Spring container.</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>2. How can you make sure that a Spring bean is created only once in a Spring container?</h3>
  <p><strong>Answer:</strong> To ensure that a Spring bean is created only once, you can use the singleton scope, which is the default in Spring. This ensures that the same instance of the bean is shared across the entire application context. You can explicitly specify this using the <code>@Scope(&quot;singleton&quot;)</code> annotation.</p>
</div>
<div class="question">
  <h3>3. What is the purpose of <code>@Autowired</code> annotation?</h3>
  <p><strong>Answer:</strong> The <code>@Autowired</code> annotation is used for automatic dependency injection in Spring. It tells Spring to resolve and inject the appropriate bean into a property, constructor, or method. Spring will try to autowire by type by default, but you can change it to autowire by name or qualifier if needed.</p>
</div>
<div class="question">
  <h3>4. What are the different types of dependency injection supported by Spring?</h3>
  <p><strong>Answer:</strong> Spring supports three types of dependency injection: </p>
  <ul>
    <li><strong>Constructor Injection:</strong> Dependencies are provided through the constructor of the bean.</li>
    <li><strong>Setter Injection:</strong> Dependencies are provided through setter methods after the bean is instantiated.</li>
    <li><strong>Field Injection:</strong> Dependencies are injected directly into fields using the <code>@Autowired</code> annotation.</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>5. What is the difference between the <code>@Component</code> annotation and <code>@Configuration</code> annotation?</h3>
  <p><strong>Answer:</strong> </p>
  <ul>
    <li><code>@Component</code>: Marks a class as a Spring-managed bean. It is a generic annotation that can be used for any type of bean.</li>
    <li><code>@Configuration</code>: Marks a class as a configuration class that may contain <code>@Bean</code> methods. It is a specialization of <code>@Component</code> and indicates that the class provides bean definitions for the Spring container.</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>6. What is the <code>BeanFactory</code> in Spring?</h3>
  <p><strong>Answer:</strong> The <code>BeanFactory</code> is the simplest container in Spring and is used for loading beans lazily. It creates beans only when they are needed. The <code>ApplicationContext</code> extends the <code>BeanFactory</code> interface and adds additional features like event handling, internationalization, and other advanced capabilities.</p>
</div>
<div class="question">
  <h3>7. How can you make Spring beans lifecycle management more customizable?</h3>
  <p><strong>Answer:</strong> You can customize the lifecycle of Spring beans using: </p>
  <ul>
    <li><strong>InitializingBean interface:</strong> Override <code>afterPropertiesSet()</code> to provide custom initialization logic.</li>
    <li><strong>DisposableBean interface:</strong> Override <code>destroy()</code> to provide custom destruction logic.</li>
    <li><strong>Custom init and destroy methods:</strong> Specify custom init and destroy methods using the <code>@Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;destroy&quot;)</code> annotation or XML configuration.</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>8. What is the purpose of <code>ApplicationContext</code> in Spring?</h3>
  <p><strong>Answer:</strong> <code>ApplicationContext</code> is the central interface for providing configuration and retrieving beans in a Spring application. It manages the lifecycle and configuration of beans and allows for resolving dependencies, events, and other context-related tasks. It is an extension of the <code>BeanFactory</code> interface and provides additional features like internationalization, event propagation, and more.</p>
</div>
<div class="question">
  <h3>9. What is the <code>@Primary</code> annotation in Spring?</h3>
  <p><strong>Answer:</strong> The <code>@Primary</code> annotation is used to specify that a bean should be given preference when there are multiple candidates for autowiring. When multiple beans of the same type are available, the one marked with <code>@Primary</code> will be injected by default unless another bean is explicitly specified with <code>@Qualifier</code>.</p>
</div>
<div class="question">
  <h3>10. How does Spring manage circular dependencies?</h3>
  <p><strong>Answer:</strong> Spring handles circular dependencies by using proxy beans. If two beans depend on each other, Spring will create a proxy for one of the beans, allowing the circular reference to be resolved. This proxy allows Spring to inject the dependent bean while maintaining the original bean's functionality.</p>
</div>
<p>&nbsp;</p>
<h2>Spring Core (DI, Bean Lifecycle, ApplicationContext) - Set 5</h2>
<div class="question">
  <h3>1. What is a Bean Post Processor in Spring?</h3>
  <p><strong>Answer:</strong> A <code>BeanPostProcessor</code> is a Spring interface that allows for custom modification of new bean instances before and after their initialization. It provides two methods: </p>
  <ul>
    <li><code>postProcessBeforeInitialization()</code>: Called before the initialization method of the bean.</li>
    <li><code>postProcessAfterInitialization()</code>: Called after the initialization method of the bean.</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>2. What is the <code>@Value</code> annotation used for in Spring?</h3>
  <p><strong>Answer:</strong> The <code>@Value</code> annotation is used to inject values into Spring beans from properties files, environment variables, or expressions. It can be applied to fields, methods, or constructor parameters to inject configuration values or literals directly into the bean.</p>
</div>
<div class="question">
  <h3>3. What is the purpose of <code>@Scope</code> annotation in Spring?</h3>
  <p><strong>Answer:</strong> The <code>@Scope</code> annotation is used to specify the scope of a Spring bean. The most common scopes are: </p>
  <ul>
    <li><strong>singleton:</strong> A single instance of the bean is created for the entire application context.</li>
    <li><strong>prototype:</strong> A new instance of the bean is created every time it is requested.</li>
    <li><strong>request:</strong> A new bean is created for each HTTP request.</li>
    <li><strong>session:</strong> A new bean is created for each HTTP session.</li>
    <li><strong>application:</strong> A new bean is created for the entire servlet context (application scope).</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>4. What is a BeanFactory in Spring?</h3>
  <p><strong>Answer:</strong> A <code>BeanFactory</code> is a basic container that provides the fundamental features of a Spring IoC container. It is used for lazy initialization of beans, meaning beans are created only when they are required. It is the simplest container available in Spring, but it lacks features like event propagation and internationalization, which are available in <code>ApplicationContext</code>.</p>
</div>
<div class="question">
  <h3>5. How can you define a custom scope for a Spring bean?</h3>
  <p><strong>Answer:</strong> You can define a custom scope for a Spring bean by implementing the <code>Scope</code> interface and registering it in the Spring context. The custom scope class must implement methods to manage bean creation, destruction, and lifecycle handling. The custom scope can then be applied to beans using the <code>@Scope</code> annotation.</p>
</div>
<div class="question">
  <h3>6. What is the difference between <code>ApplicationContext</code> and <code>BeanFactory</code>?</h3>
  <p><strong>Answer:</strong> The <code>ApplicationContext</code> is a more feature-rich and advanced container than <code>BeanFactory</code>. It extends the <code>BeanFactory</code> interface and provides additional capabilities such as: </p>
  <ul>
    <li>Event propagation</li>
    <li>Internationalization support</li>
    <li>Annotation-based configuration</li>
    <li>Automatic bean post-processing</li>
  </ul>
  <code>BeanFactory</code> is the base interface and is suitable for simple scenarios, while <code>ApplicationContext</code> is typically used in most Spring applications.
  </p>
</div>
<div class="question">
  <h3>7. How does Spring handle bean initialization?</h3>
  <p><strong>Answer:</strong> Spring handles bean initialization in the following way: </p>
  <ul>
    <li>First, the bean is instantiated using the constructor or factory method.</li>
    <li>Then, Spring injects dependencies using dependency injection (DI).</li>
    <li>If the bean implements the <code>InitializingBean</code> interface, the <code>afterPropertiesSet()</code> method is called.</li>
    <li>If a custom init method is specified, it is invoked after <code>afterPropertiesSet()</code>.</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>8. What is a <code>@PostConstruct</code> annotation?</h3>
  <p><strong>Answer:</strong> The <code>@PostConstruct</code> annotation is used to specify a method that should be executed after the bean’s properties have been set. It is typically used for initialization tasks, similar to the <code>afterPropertiesSet()</code> method of the <code>InitializingBean</code> interface.</p>
</div>
<div class="question">
  <h3>9. What is the <code>@PreDestroy</code> annotation used for in Spring?</h3>
  <p><strong>Answer:</strong> The <code>@PreDestroy</code> annotation is used to specify a method that should be executed before a Spring bean is destroyed. This is useful for performing cleanup tasks or releasing resources before the bean is removed from the container. It is equivalent to the <code>destroy()</code> method in the <code>DisposableBean</code> interface.</p>
</div>
<div class="question">
  <h3>10. What is a <code>FactoryBean</code> in Spring?</h3>
  <p><strong>Answer:</strong> A <code>FactoryBean</code> is an interface that allows you to create beans programmatically. Instead of using the default bean instantiation process, a <code>FactoryBean</code> enables you to customize the bean creation process. The <code>getObject()</code> method is used to define the bean creation logic, and it is registered in the Spring context like any other bean.</p>
</div>
<p>&nbsp;</p>
<h2>Spring Core (DI, Bean Lifecycle, ApplicationContext) - Set 6</h2>
<div class="question">
  <h3>1. What is the role of <code>ApplicationContext</code> in Spring?</h3>
  <p><strong>Answer:</strong> <code>ApplicationContext</code> is the central interface in Spring for providing configuration and managing the lifecycle of beans. It is responsible for managing beans, handling dependency injection (DI), managing bean scopes, and providing support for events, AOP, and resource loading. It is a more advanced version of the <code>BeanFactory</code> container.</p>
</div>
<div class="question">
  <h3>2. How does Spring handle the lifecycle of beans?</h3>
  <p><strong>Answer:</strong> Spring handles the lifecycle of beans by following several stages: </p>
  <ul>
    <li>Bean Instantiation: Beans are created, either by constructor or factory method.</li>
    <li>Dependency Injection: Spring injects dependencies into the bean using DI.</li>
    <li>Bean Initialization: Methods like <code>afterPropertiesSet()</code> or methods annotated with <code>@PostConstruct</code> are invoked for initialization tasks.</li>
    <li>Bean Destruction: When the container shuts down, Spring invokes destruction methods such as <code>destroy()</code> or methods annotated with <code>@PreDestroy</code>.</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>3. What is <code>@ComponentScan</code> used for?</h3>
  <p><strong>Answer:</strong> The <code>@ComponentScan</code> annotation tells Spring to automatically discover and register beans in the application context by scanning the classpath for components (like <code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, and <code>@Controller</code> annotated classes).</p>
</div>
<div class="question">
  <h3>4. What is the difference between <code>singleton</code> and <code>prototype</code> scopes in Spring?</h3>
  <p><strong>Answer:</strong> </p>
  <ul>
    <li><strong>Singleton:</strong> A single instance of the bean is created and shared across the entire Spring container. This is the default scope.</li>
    <li><strong>Prototype:</strong> A new instance of the bean is created every time it is requested from the container.</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>5. What is the purpose of the <code>@Autowired</code> annotation?</h3>
  <p><strong>Answer:</strong> The <code>@Autowired</code> annotation is used for automatic dependency injection in Spring. It allows Spring to inject the required dependencies into a bean automatically, either by constructor, setter, or field injection.</p>
</div>
<div class="question">
  <h3>6. What are the types of dependency injection in Spring?</h3>
  <p><strong>Answer:</strong> Spring supports three types of dependency injection: </p>
  <ul>
    <li><strong>Constructor Injection:</strong> Dependencies are injected via the constructor of the bean.</li>
    <li><strong>Setter Injection:</strong> Dependencies are injected via setter methods.</li>
    <li><strong>Field Injection:</strong> Dependencies are injected directly into fields using the <code>@Autowired</code> annotation.</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>7. How can you create a custom bean factory in Spring?</h3>
  <p><strong>Answer:</strong> You can create a custom bean factory by implementing the <code>FactoryBean</code> interface. The <code>FactoryBean</code> interface provides methods to define how to create and configure the bean, and it can be used for more complex bean instantiation logic.</p>
</div>
<div class="question">
  <h3>8. What is <code>ApplicationContextAware</code> in Spring?</h3>
  <p><strong>Answer:</strong> The <code>ApplicationContextAware</code> interface allows a Spring bean to access the <code>ApplicationContext</code> object. A class that implements this interface can access the container and beans registered within it via the <code>setApplicationContext()</code> method.</p>
</div>
<div class="question">
  <h3>9. What is the purpose of <code>@Primary</code> annotation?</h3>
  <p><strong>Answer:</strong> The <code>@Primary</code> annotation is used when there are multiple candidates for autowiring a dependency, and you want to specify which bean should be used by default. The bean marked with <code>@Primary</code> is chosen by Spring when multiple beans are available for autowiring.</p>
</div>
<div class="question">
  <h3>10. How can you define a bean’s initialization and destruction methods in Spring?</h3>
  <p><strong>Answer:</strong> You can define initialization and destruction methods for beans in two ways: </p>
  <ul>
    <li>Using the <code>init-method</code> and <code>destroy-method</code> attributes in the XML configuration.</li>
    <li>Using annotations: <code>@PostConstruct</code> for initialization and <code>@PreDestroy</code> for destruction.</li>
  </ul>
  </p>
</div>
<p>&nbsp;</p>
<h2>Spring Core (DI, Bean Lifecycle, ApplicationContext) - Set 7</h2>
<div class="question">
  <h3>1. What is the difference between <code>BeanFactory</code> and <code>ApplicationContext</code> in Spring?</h3>
  <p><strong>Answer:</strong> </p>
  <ul>
    <li><strong>BeanFactory:</strong> The basic container in Spring, providing fundamental features such as bean instantiation and dependency injection. It is more lightweight and has less overhead but lacks advanced features like event handling and AOP support.</li>
    <li><strong>ApplicationContext:</strong> A more advanced container that extends <code>BeanFactory</code> and adds additional functionality, such as event propagation, AOP support, and easier internationalization (i18n). It is generally recommended for most applications.</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>2. What are Spring’s bean scopes and how do they differ?</h3>
  <p><strong>Answer:</strong> Spring supports several bean scopes: </p>
  <ul>
    <li><strong>Singleton:</strong> One shared instance of the bean throughout the Spring container.</li>
    <li><strong>Prototype:</strong> A new instance of the bean is created every time it is requested.</li>
    <li><strong>Request:</strong> A new instance is created for each HTTP request (only valid in a web application).</li>
    <li><strong>Session:</strong> A new instance is created for each HTTP session (only valid in a web application).</li>
    <li><strong>Application:</strong> A single instance of the bean for the entire lifecycle of a ServletContext (valid in web applications).</li>
    <li><strong>WebSocket:</strong> A new instance is created for each WebSocket (valid in web applications).</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>3. What is the <code>@Scope</code> annotation used for in Spring?</h3>
  <p><strong>Answer:</strong> The <code>@Scope</code> annotation in Spring is used to define the scope of a bean. It determines how many instances of the bean should exist within the container. The default scope is <code>singleton</code>, but it can be changed to any of the other scopes, such as <code>prototype</code>, <code>request</code>, <code>session</code>, etc.</p>
</div>
<div class="question">
  <h3>4. What are <code>@PostConstruct</code> and <code>@PreDestroy</code> annotations used for in Spring?</h3>
  <p><strong>Answer:</strong> </p>
  <ul>
    <li><strong>@PostConstruct:</strong> It is used to define a method that should be invoked after the bean's properties are set (after dependency injection).</li>
    <li><strong>@PreDestroy:</strong> It is used to define a method that should be invoked before the bean is destroyed, typically when the application context is closed or the container is being shut down.</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>5. What does the <code>@Autowired</code> annotation do in Spring?</h3>
  <p><strong>Answer:</strong> The <code>@Autowired</code> annotation in Spring is used for automatic dependency injection. When Spring sees this annotation, it will try to inject a matching bean from the application context into the field, setter, or constructor of the class. The matching bean can be selected based on the type of the dependency.</p>
</div>
<div class="question">
  <h3>6. What are some ways to inject dependencies in Spring?</h3>
  <p><strong>Answer:</strong> Spring supports three main types of dependency injection: </p>
  <ul>
    <li><strong>Constructor Injection:</strong> Dependencies are provided through the constructor of the class.</li>
    <li><strong>Setter Injection:</strong> Dependencies are provided via setter methods.</li>
    <li><strong>Field Injection:</strong> Dependencies are directly injected into the fields of the class (not recommended for most cases due to tight coupling).</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>7. What is the <code>ApplicationContextAware</code> interface used for?</h3>
  <p><strong>Answer:</strong> The <code>ApplicationContextAware</code> interface allows a Spring bean to access the <code>ApplicationContext</code>. It provides the <code>setApplicationContext()</code> method, which is called by Spring after the bean has been created and the context has been initialized. This interface allows the bean to interact with the Spring container.</p>
</div>
<div class="question">
  <h3>8. What are the <code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, and <code>@Controller</code> annotations in Spring?</h3>
  <p><strong>Answer:</strong> These are all specializations of the <code>@Component</code> annotation, which is used to mark a class as a Spring-managed bean: </p>
  <ul>
    <li><strong>@Component:</strong> The base annotation for a Spring bean.</li>
    <li><strong>@Service:</strong> A specialization of <code>@Component</code>, typically used to annotate service layer beans.</li>
    <li><strong>@Repository:</strong> A specialization of <code>@Component</code>, typically used to annotate DAO classes.</li>
    <li><strong>@Controller:</strong> A specialization of <code>@Component</code>, used for Spring MVC controller classes.</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>9. What is the difference between <code>@Qualifier</code> and <code>@Primary</code> in Spring?</h3>
  <p><strong>Answer:</strong> </p>
  <ul>
    <li><strong>@Qualifier:</strong> Used to specify which bean to inject when there are multiple beans of the same type. It is used in conjunction with <code>@Autowired</code> to resolve ambiguity.</li>
    <li><strong>@Primary:</strong> Used to mark a bean as the default bean to be injected when there are multiple candidates of the same type. If there is no <code>@Qualifier</code> specified, Spring will use the <code>@Primary</code> bean.</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>10. How can you customize the bean creation process in Spring?</h3>
  <p><strong>Answer:</strong> You can customize the bean creation process in Spring by implementing the <code>BeanFactoryPostProcessor</code> or <code>BeanPostProcessor</code> interfaces. The <code>BeanFactoryPostProcessor</code> is used to modify the <code>BeanFactory</code> configuration before the beans are instantiated, while the <code>BeanPostProcessor</code> is used to modify beans after they are instantiated but before they are returned to the caller.</p>
</div>
<p>&nbsp;</p>
<h2>Spring Core (DI, Bean Lifecycle, ApplicationContext) - Set 8</h2>
<div class="question">
  <h3>1. What is the <code>@Bean</code> annotation used for in Spring?</h3>
  <p><strong>Answer:</strong> The <code>@Bean</code> annotation is used to define a bean in the Spring container through Java configuration. It is typically placed on a method in a class annotated with <code>@Configuration</code> to tell Spring to manage the return value of that method as a Spring bean.</p>
</div>
<div class="question">
  <h3>2. What is the difference between <code>@Configuration</code> and <code>@Component</code> annotations in Spring?</h3>
  <p><strong>Answer:</strong> </p>
  <ul>
    <li><strong>@Configuration:</strong> Used to define a configuration class that declares one or more <code>@Bean</code> methods, essentially replacing the XML configuration.</li>
    <li><strong>@Component:</strong> Marks a class as a Spring bean, which will be automatically discovered by component scanning. It is the general-purpose annotation for marking a bean class.</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>3. How can you control the initialization and destruction of beans in Spring?</h3>
  <p><strong>Answer:</strong> You can control the initialization and destruction of beans in Spring by: </p>
  <ul>
    <li>Using <code>@PostConstruct</code> for initialization and <code>@PreDestroy</code> for destruction methods.</li>
    <li>Implementing the <code>InitializingBean</code> and <code>DisposableBean</code> interfaces for custom initialization and destruction logic.</li>
    <li>Using <code>init-method</code> and <code>destroy-method</code> attributes in the XML configuration.</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>4. What is the purpose of <code>@Primary</code> annotation in Spring?</h3>
  <p><strong>Answer:</strong> The <code>@Primary</code> annotation is used to specify a default bean when multiple beans of the same type exist. If there is no specific <code>@Qualifier</code> annotation to resolve ambiguity, Spring will choose the bean marked with <code>@Primary</code>.</p>
</div>
<div class="question">
  <h3>5. What is the role of <code>ApplicationContext</code> in the Spring framework?</h3>
  <p><strong>Answer:</strong> <code>ApplicationContext</code> is the central interface to the Spring IoC container. It is responsible for providing the beans, managing their lifecycle, and handling dependency injection. It also provides additional features like event propagation, declarative mechanisms, and AOP integration.</p>
</div>
<div class="question">
  <h3>6. What is the <code>BeanFactoryPostProcessor</code> interface used for?</h3>
  <p><strong>Answer:</strong> The <code>BeanFactoryPostProcessor</code> interface allows you to modify the configuration of the <code>BeanFactory</code> before the beans are instantiated. It is typically used to alter bean definitions, such as changing property values, adding additional beans, or modifying the bean registration process.</p>
</div>
<div class="question">
  <h3>7. What is <code>ApplicationContextAware</code> used for in Spring?</h3>
  <p><strong>Answer:</strong> The <code>ApplicationContextAware</code> interface is used to provide access to the <code>ApplicationContext</code> within a bean. By implementing this interface, the bean is able to access the application context and interact with other beans or the environment in which it is running.</p>
</div>
<div class="question">
  <h3>8. Can you explain the <code>autowiring</code> modes in Spring?</h3>
  <p><strong>Answer:</strong> In Spring, autowiring is the automatic injection of dependencies into beans. The modes are: </p>
  <ul>
    <li><strong>byName:</strong> Spring looks for a bean with the same name as the property to be autowired.</li>
    <li><strong>byType:</strong> Spring looks for a bean with the matching data type of the property to be autowired.</li>
    <li><strong>constructor:</strong> Spring uses constructor-based autowiring, providing arguments based on the type of constructor.</li>
    <li><strong>autowire=”default”:</strong> No specific autowiring is applied, and dependencies are injected based on the bean definition.</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>9. How does Spring handle circular dependencies between beans?</h3>
  <p><strong>Answer:</strong> Spring can handle circular dependencies by using setter injection. If two beans depend on each other, Spring will first create the bean instances without setting the dependencies, then it will inject the dependencies using setters after the beans are instantiated. Constructor injection, however, cannot handle circular dependencies directly.</p>
</div>
<div class="question">
  <h3>10. What is the purpose of <code>@ComponentScan</code> annotation?</h3>
  <p><strong>Answer:</strong> The <code>@ComponentScan</code> annotation is used to automatically scan and register beans in the Spring container. It is typically used in conjunction with <code>@Configuration</code> to specify the base packages to scan for annotated components, such as <code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, and <code>@Controller</code> beans.</p>
</div>
<p>&nbsp;</p>
<h2>Spring Core (DI, Bean Lifecycle, ApplicationContext) - Set 9</h2>
<div class="question">
  <h3>1. What is the difference between singleton and prototype bean scopes in Spring?</h3>
  <p><strong>Answer:</strong> </p>
  <ul>
    <li><strong>Singleton:</strong> A single instance of the bean is created and shared across the entire Spring container. It is the default scope.</li>
    <li><strong>Prototype:</strong> A new instance of the bean is created each time it is requested from the Spring container.</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>2. What is the purpose of the <code>@Scope</code> annotation in Spring?</h3>
  <p><strong>Answer:</strong> The <code>@Scope</code> annotation is used to define the scope of a Spring bean. It can be applied to beans to specify how they should be instantiated and managed, with options such as <code>singleton</code>, <code>prototype</code>, <code>request</code>, <code>session</code>, and <code>application</code>.</p>
</div>
<div class="question">
  <h3>3. What are the common scopes available in Spring?</h3>
  <p><strong>Answer:</strong> The common bean scopes in Spring are: </p>
  <ul>
    <li><strong>singleton:</strong> One instance is created per Spring IoC container (default scope).</li>
    <li><strong>prototype:</strong> A new instance is created each time the bean is requested.</li>
    <li><strong>request:</strong> One instance per HTTP request (used in web applications).</li>
    <li><strong>session:</strong> One instance per HTTP session (used in web applications).</li>
    <li><strong>application:</strong> One instance per ServletContext (used in web applications).</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>4. How can you define a custom bean lifecycle in Spring?</h3>
  <p><strong>Answer:</strong> You can define a custom bean lifecycle in Spring by implementing the <code>InitializingBean</code> and <code>DisposableBean</code> interfaces, or by using <code>@PostConstruct</code> and <code>@PreDestroy</code> annotations for initialization and destruction logic, respectively. Additionally, you can specify <code>init-method</code> and <code>destroy-method</code> in XML configuration for custom lifecycle methods.</p>
</div>
<div class="question">
  <h3>5. What does the <code>ApplicationContext</code> provide that <code>BeanFactory</code> does not?</h3>
  <p><strong>Answer:</strong> The <code>ApplicationContext</code> provides all the features of <code>BeanFactory</code>, with additional functionality such as event propagation, internationalization (I18N) support, and the ability to resolve messages. It also provides integration with Spring AOP (Aspect-Oriented Programming) and is a more feature-rich container than <code>BeanFactory</code>.</p>
</div>
<div class="question">
  <h3>6. What is the significance of the <code>@Lazy</code> annotation in Spring?</h3>
  <p><strong>Answer:</strong> The <code>@Lazy</code> annotation is used to delay the initialization of a Spring bean until it is needed. This helps to improve startup performance by deferring the creation of beans that may not be required immediately.</p>
</div>
<div class="question">
  <h3>7. How does Spring handle bean instantiation?</h3>
  <p><strong>Answer:</strong> Spring handles bean instantiation by either creating beans eagerly or lazily, depending on the scope and configuration. It uses reflection to instantiate beans and automatically inject dependencies based on the type and constructor of the beans. Spring also allows for factory methods, either programmatically or using annotations, to create beans.</p>
</div>
<div class="question">
  <h3>8. What is the function of the <code>BeanDefinition</code> interface?</h3>
  <p><strong>Answer:</strong> The <code>BeanDefinition</code> interface is used by Spring to define the metadata about a bean, including its class, dependencies, initialization method, and scope. It provides an abstraction that allows developers to register and manipulate beans programmatically.</p>
</div>
<div class="question">
  <h3>9. What are the advantages of using Spring's Dependency Injection?</h3>
  <p><strong>Answer:</strong> The main advantages of using Spring's Dependency Injection are: </p>
  <ul>
    <li>Improved testability by decoupling components.</li>
    <li>Reduced boilerplate code for creating and managing dependencies.</li>
    <li>Centralized configuration and management of beans in a Spring container.</li>
    <li>Enhanced maintainability and flexibility by making components interchangeable.</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>10. How can you configure Spring beans in an XML configuration file?</h3>
  <p><strong>Answer:</strong> Spring beans can be configured in XML by declaring <code>&lt;bean&gt;</code> elements with attributes like <code>id</code>, <code>class</code>, and <code>scope</code>, and using <code>&lt;constructor-arg&gt;</code> or <code>&lt;property&gt;</code> elements to inject dependencies. Example:</p>
  <pre>&lt;bean id=&quot;myBean&quot; class=&quot;com.example.MyBean&quot; scope=&quot;singleton&quot;&gt;
            &lt;constructor-arg value=&quot;Some value&quot;/&gt;
        &lt;/bean&gt;</pre>
</div>
<p>&nbsp;</p>
<h2>Spring Core (DI, Bean Lifecycle, ApplicationContext) - Set 10</h2>
<div class="question">
  <h3>1. What is the difference between a bean factory and an application context in Spring?</h3>
  <p><strong>Answer:</strong> </p>
  <ul>
    <li><strong>BeanFactory:</strong> It is the simplest container in Spring, providing the fundamental functionality of the IoC container. It is used for lazy initialization of beans and works well for low-memory footprint environments.</li>
    <li><strong>ApplicationContext:</strong> It is a more advanced and feature-rich container compared to <code>BeanFactory</code>. It supports event propagation, internationalization, and integrates with Spring AOP. It is the preferred container in most Spring applications.</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>2. How does Spring handle circular dependencies in beans?</h3>
  <p><strong>Answer:</strong> Spring can handle circular dependencies by using setter injection or by creating a proxy for the beans involved in the circular reference. If constructor injection is used, Spring will throw an exception since it cannot resolve the circular dependency at the time of bean creation.</p>
</div>
<div class="question">
  <h3>3. Can you explain the lifecycle of a Spring bean from creation to destruction?</h3>
  <p><strong>Answer:</strong> The lifecycle of a Spring bean involves the following stages: </p>
  <ol>
    <li><strong>Instantiation:</strong> Spring creates the bean using reflection.</li>
    <li><strong>Dependency Injection:</strong> Spring injects dependencies into the bean using constructor or setter injection.</li>
    <li><strong>Initialization:</strong> Spring calls the <code>init-method</code> or <code>afterPropertiesSet()</code> method, if specified.</li>
    <li><strong>Destruction:</strong> Spring calls the <code>destroy-method</code> or <code>destroy()</code> method during the cleanup phase.</li>
  </ol>
  </p>
</div>
<div class="question">
  <h3>4. What is a bean definition in Spring?</h3>
  <p><strong>Answer:</strong> A bean definition in Spring is a configuration that defines the properties of a bean, including its class type, dependencies, scope, and lifecycle methods. It can be configured in XML, annotation-based configuration, or programmatically via the <code>BeanDefinition</code> API.</p>
</div>
<div class="question">
  <h3>5. How can you configure a bean's scope in Spring?</h3>
  <p><strong>Answer:</strong> You can configure a bean's scope in Spring using the <code>@Scope</code> annotation or the <code>scope</code> attribute in XML configuration. The available scopes are: </p>
  <ul>
    <li><strong>singleton</strong>: One instance per Spring container (default scope).</li>
    <li><strong>prototype</strong>: A new instance each time the bean is requested.</li>
    <li><strong>request</strong>: One instance per HTTP request (for web applications).</li>
    <li><strong>session</strong>: One instance per HTTP session (for web applications).</li>
    <li><strong>application</strong>: One instance per ServletContext (for web applications).</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>6. What is the purpose of the <code>@Autowired</code> annotation in Spring?</h3>
  <p><strong>Answer:</strong> The <code>@Autowired</code> annotation is used for dependency injection in Spring. It allows Spring to automatically inject the dependent beans into a class, either by constructor injection, setter injection, or field injection, based on the bean type.</p>
</div>
<div class="question">
  <h3>7. Can you explain the concept of bean wiring in Spring?</h3>
  <p><strong>Answer:</strong> Bean wiring in Spring refers to the process of connecting beans to their dependencies. There are two main types of wiring in Spring: </p>
  <ul>
    <li><strong>Autowiring:</strong> Spring automatically wires beans by matching their types or names using the <code>@Autowired</code> annotation or XML configuration.</li>
    <li><strong>Manual wiring:</strong> Beans can also be manually wired by specifying their dependencies in XML configuration or using Java-based configuration with <code>@Bean</code>.</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>8. What are the advantages of using the <code>@PostConstruct</code> and <code>@PreDestroy</code> annotations?</h3>
  <p><strong>Answer:</strong> The <code>@PostConstruct</code> and <code>@PreDestroy</code> annotations are used to define lifecycle callback methods that are executed after the bean is initialized and before the bean is destroyed, respectively. They provide an easy way to add initialization and cleanup logic without needing to implement additional interfaces like <code>InitializingBean</code> and <code>DisposableBean</code>.</p>
</div>
<div class="question">
  <h3>9. What is the significance of <code>ApplicationContext</code> in Spring?</h3>
  <p><strong>Answer:</strong> <code>ApplicationContext</code> is the central interface to the Spring IoC container, responsible for managing beans and their dependencies. It provides additional features such as event propagation, AOP support, and internationalization, making it more powerful than <code>BeanFactory</code>.</p>
</div>
<div class="question">
  <h3>10. How do you configure Spring beans in Java-based configuration?</h3>
  <p><strong>Answer:</strong> In Java-based configuration, beans are defined using the <code>@Configuration</code> annotation on a class and the <code>@Bean</code> annotation on methods to define and configure beans. Example:</p>
  <pre>
@Configuration
public class AppConfig {
    @Bean
    public MyBean myBean() {
        return new MyBean();
    }
}
        </pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
</body>
</html>
