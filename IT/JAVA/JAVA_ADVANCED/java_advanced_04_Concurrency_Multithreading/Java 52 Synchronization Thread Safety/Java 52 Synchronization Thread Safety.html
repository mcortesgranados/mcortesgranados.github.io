<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Untitled Document</title>
<style type="text/css">
<!--
.style1 {font-family: Arial, Helvetica, sans-serif}
.style2 {font-family: Arial, Helvetica, sans-serif; font-weight: bold; }
-->
</style>
</head>

<body>
<h1 class="style1">Synchronization &amp; Thread Safety - Q&amp;A Set 1</h1>
<p class="style2"><a href="Java 52 Synchronization Thread Safety 01.mp3" target="_blank">Audio 1</a> - <a href="Java 52 Synchronization Thread Safety 02.mp3" target="_blank">Audio 2</a></p>
<ol class="style1">
  <li> <strong>What is the purpose of synchronization in Java?</strong><br />
    Synchronization ensures that only one thread can access a critical section of code at a time, preventing race conditions and ensuring thread safety.
    <pre>
class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public synchronized int getCount() {
        return count;
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is a race condition in multithreaded programming?</strong><br />
    A race condition occurs when two or more threads attempt to modify shared data concurrently, leading to unpredictable results or inconsistent data.
    <pre>
class RaceCondition {
    private int value = 0;

    public void increment() {
        value++; // Race condition if not synchronized
    }

    public int getValue() {
        return value;
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is the <code>synchronized</code> keyword used for?</strong><br />
    The <code>synchronized</code> keyword ensures that only one thread can execute a method or block of code at a time, making it thread-safe.
    <pre>
class SyncExample {
    public synchronized void doSomething() {
        // Critical section
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is the difference between synchronized methods and synchronized blocks?</strong><br />
    A synchronized method locks the entire method, while a synchronized block locks only a specific section of code, allowing for finer control over synchronization.
    <pre>
class SynchronizedBlock {
    private final Object lock = new Object();

    public void methodWithBlock() {
        synchronized (lock) {
            // Critical section code
        }
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is thread safety?</strong><br />
    Thread safety ensures that a class or method can be safely used by multiple threads simultaneously without causing race conditions or corrupting shared data.
    <pre>
class ThreadSafeCounter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public synchronized int getCount() {
        return count;
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>How can you make a collection thread-safe in Java?</strong><br />
    You can make a collection thread-safe by using synchronized collections like <code>Collections.synchronizedList()</code> or by using concurrent collections such as <code>CopyOnWriteArrayList</code>.
    <pre>
List<Integer> list = Collections.synchronizedList(new ArrayList&lt;&gt;());
list.add(1); // Thread-safe
            </pre>
  </li>
  <br />
  <li> <strong>What is a deadlock in multithreading?</strong><br />
    A deadlock occurs when two or more threads are blocked forever, each waiting for a resource held by the other, creating a cycle of dependencies.
    <pre>
class DeadlockExample {
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();

    public void method1() {
        synchronized (lock1) {
            synchronized (lock2) {
                // Deadlock may occur here
            }
        }
    }

    public void method2() {
        synchronized (lock2) {
            synchronized (lock1) {
                // Deadlock may occur here
            }
        }
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is the <code>volatile</code> keyword in Java?</strong><br />
    The <code>volatile</code> keyword ensures that a variable's value is always read from and written to the main memory, preventing thread-specific caches from causing issues in multithreaded environments.
    <pre>
class VolatileExample {
    private volatile boolean flag = false;

    public void toggleFlag() {
        flag = !flag;
    }

    public boolean getFlag() {
        return flag;
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is the <code>ThreadLocal</code> class in Java?</strong><br />
    The <code>ThreadLocal</code> class provides thread-local variables, meaning each thread has its own independent copy of the variable, preventing synchronization issues.
    <pre>
ThreadLocal<Integer> threadLocalValue = ThreadLocal.withInitial(() -&gt; 0);
threadLocalValue.set(10);
System.out.println(threadLocalValue.get()); // Each thread has its own value
            </pre>
  </li>
</ol>
<p class="style1">&nbsp;</p>
<h1 class="style1">Synchronization &amp; Thread Safety - Q&amp;A Set 2</h1>
<ol class="style1">
  <li> <strong>What is the difference between <code>synchronized</code> and <code>ReentrantLock</code>?</strong><br />
      <code>synchronized</code> is a built-in keyword for synchronization, while <code>ReentrantLock</code> is a more flexible lock that allows for features like timed locks and interruptible lock acquisition.
    <pre>
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class LockExample {
    private final Lock lock = new ReentrantLock();

    public void criticalSection() {
        lock.lock();
        try {
            // Critical section code
        } finally {
            lock.unlock();
        }
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is the <code>readWriteLock</code> and when would you use it?</strong><br />
    A <code>ReadWriteLock</code> allows multiple threads to read a resource concurrently while ensuring that only one thread can write to the resource at a time. It's useful when reads are more frequent than writes.
    <pre>
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

class ReadWriteLockExample {
    private final ReadWriteLock lock = new ReentrantReadWriteLock();

    public void read() {
        lock.readLock().lock();
        try {
            // Reading data
        } finally {
            lock.readLock().unlock();
        }
    }

    public void write() {
        lock.writeLock().lock();
        try {
            // Writing data
        } finally {
            lock.writeLock().unlock();
        }
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What are the best practices for avoiding deadlocks?</strong><br />
    To avoid deadlocks, follow practices like acquiring locks in a consistent order, using <code>tryLock()</code> with timeouts, and keeping lock acquisitions as short as possible.
    <pre>
class DeadlockPrevention {
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();

    public void method1() {
        synchronized (lock1) {
            synchronized (lock2) {
                // Safe to execute
            }
        }
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is the <code>ForkJoinPool</code>?</strong><br />
    The <code>ForkJoinPool</code> is a special implementation of the <code>ExecutorService</code> designed for parallel tasks that can be broken down into smaller sub-tasks, making it ideal for divide-and-conquer algorithms.
    <pre>
import java.util.concurrent.RecursiveTask;
import java.util.concurrent.ForkJoinPool;

class ForkJoinExample extends RecursiveTask<Integer> {
    private final int threshold = 10;
    private final int[] array;
    private final int start, end;

    public ForkJoinExample(int[] array, int start, int end) {
        this.array = array;
        this.start = start;
        this.end = end;
    }

    @Override
    protected Integer compute() {
        if (end - start &lt;= threshold) {
            int sum = 0;
            for (int i = start; i &lt; end; i++) {
                sum += array[i];
            }
            return sum;
        } else {
            int mid = (start + end) / 2;
            ForkJoinExample left = new ForkJoinExample(array, start, mid);
            ForkJoinExample right = new ForkJoinExample(array, mid, end);
            left.fork();
            right.fork();
            return left.join() + right.join();
        }
    }

    public static void main(String[] args) {
        int[] array = new int[100];
        for (int i = 0; i &lt; 100; i++) array[i] = i;

        ForkJoinPool pool = new ForkJoinPool();
        ForkJoinExample task = new ForkJoinExample(array, 0, array.length);
        int result = pool.invoke(task);
        System.out.println(&quot;Sum: &quot; + result);
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is thread contention?</strong><br />
    Thread contention occurs when multiple threads try to access the same resource or critical section concurrently, which may lead to performance degradation due to excessive waiting.
    <pre>
class ThreadContention {
    private int sharedResource = 0;

    public synchronized void increment() {
        sharedResource++;
    }

    public int getResource() {
        return sharedResource;
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is the difference between <code>synchronized</code> and <code>Atomic</code> variables?</strong><br />
      <code>synchronized</code> blocks provide mutual exclusion for critical sections, while <code>Atomic</code> variables offer lock-free, thread-safe operations for single variables.
    <pre>
import java.util.concurrent.atomic.AtomicInteger;

class AtomicExample {
    private final AtomicInteger counter = new AtomicInteger();

    public void increment() {
        counter.incrementAndGet();
    }

    public int getCount() {
        return counter.get();
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>How do you ensure thread safety in a singleton class?</strong><br />
    You can ensure thread safety in a singleton class by using <code>synchronized</code> for the method that returns the instance or by using an enum for a thread-safe singleton.
    <pre>
class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is <code>CountDownLatch</code> and how does it work?</strong><br />
      <code>CountDownLatch</code> is a synchronization aid that allows one or more threads to wait until a set of operations in other threads completes. The latch is initialized with a count, and threads await until the count reaches zero.
    <pre>
import java.util.concurrent.CountDownLatch;

class CountDownLatchExample {
    public static void main(String[] args) throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(2);

        Thread thread1 = new Thread(() -&gt; {
            try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); }
            latch.countDown();
        });

        Thread thread2 = new Thread(() -&gt; {
            try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); }
            latch.countDown();
        });

        thread1.start();
        thread2.start();
        
        latch.await(); // Waits for both threads to complete
        System.out.println(&quot;Both threads are done!&quot;);
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is <code>Semaphore</code> and how is it used?</strong><br />
    A <code>Semaphore</code> is a counting semaphore that controls access to a particular resource by multiple threads. It is initialized with a fixed number of permits, and threads can acquire or release permits to enter the critical section.
    <pre>
import java.util.concurrent.Semaphore;

class SemaphoreExample {
    private static final Semaphore semaphore = new Semaphore(1); // One permit

    public void criticalSection() throws InterruptedException {
        semaphore.acquire();
        try {
            // Critical section code
        } finally {
            semaphore.release();
        }
    }
}
            </pre>
  </li>
</ol>
<p class="style1">&nbsp;</p>
<h1 class="style1">Synchronization &amp; Thread Safety - Q&amp;A Set 3</h1>
<ol class="style1">
  <li> <strong>What is <code>volatile</code> keyword in Java, and how does it affect thread safety?</strong><br />
    The <code>volatile</code> keyword in Java ensures that a variable is directly read from and written to the main memory, making it visible to all threads. It provides a lighter alternative to synchronization but does not guarantee atomicity or consistency for compound operations.
    <pre>
class VolatileExample {
    private volatile boolean flag = false;

    public void changeFlag() {
        flag = true;
    }

    public boolean readFlag() {
        return flag;
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is the difference between <code>wait()</code>, <code>notify()</code>, and <code>notifyAll()</code>?</strong><br />
      <code>wait()</code> is used to pause the execution of a thread until it is notified, <code>notify()</code> wakes up one thread waiting on the object’s monitor, and <code>notifyAll()</code> wakes up all threads waiting on the object’s monitor.
    <pre>
class WaitNotifyExample {
    private final Object lock = new Object();

    public void waitForSignal() throws InterruptedException {
        synchronized (lock) {
            lock.wait(); // Pauses thread
        }
    }

    public void sendSignal() {
        synchronized (lock) {
            lock.notify(); // Wakes up one waiting thread
        }
    }

    public void sendSignalToAll() {
        synchronized (lock) {
            lock.notifyAll(); // Wakes up all waiting threads
        }
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is the <code>ExecutorService</code> and how does it help with thread safety?</strong><br />
      <code>ExecutorService</code> provides a higher-level replacement for manually creating threads. It manages a pool of threads and simplifies thread management by handling scheduling and execution, thus promoting better thread safety and resource management.
    <pre>
import java.util.concurrent.*;

class ExecutorServiceExample {
    public static void main(String[] args) throws InterruptedException {
        ExecutorService executor = Executors.newFixedThreadPool(2);

        executor.submit(() -&gt; {
            // Task 1
            System.out.println(&quot;Task 1 started&quot;);
        });

        executor.submit(() -&gt; {
            // Task 2
            System.out.println(&quot;Task 2 started&quot;);
        });

        executor.shutdown(); // Gracefully shuts down the executor
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is the <code>ReentrantReadWriteLock</code> and how does it differ from <code>synchronized</code> blocks?</strong><br />
    A <code>ReentrantReadWriteLock</code> allows multiple readers or one writer at a time, making it more efficient than using <code>synchronized</code> blocks when there are frequent read operations. It allows better concurrency by allowing multiple threads to read simultaneously.
    <pre>
import java.util.concurrent.locks.*;

class ReentrantReadWriteLockExample {
    private final ReadWriteLock lock = new ReentrantReadWriteLock();

    public void readData() {
        lock.readLock().lock();
        try {
            // Read data
        } finally {
            lock.readLock().unlock();
        }
    }

    public void writeData() {
        lock.writeLock().lock();
        try {

            // Write data
        } finally {
            lock.writeLock().unlock();
        }
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What are atomic operations and how do they improve thread safety?</strong><br />
    Atomic operations ensure that a variable is updated atomically, meaning the update is completed in one indivisible step, thus preventing race conditions. In Java, <code>AtomicInteger</code> or <code>AtomicReference</code> provide atomic methods for variables.
    <pre>
import java.util.concurrent.atomic.AtomicInteger;

class AtomicOperationsExample {
    private final AtomicInteger counter = new AtomicInteger();

    public void increment() {
        counter.incrementAndGet(); // Atomic increment
    }

    public int getCount() {
        return counter.get(); // Atomic read
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is the <code>ThreadLocal</code> class and how does it improve thread safety?</strong><br />
      <code>ThreadLocal</code> ensures that each thread has its own independent copy of a variable, preventing race conditions and synchronization issues. It provides a way to store thread-local data.
    <pre>
class ThreadLocalExample {
    private static final ThreadLocal<Integer> threadLocal = ThreadLocal.withInitial(() -&gt; 1);

    public static void main(String[] args) {
        System.out.println(threadLocal.get()); // Prints 1 for the current thread
        threadLocal.set(2);
        System.out.println(threadLocal.get()); // Prints 2 for the current thread
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is thread starvation?</strong><br />
    Thread starvation occurs when a thread is perpetually denied access to the CPU due to other threads acquiring all the CPU time. It happens when thread scheduling favors certain threads over others.
    <pre>
class StarvationExample {
    private final Object lock = new Object();

    public void task() {
        synchronized (lock) {
            // Critical section
        }
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What are the differences between <code>Thread.sleep()</code> and <code>Object.wait()</code>?</strong><br />
      <code>Thread.sleep()</code> causes the current thread to pause execution for a specified time, while <code>Object.wait()</code> makes the current thread wait until it is notified, and it must be used within a synchronized block.
    <pre>
class SleepVsWait {
    public void sleepExample() throws InterruptedException {
        Thread.sleep(1000); // Pauses execution for 1 second
    }

    public void waitExample() throws InterruptedException {
        synchronized (this) {
            wait(1000); // Waits for notification or timeout
        }
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>How can you implement a thread-safe singleton class using double-checked locking?</strong><br />
    Double-checked locking uses <code>synchronized</code> inside a method with a check to prevent unnecessary synchronization. It ensures thread safety while avoiding performance hits due to synchronization.
    <pre>
class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
            </pre>
  </li>
</ol>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<h1 class="style1">Synchronization &amp; Thread Safety - Q&amp;A Set 4</h1>
<ol class="style1">
  <li> <strong>What is thread safety, and why is it important in concurrent programming?</strong><br />
    Thread safety refers to the property of a program or data structure where multiple threads can safely operate on it without causing data corruption or inconsistent results. It is essential in concurrent programming to prevent race conditions, deadlocks, and data inconsistency. </li>
  <br />
  <li> <strong>What is the difference between synchronized methods and synchronized blocks in Java?</strong><br />
    A synchronized method locks the object or class for the duration of the method, ensuring that only one thread can execute it at a time. A synchronized block, on the other hand, allows more fine-grained control over which part of the code is synchronized.
    <pre>
class SynchronizedExample {
    private final Object lock = new Object();

    public synchronized void synchronizedMethod() {
        // Code executed by only one thread at a time
    }

    public void synchronizedBlock() {
        synchronized (lock) {
            // Code executed by only one thread at a time
        }
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is a race condition, and how can it be prevented?</strong><br />
    A race condition occurs when two or more threads concurrently access shared data and try to change it at the same time, leading to unpredictable results. It can be prevented using synchronization mechanisms like locks, synchronized blocks, or atomic variables. </li>
  <br />
  <li> <strong>How can you use the <code>synchronized</code> keyword to prevent race conditions in a Java program?</strong><br />
    The <code>synchronized</code> keyword ensures that only one thread can access the critical section of code at any given time, thus preventing race conditions.
    <pre>
class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public synchronized int getCount() {
        return count;
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What are the issues with using synchronized blocks excessively?</strong><br />
    Excessive use of synchronized blocks can lead to performance issues, including thread contention and deadlocks. It can also increase the complexity of the program and make it harder to debug and maintain. </li>
  <br />
  <li> <strong>What is deadlock, and how can it be avoided in multithreaded applications?</strong><br />
    Deadlock occurs when two or more threads are blocked forever, each waiting for the other to release a resource. It can be avoided by acquiring locks in a consistent order or using timeout-based mechanisms. </li>
  <br />
  <li> <strong>What is the difference between <code>ReentrantLock</code> and the <code>synchronized</code> keyword?</strong><br />
    The <code>ReentrantLock</code> offers more advanced features compared to the <code>synchronized</code> keyword, such as the ability to try locking with timeouts, interruptible locks, and fair locking, which ensures that threads acquire the lock in the order they requested it.
    <pre>
import java.util.concurrent.locks.*;

class LockExample {
    private final Lock lock = new ReentrantLock();

    public void lockExample() {
        lock.lock();
        try {
            // Critical section code
        } finally {
            lock.unlock();
        }
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is the <code>ReadWriteLock</code> interface, and when should it be used?</strong><br />
    The <code>ReadWriteLock</code> interface provides a mechanism for managing locks on data, allowing multiple threads to read the data concurrently while writing operations are exclusive. It is useful when the application has many read operations but fewer write operations.
    <pre>
import java.util.concurrent.locks.*;

class ReadWriteLockExample {
    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();

    public void readData() {
        rwLock.readLock().lock();
        try {
            // Read operation
        } finally {
            rwLock.readLock().unlock();
        }
    }

    public void writeData() {
        rwLock.writeLock().lock();
        try {
            // Write operation
        } finally {
            rwLock.writeLock().unlock();
        }
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is the significance of the <code>volatile</code> keyword in multithreaded programming?</strong><br />
    The <code>volatile</code> keyword ensures that a variable's value is always read from and written to the main memory, making it visible across all threads. However, it does not guarantee atomicity for compound operations.
    <pre>
class VolatileExample {
    private volatile boolean flag = false;

    public void changeFlag() {
        flag = true;
    }

    public boolean readFlag() {
        return flag;
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>How can you implement a thread-safe collection in Java?</strong><br />
    Java provides several thread-safe collections in the <code>java.util.concurrent</code> package, such as <code>CopyOnWriteArrayList</code>, <code>ConcurrentHashMap</code>, and <code>BlockingQueue</code>. These collections handle synchronization internally, making them safe for use in multithreaded environments.
    <pre>
import java.util.concurrent.*;

class ThreadSafeCollectionExample {
    private final ConcurrentMap map = new ConcurrentHashMap&lt;&gt;();

    public void addData() {
        map.put(1, &quot;Data&quot;);
    }

    public String getData() {
        return map.get(1);
    }
}
            </pre>
  </li>
</ol>
<p class="style1">&nbsp;</p>
<h1 class="style1">Synchronization &amp; Thread Safety - Q&amp;A Set 5</h1>
<ol class="style1">
  <li> <strong>What is the purpose of the <code>ThreadLocal</code> class in Java?</strong><br />
    The <code>ThreadLocal</code> class provides thread-local variables. Each thread accessing a <code>ThreadLocal</code> variable has its own independent copy, making it thread-safe without synchronization.
    <pre>
class ThreadLocalExample {
    private static ThreadLocal<Integer> threadLocal = ThreadLocal.withInitial(() -&gt; 1);

    public void increment() {
        threadLocal.set(threadLocal.get() + 1);
    }

    public int get() {
        return threadLocal.get();
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is the difference between <code>wait()</code> and <code>sleep()</code> in Java?</strong><br />
      <code>wait()</code> is used in synchronized methods to release the lock and allow other threads to acquire it. <code>sleep()</code> pauses the thread for a specified amount of time without releasing any locks.
    <pre>
class WaitSleepExample {
    public synchronized void exampleWait() throws InterruptedException {
        wait(); // Releases the lock and waits
    }

    public void exampleSleep() throws InterruptedException {
        Thread.sleep(1000); // Pauses without releasing the lock
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is the purpose of the <code>ReentrantReadWriteLock</code> class in Java?</strong><br />
    The <code>ReentrantReadWriteLock</code> class allows multiple threads to read shared data concurrently, but only one thread can write to the data at a time. It is useful when read operations are more frequent than write operations.
    <pre>
import java.util.concurrent.locks.*;

class ReentrantReadWriteLockExample {
    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();

    public void readData() {
        rwLock.readLock().lock();
        try {
            // Read operation
        } finally {
            rwLock.readLock().unlock();
        }
    }

    public void writeData() {
        rwLock.writeLock().lock();
        try {
            // Write operation
        } finally {
            rwLock.writeLock().unlock();
        }
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is the difference between <code>ConcurrentHashMap</code> and <code>HashMap</code>?</strong><br />
      <code>ConcurrentHashMap</code> is thread-safe and allows multiple threads to read and write to the map concurrently without external synchronization. In contrast, <code>HashMap</code> is not thread-safe and requires external synchronization to be used safely in a multithreaded environment.
    <pre>
import java.util.concurrent.*;

class ConcurrentHashMapExample {
    private final ConcurrentMap map = new ConcurrentHashMap&lt;&gt;();

    public void addData() {
        map.put(1, &quot;Data&quot;);
    }

    public String getData() {
        return map.get(1);
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is thread contention, and how can it be reduced?</strong><br />
    Thread contention occurs when multiple threads try to access the same resource simultaneously. It can be reduced by minimizing the critical section, using proper synchronization techniques, and using thread-safe data structures. </li>
  <br />
  <li> <strong>How does the <code>ExecutorService</code> help in managing thread safety?</strong><br />
      <code>ExecutorService</code> provides a higher-level replacement for the traditional thread management techniques, like <code>Thread</code> or <code>Runnable</code>. It manages a pool of threads and allows for better control over concurrency and thread safety.
    <pre>
import java.util.concurrent.*;

class ExecutorServiceExample {
    private final ExecutorService executor = Executors.newFixedThreadPool(10);

    public void executeTask(Runnable task) {
        executor.submit(task);
    }

    public void shutdown() {
        executor.shutdown();
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What are atomic operations, and how can they be implemented in Java?</strong><br />
    Atomic operations are operations that are performed as a single, indivisible step. Java provides atomic classes like <code>AtomicInteger</code>, <code>AtomicLong</code>, and <code>AtomicReference</code> to ensure thread safety without synchronization.
    <pre>
import java.util.concurrent.atomic.*;

class AtomicExample {
    private final AtomicInteger counter = new AtomicInteger(0);

    public void increment() {
        counter.incrementAndGet();
    }

    public int getCounter() {
        return counter.get();
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is the <code>ForkJoinPool</code>, and when is it useful?</strong><br />
    The <code>ForkJoinPool</code> is designed for parallel tasks that can be split into smaller tasks. It is useful for divide-and-conquer algorithms, where tasks can be recursively split and then combined.
    <pre>
import java.util.concurrent.*;

class ForkJoinPoolExample {
    private final ForkJoinPool pool = new ForkJoinPool();

    public void processTask(RecursiveTask<Integer> task) {
        pool.invoke(task);
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is the <code>CountDownLatch</code> in Java, and how does it work?</strong><br />
      <code>CountDownLatch</code> is used to synchronize threads by allowing one or more threads to wait until a set of operations performed by other threads reaches a specified count.
    <pre>
import java.util.concurrent.*;

class CountDownLatchExample {
    private final CountDownLatch latch = new CountDownLatch(3);

    public void task() throws InterruptedException {
        // Perform some task
        latch.countDown(); // Decrements the latch count
    }

    public void await() throws InterruptedException {
        latch.await(); // Waits until the count reaches zero
    }
}
            </pre>
  </li>
</ol>
<p class="style1">&nbsp;</p>
<h1 class="style1">Synchronization &amp; Thread Safety - Q&amp;A Set 6</h1>
<ol class="style1">
  <li> <strong>What is the difference between <code>synchronized</code> block and <code>synchronized</code> method?</strong><br />
    A <code>synchronized</code> method locks the instance of the class or the class object (if it's static) for the duration of the method's execution. A <code>synchronized</code> block allows you to lock a specific object, offering finer control over which resource is locked.
    <pre>
class SynchronizedExample {
    private final Object lock = new Object();

    public synchronized void method() {
        // synchronized method
    }

    public void block() {
        synchronized (lock) {
            // synchronized block
        }
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is the <code>volatile</code> keyword used for in Java?</strong><br />
    The <code>volatile</code> keyword is used to indicate that a variable's value may be changed by multiple threads. It ensures visibility of changes made to the variable across all threads, but it doesn't guarantee atomicity.
    <pre>
class VolatileExample {
    private volatile boolean flag = false;

    public void setFlagTrue() {
        flag = true;
    }

    public boolean getFlag() {
        return flag;
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is a <code>ReentrantLock</code>, and how does it differ from <code>synchronized</code>?</strong><br />
      <code>ReentrantLock</code> is a more flexible and feature-rich alternative to the synchronized keyword. It provides additional functionality like lock acquisition with a timeout and the ability to interrupt threads waiting for a lock.
    <pre>
import java.util.concurrent.locks.*;

class ReentrantLockExample {
    private final ReentrantLock lock = new ReentrantLock();

    public void exampleMethod() {
        lock.lock();
        try {
            // critical section
        } finally {
            lock.unlock();
        }
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is the purpose of <code>Lock</code> in Java, and when should it be used?</strong><br />
    The <code>Lock</code> interface provides a more sophisticated and flexible locking mechanism compared to the synchronized keyword. It should be used when you need fine-grained control over locks or need to handle lock timeouts, retries, etc.
    <pre>
import java.util.concurrent.locks.*;

class LockExample {
    private final Lock lock = new ReentrantLock();

    public void exampleMethod() {
        lock.lock();
        try {
            // critical section
        } finally {
            lock.unlock();
        }
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>How does the <code>AtomicInteger</code> class ensure thread safety?</strong><br />
    The <code>AtomicInteger</code> class ensures thread safety by providing atomic operations, meaning operations like increment and decrement are guaranteed to complete in a single, indivisible step, without the need for explicit synchronization.
    <pre>
import java.util.concurrent.atomic.*;

class AtomicIntegerExample {
    private final AtomicInteger counter = new AtomicInteger();

    public void increment() {
        counter.incrementAndGet();
    }

    public int getCounter() {
        return counter.get();
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is a <code>Semaphore</code> in Java, and how is it used?</strong><br />
    A <code>Semaphore</code> controls access to a shared resource by limiting the number of threads that can access it simultaneously. It uses permits to manage the number of threads allowed to execute a particular section of code.
    <pre>
import java.util.concurrent.*;

class SemaphoreExample {
    private final Semaphore semaphore = new Semaphore(2);

    public void accessResource() throws InterruptedException {
        semaphore.acquire();
        try {
            // Access the shared resource
        } finally {
            semaphore.release();
        }
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is the purpose of the <code>CountDownLatch</code> class?</strong><br />
      <code>CountDownLatch</code> is used to block a thread until a specified number of events occur. It is often used to wait for a collection of threads to complete their tasks before proceeding.
    <pre>
import java.util.concurrent.*;

class CountDownLatchExample {
    private final CountDownLatch latch = new CountDownLatch(3);

    public void task() throws InterruptedException {
        // Perform task
        latch.countDown();
    }

    public void waitForCompletion() throws InterruptedException {
        latch.await();
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is thread starvation, and how can it be prevented?</strong><br />
    Thread starvation occurs when a thread is unable to gain regular access to resources because other threads are always being prioritized. It can be prevented by ensuring fair scheduling policies, such as using a <code>ReentrantLock</code> with fairness enabled or using <code>ExecutorService</code> with a proper thread pool. </li>
  <br />
  <li> <strong>What is thread safety, and how can you achieve it in Java?</strong><br />
    Thread safety means that an object or code block can function correctly when multiple threads access it simultaneously. You can achieve thread safety by using synchronization techniques, like <code>synchronized</code> methods/blocks, locks, or thread-safe collections. </li>
</ol>
<p class="style1">&nbsp;</p>
<h1 class="style1">Synchronization &amp; Thread Safety - Q&amp;A Set 7</h1>
<ol class="style1">
  <li> <strong>What is a <code>ReadWriteLock</code> and when should it be used?</strong><br />
    A <code>ReadWriteLock</code> allows multiple threads to read a resource concurrently, but only one thread can write to it at a time. It's ideal for scenarios where reads are frequent and writes are rare.
    <pre>
import java.util.concurrent.locks.*;

class ReadWriteLockExample {
    private final ReadWriteLock lock = new ReentrantReadWriteLock();
    private int sharedResource = 0;

    public void read() {
        lock.readLock().lock();
        try {
            // read resource
        } finally {
            lock.readLock().unlock();
        }
    }

    public void write(int value) {
        lock.writeLock().lock();
        try {
            sharedResource = value;
        } finally {
            lock.writeLock().unlock();
        }
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is the difference between <code>wait()</code> and <code>sleep()</code>?</strong><br />
      <code>wait()</code> is used to pause the execution of a thread and release the lock until another thread signals it to continue, while <code>sleep()</code> pauses the execution of a thread for a fixed period but does not release any locks.
    <pre>
class WaitSleepExample {
    private final Object lock = new Object();

    public void exampleWait() throws InterruptedException {
        synchronized (lock) {
            lock.wait();
        }
    }

    public void exampleSleep() throws InterruptedException {
        Thread.sleep(1000);
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is the <code>ThreadLocal</code> class in Java?</strong><br />
      <code>ThreadLocal</code> provides thread-local variables. Each thread accessing a <code>ThreadLocal</code> variable has its own independent copy, making it thread-safe without synchronization.
    <pre>
class ThreadLocalExample {
    private static final ThreadLocal<Integer> threadLocal = ThreadLocal.withInitial(() -&gt; 0);

    public void increment() {
        threadLocal.set(threadLocal.get() + 1);
    }

    public int getValue() {
        return threadLocal.get();
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is a <code>Deadlock</code>, and how can it be prevented?</strong><br />
    A <code>Deadlock</code> occurs when two or more threads are blocked forever because they are waiting for each other to release a resource. It can be prevented by using a proper locking order or implementing a timeout mechanism. </li>
  <br />
  <li> <strong>How does <code>ExecutorService</code> provide thread pool management?</strong><br />
      <code>ExecutorService</code> provides an easy way to manage a pool of threads, allowing for asynchronous task execution. It handles thread creation, execution, and termination without the need to manually manage individual threads.
    <pre>
import java.util.concurrent.*;

class ExecutorServiceExample {
    private final ExecutorService executorService = Executors.newFixedThreadPool(2);

    public void submitTask() {
        executorService.submit(() -&gt; {
            // task logic
        });
    }

    public void shutdown() {
        executorService.shutdown();
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is <code>ThreadPoolExecutor</code> and when would you use it?</strong><br />
      <code>ThreadPoolExecutor</code> is a customizable implementation of the <code>ExecutorService</code> interface. It allows fine-grained control over the thread pool, such as core pool size, maximum pool size, and queue type.
    <pre>
import java.util.concurrent.*;

class ThreadPoolExecutorExample {
    private final ThreadPoolExecutor executor = new ThreadPoolExecutor(2, 4, 60, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;());

    public void submitTask() {
        executor.submit(() -&gt; {
            // task logic
        });
    }

    public void shutdown() {
        executor.shutdown();
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What are the key differences between <code>synchronized</code> and <code>Lock</code>?</strong><br />
      <code>synchronized</code> is a simpler mechanism that automatically acquires and releases locks, while <code>Lock</code> provides more flexibility, allowing for manual lock acquisition, timed lock waits, and lock interruption. </li>
  <br />
  <li> <strong>What is a <code>ForkJoinPool</code> in Java?</strong><br />
    A <code>ForkJoinPool</code> is a special type of thread pool designed for parallel computing. It allows tasks to be recursively split (forked) into smaller tasks and then joined back together when completed.
    <pre>
import java.util.concurrent.*;

class ForkJoinPoolExample {
    private final ForkJoinPool forkJoinPool = new ForkJoinPool();

    public void executeTask() {
        forkJoinPool.submit(() -&gt; {
            // task logic
        });
    }

    public void shutdown() {
        forkJoinPool.shutdown();
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is <code>CompletableFuture</code> in Java and how does it relate to thread safety?</strong><br />
      <code>CompletableFuture</code> is a class that allows you to write asynchronous, non-blocking code. It provides a way to run tasks asynchronously and then combine or process their results.
    <pre>
import java.util.concurrent.*;

class CompletableFutureExample {
    public void runAsyncTask() {
        CompletableFuture.supplyAsync(() -&gt; {
            return &quot;Hello&quot;;
        }).thenAccept(result -&gt; {
            // process result
        });
    }
}
            </pre>
  </li>
</ol>
<h1 class="style1">Synchronization &amp; Thread Safety - Q&amp;A Set 8</h1>
<ol class="style1">
  <li> <strong>What is a <code>volatile</code> keyword in Java and how does it affect thread safety?</strong><br />
    The <code>volatile</code> keyword ensures that a variable's value is always read from and written to the main memory, not cached in local thread memory. This ensures visibility across threads but does not provide atomicity.
    <pre>
class VolatileExample {
    private volatile boolean flag = false;

    public void toggleFlag() {
        flag = !flag;
    }

    public boolean getFlag() {
        return flag;
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is a <code>synchronized</code> block in Java, and when is it preferred over method synchronization?</strong><br />
    A <code>synchronized</code> block allows for fine-grained control over which part of the method needs synchronization. It's preferred when only a portion of the method requires synchronization, minimizing the locked section.
    <pre>
class SynchronizedBlockExample {
    private final Object lock = new Object();

    public void criticalSection() {
        synchronized (lock) {
            // Critical section code
        }
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is a <code>CountDownLatch</code> and how can it be used for thread synchronization?</strong><br />
    A <code>CountDownLatch</code> allows one or more threads to wait until a set of operations in other threads are completed. It’s commonly used to wait for a certain condition before proceeding.
    <pre>
import java.util.concurrent.*;

class CountDownLatchExample {
    private final CountDownLatch latch = new CountDownLatch(1);

    public void waitForCompletion() throws InterruptedException {
        latch.await();
        System.out.println(&quot;Operation completed!&quot;);
    }

    public void signalCompletion() {
        latch.countDown();
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is a <code>Semaphore</code> in Java, and how does it regulate access to resources?</strong><br />
    A <code>Semaphore</code> controls access to a shared resource by maintaining a set number of permits. Threads can acquire permits to access the resource and must release the permit when done.
    <pre>
import java.util.concurrent.*;

class SemaphoreExample {
    private final Semaphore semaphore = new Semaphore(3);

    public void accessResource() throws InterruptedException {
        semaphore.acquire();
        try {
            // Access shared resource
        } finally {
            semaphore.release();
        }
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is the <code>ReentrantLock</code>, and how is it different from using <code>synchronized</code>?</strong><br />
      <code>ReentrantLock</code> is a more flexible lock that provides features such as try-lock, timed lock, and interruptible lock acquisition, unlike <code>synchronized</code>, which is simpler but less feature-rich.
    <pre>
import java.util.concurrent.locks.*;

class ReentrantLockExample {
    private final ReentrantLock lock = new ReentrantLock();

    public void safeMethod() {
        lock.lock();
        try {
            // Critical section code
        } finally {
            lock.unlock();
        }
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>How does <code>ReentrantReadWriteLock</code> improve thread safety in read-heavy applications?</strong><br />
      <code>ReentrantReadWriteLock</code> allows multiple threads to read a resource concurrently but ensures exclusive access when writing. This improves thread safety and performance in applications where reads are much more frequent than writes.
    <pre>
import java.util.concurrent.locks.*;

class ReentrantReadWriteLockExample {
    private final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
    private int resource;

    public int read() {
        rwLock.readLock().lock();
        try {
            return resource;
        } finally {
            rwLock.readLock().unlock();
        }
    }

    public void write(int value) {
        rwLock.writeLock().lock();
        try {
            resource = value;
        } finally {
            rwLock.writeLock().unlock();
        }
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is the <code>ForkJoinTask</code> and how does it relate to parallel computation in Java?</strong><br />
      <code>ForkJoinTask</code> represents tasks in a <code>ForkJoinPool</code>. It's designed for tasks that can be recursively split into smaller sub-tasks, which can then be executed in parallel and combined.
    <pre>
import java.util.concurrent.*;

class ForkJoinTaskExample {
    private final ForkJoinPool forkJoinPool = new ForkJoinPool();

    public void executeTask() {
        forkJoinPool.submit(() -&gt; {
            // Task logic
        });
    }

    public void shutdown() {
        forkJoinPool.shutdown();
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>How do <code>AtomicInteger</code> and other atomic classes help with thread safety?</strong><br />
      <code>AtomicInteger</code> and other atomic classes provide a thread-safe way to perform operations on variables like incrementing or updating values. These classes ensure atomicity without the need for explicit synchronization.
    <pre>
import java.util.concurrent.atomic.*;

class AtomicIntegerExample {
    private final AtomicInteger counter = new AtomicInteger(0);

    public void increment() {
        counter.incrementAndGet();
    }

    public int getValue() {
        return counter.get();
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is the <code>ThreadFactory</code> interface and how can it help manage threads in Java?</strong><br />
    A <code>ThreadFactory</code> is an interface used to create new threads with customized properties (such as name, priority, etc.), often used in thread pools for better thread management and diagnostics.
    <pre>
import java.util.concurrent.*;

class CustomThreadFactory implements ThreadFactory {
    private int threadCount = 0;

    @Override
    public Thread newThread(Runnable r) {
        return new Thread(r, &quot;CustomThread-&quot; + threadCount++);
    }
}
            </pre>
  </li>
</ol>
<h1 class="style1">Synchronization &amp; Thread Safety - Q&amp;A Set 9</h1>
<ol class="style1">
  <li> <strong>What is the significance of the <code>ThreadLocal</code> class in Java?</strong><br />
    The <code>ThreadLocal</code> class provides thread-local variables. Each thread accessing a <code>ThreadLocal</code> variable has its own independent copy, preventing conflicts between threads.
    <pre>
class ThreadLocalExample {
    private ThreadLocal<Integer> threadLocalValue = ThreadLocal.withInitial(() -&gt; 0);

    public void increment() {
        threadLocalValue.set(threadLocalValue.get() + 1);
    }

    public int getValue() {
        return threadLocalValue.get();
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is a <code>Deadlock</code> in Java and how can it be avoided?</strong><br />
    A deadlock occurs when two or more threads are blocked forever because they are waiting for each other. To avoid deadlocks, one can ensure that locks are acquired in a consistent order or use timeout mechanisms.
    <pre>
class DeadlockExample {
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();

    public void method1() {
        synchronized (lock1) {
            synchronized (lock2) {
                // Do something
            }
        }
    }

    public void method2() {
        synchronized (lock2) {
            synchronized (lock1) {
                // Do something
            }
        }
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>How does <code>ReentrantLock</code> support interruptible lock acquisition?</strong><br />
      <code>ReentrantLock</code> allows for interruptible lock acquisition using the <code>lockInterruptibly()</code> method, which allows a thread to acquire a lock unless interrupted.
    <pre>
import java.util.concurrent.locks.*;

class ReentrantLockInterruptibleExample {
    private final ReentrantLock lock = new ReentrantLock();

    public void executeWithLock() throws InterruptedException {
        lock.lockInterruptibly();
        try {
            // Critical section code
        } finally {
            lock.unlock();
        }
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is the <code>ForkJoinPool</code> and how does it optimize parallel execution?</strong><br />
    The <code>ForkJoinPool</code> is a specialized thread pool designed for parallel computing. It efficiently manages tasks that can be recursively divided into smaller sub-tasks, allowing better resource utilization.
    <pre>
import java.util.concurrent.*;

class ForkJoinPoolExample {
    private final ForkJoinPool forkJoinPool = new ForkJoinPool();

    public void submitTask() {
        forkJoinPool.submit(() -&gt; {
            // Task logic
        });
    }

    public void shutdown() {
        forkJoinPool.shutdown();
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What are the benefits of using <code>AtomicReference</code> in Java?</strong><br />
      <code>AtomicReference</code> provides a thread-safe way to update reference types (like objects) atomically, without using locks or synchronization, improving performance and reducing contention.
    <pre>
import java.util.concurrent.atomic.*;

class AtomicReferenceExample {
    private final AtomicReference<String> ref = new AtomicReference&lt;&gt;(&quot;Initial&quot;);

    public void updateReference() {
        ref.set(&quot;Updated&quot;);
    }

    public String getReference() {
        return ref.get();
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is the role of <code>Executors.newFixedThreadPool()</code> in managing thread pools?</strong><br />
      <code>Executors.newFixedThreadPool()</code> creates a thread pool with a fixed number of threads. It is useful when you want to limit the number of concurrent threads to manage system resources efficiently.
    <pre>
import java.util.concurrent.*;

class FixedThreadPoolExample {
    private final ExecutorService executorService = Executors.newFixedThreadPool(3);

    public void submitTasks() {
        for (int i = 0; i &lt; 5; i++) {
            executorService.submit(() -&gt; {
                // Task logic
            });
        }
    }

    public void shutdown() {
        executorService.shutdown();
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>How does <code>Callable</code> differ from <code>Runnable</code> in Java?</strong><br />
      <code>Callable</code> is similar to <code>Runnable</code>, but it can return a result and throw exceptions. It is often used in parallel computing tasks that need to return data or handle errors.
    <pre>
import java.util.concurrent.*;

class CallableExample implements Callable<String> {
    @Override
    public String call() throws Exception {
        return &quot;Result from callable&quot;;
    }
}

class ExecutorExample {
    private final ExecutorService executorService = Executors.newCachedThreadPool();

    public void submitCallable() throws InterruptedException, ExecutionException {
        Future<String> future = executorService.submit(new CallableExample());
        System.out.println(future.get());
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is the use of <code>Thread.sleep()</code> in thread synchronization?</strong><br />
      <code>Thread.sleep()</code> pauses the current thread for a specified amount of time. It is not a synchronization mechanism but can be used to simulate delays in thread execution.
    <pre>
class SleepExample {
    public void simulateDelay() throws InterruptedException {
        Thread.sleep(1000); // Sleep for 1 second
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is the <code>Object.wait()</code> method, and how is it used for inter-thread communication?</strong><br />
      <code>Object.wait()</code> is used to make the current thread release the lock and enter the waiting state until notified by another thread. It is often used for communication between threads in synchronization blocks.
    <pre>
class WaitNotifyExample {
    private final Object lock = new Object();

    public void awaitThread() throws InterruptedException {
        synchronized (lock) {
            lock.wait();
        }
    }

    public void notifyThread() {
        synchronized (lock) {
            lock.notify();
        }
    }
}
            </pre>
  </li>
</ol>
<p class="style1">&nbsp;</p>
<h1 class="style1">Synchronization &amp; Thread Safety - Q&amp;A Set 10</h1>
<ol class="style1">
  <li> <strong>What is the <code>volatile</code> keyword used for in Java?</strong><br />
    The <code>volatile</code> keyword is used to indicate that a variable may be modified by multiple threads. It ensures that the value of the variable is always read from and written to the main memory, preventing caching issues.
    <pre>
class VolatileExample {
    private volatile boolean flag = false;

    public void toggleFlag() {
        flag = !flag;
    }

    public boolean getFlag() {
        return flag;
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is the difference between <code>synchronized</code> methods and blocks in Java?</strong><br />
    A <code>synchronized</code> method ensures that only one thread can execute that method at a time. A <code>synchronized</code> block, on the other hand, only synchronizes a specific section of code within a method, offering more fine-grained control over synchronization.
    <pre>
class SynchronizedMethodsBlocksExample {
    private int counter = 0;

    // Synchronized method
    public synchronized void incrementCounter() {
        counter++;
    }

    // Synchronized block
    public void incrementCounterWithBlock() {
        synchronized (this) {
            counter++;
        }
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>How do <code>CountDownLatch</code> and <code>CyclicBarrier</code> differ in Java?</strong><br />
    A <code>CountDownLatch</code> is used to block a thread until a specified count reaches zero, usually for waiting for multiple threads to finish. A <code>CyclicBarrier</code> is used to synchronize a fixed number of threads, allowing them to all start together at a barrier point and then continue executing.
    <pre>
import java.util.concurrent.*;

class CountDownLatchExample {
    private final CountDownLatch latch = new CountDownLatch(3);

    public void waitForThreads() throws InterruptedException {
        latch.await(); // Wait for countdown to reach 0
    }

    public void threadDone() {
        latch.countDown(); // Decreases the latch count by 1
    }
}

class CyclicBarrierExample {
    private final CyclicBarrier barrier = new CyclicBarrier(3);

    public void waitAtBarrier() throws InterruptedException, BrokenBarrierException {
        barrier.await(); // Threads wait at the barrier
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is the difference between <code>Thread.sleep()</code> and <code>Object.wait()</code> in Java?</strong><br />
      <code>Thread.sleep()</code> pauses the current thread for a specified time, while <code>Object.wait()</code> releases the lock on the object and allows other threads to acquire the lock, waiting until another thread notifies it.
    <pre>
class SleepWaitExample {
    private final Object lock = new Object();

    public void sleepExample() throws InterruptedException {
        Thread.sleep(1000); // Sleeps for 1 second
    }

    public void waitExample() throws InterruptedException {
        synchronized (lock) {
            lock.wait(); // Wait for notification from another thread
        }
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>How does the <code>ExecutorService</code> simplify thread management in Java?</strong><br />
      <code>ExecutorService</code> manages a pool of threads for you, simplifying the task of thread creation, management, and shutdown. It reduces the complexity of directly managing threads and improves performance by reusing thread resources.
    <pre>
import java.util.concurrent.*;

class ExecutorServiceExample {
    private final ExecutorService executorService = Executors.newFixedThreadPool(3);

    public void submitTask() {
        executorService.submit(() -&gt; {
            // Task logic
        });
    }

    public void shutdown() {
        executorService.shutdown();
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is the difference between <code>synchronized</code> keyword and <code>ReentrantLock</code> in Java?</strong><br />
    The <code>synchronized</code> keyword is simpler and provides automatic lock release. <code>ReentrantLock</code> is more flexible and offers additional features like timed lock acquisition, interruptible lock acquisition, and ability to try locking.
    <pre>
import java.util.concurrent.locks.*;

class ReentrantLockExample {
    private final ReentrantLock lock = new ReentrantLock();

    public void execute() {
        lock.lock();
        try {
            // Critical section
        } finally {
            lock.unlock();
        }
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is the use of <code>Thread.interrupt()</code> method in Java?</strong><br />
    The <code>Thread.interrupt()</code> method is used to interrupt a thread's execution. It sets the thread's interrupt flag, which can be checked by the thread to decide if it should terminate its task early.
    <pre>
class InterruptExample {
    public void longRunningTask() throws InterruptedException {
        while (!Thread.currentThread().isInterrupted()) {
            // Simulate a long-running task
        }
    }

    public void interruptThread(Thread thread) {
        thread.interrupt();
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>What is a <code>Semaphore</code> in Java and when would you use it?</strong><br />
    A <code>Semaphore</code> is a synchronization aid that controls access to a shared resource by multiple threads. It allows a set number of threads to access a resource at a time and blocks other threads until a permit is available.
    <pre>
import java.util.concurrent.*;

class SemaphoreExample {
    private final Semaphore semaphore = new Semaphore(3);

    public void accessResource() throws InterruptedException {
        semaphore.acquire(); // Acquire a permit
        try {
            // Access shared resource
        } finally {
            semaphore.release(); // Release the permit
        }
    }
}
            </pre>
  </li>
  <br />
  <li> <strong>How does <code>AtomicInteger</code> work and why is it useful in multi-threaded environments?</strong><br />
      <code>AtomicInteger</code> provides atomic operations for integers. It ensures that the value is updated safely across threads without the need for synchronization.
    <pre>
import java.util.concurrent.atomic.*;

class AtomicIntegerExample {
    private final AtomicInteger count = new AtomicInteger(0);

    public void increment() {
        count.incrementAndGet(); // Atomically increments the value
    }

    public int getCount() {
        return count.get();
    }
}
            </pre>
  </li>
</ol>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
</body>
</html>
