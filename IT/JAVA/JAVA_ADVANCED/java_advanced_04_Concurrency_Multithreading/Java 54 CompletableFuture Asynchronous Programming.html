<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Untitled Document</title>
<style type="text/css">
<!--
.question {            margin-bottom: 20px;
}
-->
</style>
</head>

<body>
<h1>Set 1: CompletableFuture &amp; Asynchronous Programming</h1>
<div class="question">
  <h2>1. What is CompletableFuture in Java?</h2>
  <p>CompletableFuture is a class in Java that provides an easy way to write asynchronous and non-blocking code.</p>
</div>
<div class="question">
  <h2>2. How do you create a simple CompletableFuture?</h2>
  <p>Example: </p>
  <pre>
CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &quot;Hello, World!&quot;);
future.thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>3. What is the difference between thenApply() and thenAccept()?</h2>
  <p>- thenApply(): Transforms the result and returns a new CompletableFuture.<br />
    - thenAccept(): Consumes the result without returning a new CompletableFuture.</p>
</div>
<div class="question">
  <h2>4. How can you run multiple CompletableFutures in parallel?</h2>
  <p>Example: </p>
  <pre>
CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 1&quot;);
CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 2&quot;);
CompletableFuture.allOf(future1, future2).join();
        </pre>
  </p>
</div>
<div class="question">
  <h2>5. How do you handle exceptions in CompletableFuture?</h2>
  <p>Example using exceptionally(): </p>
  <pre>
CompletableFuture.supplyAsync(() -&gt; { throw new RuntimeException(&quot;Error!&quot;); })
    .exceptionally(ex -&gt; &quot;Recovered from: &quot; + ex.getMessage())
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>6. What is the purpose of handle() in CompletableFuture?</h2>
  <p>handle() allows processing both the result and exception in a single callback.</p>
</div>
<div class="question">
  <h2>7. How can you chain multiple CompletableFutures?</h2>
  <p>Example: </p>
  <pre>
CompletableFuture.supplyAsync(() -&gt; &quot;Step 1&quot;)
    .thenApply(result -&gt; result + &quot; -&gt; Step 2&quot;)
    .thenApply(result -&gt; result + &quot; -&gt; Step 3&quot;)
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>8. How do you run a CompletableFuture without returning a result?</h2>
  <p>Use runAsync(): </p>
  <pre>
CompletableFuture.runAsync(() -&gt; System.out.println(&quot;Running asynchronously&quot;));
        </pre>
  </p>
</div>
<div class="question">
  <h2>9. What is the difference between join() and get()?</h2>
  <p>- get(): Throws checked exceptions.<br />
    - join(): Throws unchecked exceptions.</p>
</div>
<div class="question">
  <h2>10. How do you combine results from two CompletableFutures?</h2>
  <p>Example using thenCombine(): </p>
  <pre>
CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &quot;Hello&quot;);
CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &quot;World&quot;);
future1.thenCombine(future2, (a, b) -&gt; a + &quot; &quot; + b)
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<p>&nbsp;</p>
<h1>Set 2: CompletableFuture &amp; Asynchronous Programming</h1>
<div class="question">
  <h2>11. What is the difference between supplyAsync() and runAsync()?</h2>
  <p>- supplyAsync(): Returns a result.<br />
    - runAsync(): Does not return a result.</p>
</div>
<div class="question">
  <h2>12. How do you apply a transformation only if the CompletableFuture completes successfully?</h2>
  <p>Use thenApply(): </p>
  <pre>
CompletableFuture.supplyAsync(() -&gt; &quot;Success&quot;)
    .thenApply(result -&gt; result + &quot; processed&quot;)
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>13. How do you apply an action only if the CompletableFuture fails?</h2>
  <p>Use exceptionally(): </p>
  <pre>
CompletableFuture.supplyAsync(() -&gt; { throw new RuntimeException(&quot;Error!&quot;); })
    .exceptionally(ex -&gt; &quot;Recovered from: &quot; + ex.getMessage())
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>14. How do you apply an action after both CompletableFutures complete?</h2>
  <p>Use thenCombine(): </p>
  <pre>
CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &quot;Hello&quot;);
CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &quot;World&quot;);
future1.thenCombine(future2, (a, b) -&gt; a + &quot; &quot; + b)
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>15. How do you apply an action after either CompletableFuture completes?</h2>
  <p>Use applyToEither(): </p>
  <pre>
CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &quot;Fast Task&quot;);
CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &quot;Slow Task&quot;);
future1.applyToEither(future2, result -&gt; &quot;Result: &quot; + result)
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>16. How do you execute multiple CompletableFutures in sequence?</h2>
  <p>Use thenCompose(): </p>
  <pre>
CompletableFuture.supplyAsync(() -&gt; &quot;First Task&quot;)
    .thenCompose(result -&gt; CompletableFuture.supplyAsync(() -&gt; result + &quot; -&gt; Second Task&quot;))
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>17. How do you execute multiple CompletableFutures concurrently and wait for all?</h2>
  <p>Use allOf(): </p>
  <pre>
CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 1&quot;);
CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 2&quot;);
CompletableFuture.allOf(future1, future2).join();
System.out.println(&quot;All tasks completed&quot;);
        </pre>
  </p>
</div>
<div class="question">
  <h2>18. How do you execute multiple CompletableFutures and get the first completed result?</h2>
  <p>Use anyOf(): </p>
  <pre>
CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &quot;Fast Task&quot;);
CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &quot;Slow Task&quot;);
CompletableFuture.anyOf(future1, future2)
    .thenAccept(result -&gt; System.out.println(&quot;First completed: &quot; + result));
        </pre>
  </p>
</div>
<div class="question">
  <h2>19. How do you provide a default value if a CompletableFuture fails?</h2>
  <p>Use exceptionally(): </p>
  <pre>
CompletableFuture.supplyAsync(() -&gt; { throw new RuntimeException(&quot;Error!&quot;); })
    .exceptionally(ex -&gt; &quot;Default Value&quot;)
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>20. How do you ensure a cleanup action runs regardless of success or failure?</h2>
  <p>Use whenComplete(): </p>
  <pre>
CompletableFuture.supplyAsync(() -&gt; { throw new RuntimeException(&quot;Error!&quot;); })
    .whenComplete((result, ex) -&gt; System.out.println(&quot;Cleanup action executed&quot;));
        </pre>
  </p>
</div>
<p>&nbsp;</p>
<h1>Set 3: CompletableFuture &amp; Asynchronous Programming</h1>
<div class="question">
  <h2>21. How do you handle both success and failure scenarios in a CompletableFuture?</h2>
  <p>Use handle(): </p>
  <pre>
CompletableFuture.supplyAsync(() -&gt; { throw new RuntimeException(&quot;Failure!&quot;); })
    .handle((result, ex) -&gt; result != null ? result : &quot;Recovered from: &quot; + ex.getMessage())
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>22. How do you add logging to a CompletableFuture without modifying the result?</h2>
  <p>Use thenAccept() or peek: </p>
  <pre>
CompletableFuture.supplyAsync(() -&gt; &quot;Task Completed&quot;)
    .thenAccept(result -&gt; System.out.println(&quot;Log: &quot; + result));
        </pre>
  </p>
</div>
<div class="question">
  <h2>23. How do you specify a timeout for a CompletableFuture?</h2>
  <p>Use completeOnTimeout(): </p>
  <pre>
CompletableFuture.supplyAsync(() -&gt; {
    try { Thread.sleep(5000); } catch (InterruptedException e) { }
    return &quot;Finished&quot;;
}).completeOnTimeout(&quot;Default Value&quot;, 3, TimeUnit.SECONDS)
  .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>24. How do you cancel a CompletableFuture?</h2>
  <p>Use cancel(): </p>
  <pre>
CompletableFuture&lt;String&gt; future = new CompletableFuture&lt;&gt;();
future.cancel(true);
System.out.println(&quot;Future cancelled: &quot; + future.isCancelled());
        </pre>
  </p>
</div>
<div class="question">
  <h2>25. How do you create a completed CompletableFuture?</h2>
  <p>Use completedFuture(): </p>
  <pre>
CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture(&quot;Instant Result&quot;);
future.thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>26. How do you create a failed CompletableFuture?</h2>
  <p>Use failedFuture(): </p>
  <pre>
CompletableFuture.failedFuture(new RuntimeException(&quot;Something went wrong&quot;))
    .exceptionally(ex -&gt; &quot;Handled: &quot; + ex.getMessage())
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>27. How do you convert a synchronous method into an asynchronous CompletableFuture?</h2>
  <p>Use supplyAsync(): </p>
  <pre>
public CompletableFuture&lt;Integer&gt; asyncMethod() {
    return CompletableFuture.supplyAsync(() -&gt; compute());
}
private int compute() { return 42; }
        </pre>
  </p>
</div>
<div class="question">
  <h2>28. How do you execute a task asynchronously without returning a result?</h2>
  <p>Use runAsync(): </p>
  <pre>
CompletableFuture.runAsync(() -&gt; System.out.println(&quot;Task running&quot;));
        </pre>
  </p>
</div>
<div class="question">
  <h2>29. How do you execute a CompletableFuture using a custom thread pool?</h2>
  <p>Pass an ExecutorService: </p>
  <pre>
ExecutorService executor = Executors.newFixedThreadPool(5);
CompletableFuture.supplyAsync(() -&gt; &quot;Using custom executor&quot;, executor)
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>30. How do you execute a sequence of CompletableFutures with different return types?</h2>
  <p>Use thenCompose(): </p>
  <pre>
CompletableFuture.supplyAsync(() -&gt; 10)
    .thenCompose(num -&gt; CompletableFuture.supplyAsync(() -&gt; &quot;Result: &quot; + num))
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<p>&nbsp;</p>
<h1>Set 4: CompletableFuture &amp; Asynchronous Programming</h1>
<div class="question">
  <h2>31. How do you combine multiple CompletableFutures into one result?</h2>
  <p>Use thenCombine() or thenCombineAsync(): </p>
  <pre>
CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &quot;Hello&quot;);
CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &quot;World&quot;);
future1.thenCombine(future2, (a, b) -&gt; a + &quot; &quot; + b)
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>32. How do you handle timeouts for multiple asynchronous tasks?</h2>
  <p>Use anyOf() and then manually handle timeouts: </p>
  <pre>
CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 1&quot;);
CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 2&quot;);
CompletableFuture.anyOf(task1, task2).get(2, TimeUnit.SECONDS);
        </pre>
  </p>
</div>
<div class="question">
  <h2>33. How do you handle exceptions in a CompletableFuture chain?</h2>
  <p>Use exceptionally() or handle(): </p>
  <pre>
CompletableFuture.supplyAsync(() -&gt; { throw new RuntimeException(&quot;Error!&quot;); })
    .exceptionally(ex -&gt; &quot;Error handled&quot;)
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>34. What happens when you use get() on a CompletableFuture?</h2>
  <p>The get() method blocks the thread until the result is available, or an exception is thrown: </p>
  <pre>
CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &quot;Hello&quot;);
String result = future.get();  // Blocks until result is available
System.out.println(result);
        </pre>
  </p>
</div>
<div class="question">
  <h2>35. How do you chain multiple asynchronous actions using CompletableFuture?</h2>
  <p>Use thenApply() or thenCompose(): </p>
  <pre>
CompletableFuture.supplyAsync(() -&gt; &quot;Task 1&quot;)
    .thenApply(result -&gt; result + &quot; -&gt; Task 2&quot;)
    .thenApply(result -&gt; result + &quot; -&gt; Task 3&quot;)
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>36. How do you wait for multiple futures to complete and handle the results?</h2>
  <p>Use allOf(): </p>
  <pre>
CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 1&quot;);
CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 2&quot;);
CompletableFuture.allOf(future1, future2).join();
System.out.println(&quot;All tasks completed&quot;);
        </pre>
  </p>
</div>
<div class="question">
  <h2>37. What is the difference between thenApply() and thenCompose() in CompletableFuture?</h2>
  <p>thenApply() applies a function to the result, returning a new result.<br />
    thenCompose() applies a function returning another CompletableFuture and flattens it: </p>
  <pre>
CompletableFuture.supplyAsync(() -&gt; &quot;Task&quot;)
    .thenApply(result -&gt; result + &quot; Completed&quot;)
    .thenCompose(result -&gt; CompletableFuture.supplyAsync(() -&gt; result + &quot; and Finished&quot;))
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>38. How do you create a delayed CompletableFuture?</h2>
  <p>Use sleep() within a supplyAsync task: </p>
  <pre>
CompletableFuture.supplyAsync(() -&gt; {
    try { Thread.sleep(3000); } catch (InterruptedException e) { }
    return &quot;Delayed Result&quot;;
}).thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>39. How do you execute tasks asynchronously without returning any result?</h2>
  <p>Use runAsync(): </p>
  <pre>
CompletableFuture.runAsync(() -&gt; {
    System.out.println(&quot;Asynchronous Task without result&quot;);
});
        </pre>
  </p>
</div>
<div class="question">
  <h2>40. How do you transform the result of a CompletableFuture?</h2>
  <p>Use thenApply() to modify the result: </p>
  <pre>
CompletableFuture.supplyAsync(() -&gt; &quot;Initial Result&quot;)
    .thenApply(result -&gt; result + &quot; -&gt; Transformed&quot;)
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<p>&nbsp;</p>
<h1>Set 5: CompletableFuture &amp; Asynchronous Programming</h1>
<div class="question">
  <h2>41. How do you chain multiple tasks that depend on the result of the previous task?</h2>
  <p>Use thenCompose() to flatten nested CompletableFutures: </p>
  <pre>
CompletableFuture.supplyAsync(() -&gt; &quot;Task 1&quot;)
    .thenCompose(result -&gt; CompletableFuture.supplyAsync(() -&gt; result + &quot; -&gt; Task 2&quot;))
    .thenCompose(result -&gt; CompletableFuture.supplyAsync(() -&gt; result + &quot; -&gt; Task 3&quot;))
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>42. How do you cancel an ongoing asynchronous task?</h2>
  <p>Use cancel() on the CompletableFuture instance: </p>
  <pre>
CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; {
    try { Thread.sleep(5000); } catch (InterruptedException e) { }
    return &quot;Completed&quot;;
});
future.cancel(true); // Cancels the task
System.out.println(&quot;Cancelled: &quot; + future.isCancelled());
        </pre>
  </p>
</div>
<div class="question">
  <h2>43. How do you execute multiple tasks in parallel and collect the results?</h2>
  <p>Use allOf() or anyOf() to execute tasks and collect results: </p>
  <pre>
CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 1&quot;);
CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 2&quot;);
CompletableFuture.allOf(task1, task2).join();
task1.thenAccept(result -&gt; System.out.println(&quot;Result: &quot; + result));
task2.thenAccept(result -&gt; System.out.println(&quot;Result: &quot; + result));
        </pre>
  </p>
</div>
<div class="question">
  <h2>44. How do you execute an action when any of the tasks completes?</h2>
  <p>Use anyOf() to execute an action when any task completes: </p>
  <pre>
CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 1&quot;);
CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 2&quot;);
CompletableFuture.anyOf(task1, task2)
    .thenAccept(result -&gt; System.out.println(&quot;Completed: &quot; + result));
        </pre>
  </p>
</div>
<div class="question">
  <h2>45. How do you execute a sequence of tasks asynchronously, with each task dependent on the result of the previous?</h2>
  <p>Use thenCompose() to chain dependent tasks: </p>
  <pre>
CompletableFuture.supplyAsync(() -&gt; &quot;Task 1&quot;)
    .thenCompose(result -&gt; CompletableFuture.supplyAsync(() -&gt; result + &quot; -&gt; Task 2&quot;))
    .thenCompose(result -&gt; CompletableFuture.supplyAsync(() -&gt; result + &quot; -&gt; Task 3&quot;))
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>46. How do you convert a synchronous method to asynchronous using CompletableFuture?</h2>
  <p>Use supplyAsync() to convert: </p>
  <pre>
public CompletableFuture&lt;String&gt; asyncMethod() {
    return CompletableFuture.supplyAsync(() -&gt; syncMethod());
}
public String syncMethod() {
    return &quot;Synchronous Method Result&quot;;
}
        </pre>
  </p>
</div>
<div class="question">
  <h2>47. How do you handle a case where a CompletableFuture times out?</h2>
  <p>Use exceptionally() or handle() to provide a fallback: </p>
  <pre>
CompletableFuture.supplyAsync(() -&gt; {
    try { Thread.sleep(3000); } catch (InterruptedException e) { }
    return &quot;Result&quot;;
})
.completeOnTimeout(&quot;Timeout Occurred&quot;, 2, TimeUnit.SECONDS)
.thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>48. How do you combine multiple independent tasks into a result?</h2>
  <p>Use thenCombine() to combine results: </p>
  <pre>
CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 1&quot;);
CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 2&quot;);
task1.thenCombine(task2, (result1, result2) -&gt; result1 + &quot; &quot; + result2)
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>49. How do you run an asynchronous task but don't care about the result?</h2>
  <p>Use runAsync() to execute a task without expecting a result: </p>
  <pre>
CompletableFuture.runAsync(() -&gt; System.out.println(&quot;Task running asynchronously&quot;));
        </pre>
  </p>
</div>
<div class="question">
  <h2>50. How do you handle multiple futures and get the first completed result?</h2>
  <p>Use anyOf() to get the first completed result: </p>
  <pre>
CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 1&quot;);
CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 2&quot;);
CompletableFuture.anyOf(task1, task2)
    .thenAccept(result -&gt; System.out.println(&quot;First completed: &quot; + result));
        </pre>
  </p>
</div>
<p>&nbsp;</p>
<h1>Set 6: CompletableFuture &amp; Asynchronous Programming</h1>
<div class="question">
  <h2>51. How can you handle exceptions in CompletableFuture using a fallback method?</h2>
  <p>Use handle() or exceptionally() to handle exceptions and provide a fallback: </p>
  <pre>
CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; {
    if (true) throw new RuntimeException(&quot;Error&quot;);
    return &quot;Success&quot;;
});
future.handle((result, ex) -&gt; {
    if (ex != null) {
        return &quot;Fallback due to error: &quot; + ex.getMessage();
    }
    return result;
}).thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>52. How do you chain a series of asynchronous tasks where each task depends on the result of the previous task?</h2>
  <p>Use thenCompose() for task chaining: </p>
  <pre>
CompletableFuture.supplyAsync(() -&gt; &quot;Task 1&quot;)
    .thenCompose(result -&gt; CompletableFuture.supplyAsync(() -&gt; result + &quot; -&gt; Task 2&quot;))
    .thenCompose(result -&gt; CompletableFuture.supplyAsync(() -&gt; result + &quot; -&gt; Task 3&quot;))
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>53. How do you combine multiple independent asynchronous tasks into a single result?</h2>
  <p>Use thenCombine() to combine two tasks: </p>
  <pre>
CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 1&quot;);
CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 2&quot;);
task1.thenCombine(task2, (result1, result2) -&gt; result1 + &quot; &quot; + result2)
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>54. How can you execute a task after another task completes, regardless of whether it completed successfully or with an exception?</h2>
  <p>Use whenComplete() to execute a task after the completion of another: </p>
  <pre>
CompletableFuture.supplyAsync(() -&gt; &quot;Task 1&quot;)
    .whenComplete((result, ex) -&gt; {
        if (ex != null) {
            System.out.println(&quot;Error occurred: &quot; + ex.getMessage());
        } else {
            System.out.println(&quot;Completed: &quot; + result);
        }
    })
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>55. How do you create a CompletableFuture that executes a task asynchronously?</h2>
  <p>Use supplyAsync() or runAsync() to execute tasks asynchronously: </p>
  <pre>
CompletableFuture.supplyAsync(() -&gt; &quot;Asynchronous Task&quot;);
CompletableFuture.runAsync(() -&gt; System.out.println(&quot;Running asynchronously&quot;));
        </pre>
  </p>
</div>
<div class="question">
  <h2>56. How do you block the current thread until a CompletableFuture completes?</h2>
  <p>Use join() or get() to block the current thread: </p>
  <pre>
CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &quot;Task completed&quot;);
String result = future.join(); // Blocks until completion
System.out.println(result);
        </pre>
  </p>
</div>
<div class="question">
  <h2>57. How do you run multiple independent tasks and wait for all of them to complete?</h2>
  <p>Use CompletableFuture.allOf() to wait for all tasks: </p>
  <pre>
CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 1&quot;);
CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 2&quot;);
CompletableFuture.allOf(task1, task2).join();
task1.thenAccept(result -&gt; System.out.println(&quot;Result: &quot; + result));
task2.thenAccept(result -&gt; System.out.println(&quot;Result: &quot; + result));
        </pre>
  </p>
</div>
<div class="question">
  <h2>58. How do you perform a task only after another CompletableFuture has finished?</h2>
  <p>Use thenRun() to execute a task after another one completes: </p>
  <pre>
CompletableFuture.supplyAsync(() -&gt; &quot;Task 1&quot;)
    .thenRun(() -&gt; System.out.println(&quot;Task 1 finished, executing Task 2&quot;));
        </pre>
  </p>
</div>
<div class="question">
  <h2>59. How do you use a timeout to cancel an ongoing task?</h2>
  <p>Use completeOnTimeout() to set a timeout for a task: </p>
  <pre>
CompletableFuture.supplyAsync(() -&gt; {
    try { Thread.sleep(5000); } catch (InterruptedException e) { }
    return &quot;Completed&quot;;
})
.completeOnTimeout(&quot;Timeout Occurred&quot;, 2, TimeUnit.SECONDS)
.thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>60. How do you handle multiple futures and get the result from the first one that completes?</h2>
  <p>Use anyOf() to get the first completed result: </p>
  <pre>
CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 1&quot;);
CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 2&quot;);
CompletableFuture.anyOf(task1, task2)
    .thenAccept(result -&gt; System.out.println(&quot;First completed: &quot; + result));
        </pre>
  </p>
</div>
<p>&nbsp;</p>
<h1>Set 7: CompletableFuture &amp; Asynchronous Programming</h1>
<div class="question">
  <h2>61. How do you handle multiple futures with an action when all tasks are completed?</h2>
  <p>Use thenCombine() with a set of futures to perform an action once all are completed: </p>
  <pre>
CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 1&quot;);
CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 2&quot;);
task1.thenCombine(task2, (result1, result2) -&gt; result1 + &quot; and &quot; + result2)
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>62. How do you handle the scenario where multiple futures return the same type of result and need to be combined?</h2>
  <p>Use thenCombine() when you need to combine two futures of the same type: </p>
  <pre>
CompletableFuture&lt;Integer&gt; task1 = CompletableFuture.supplyAsync(() -&gt; 1);
CompletableFuture&lt;Integer&gt; task2 = CompletableFuture.supplyAsync(() -&gt; 2);
task1.thenCombine(task2, Integer::sum)
    .thenAccept(result -&gt; System.out.println(&quot;Sum: &quot; + result));
        </pre>
  </p>
</div>
<div class="question">
  <h2>63. How can you apply multiple transformations to a result asynchronously?</h2>
  <p>Use thenApply() to apply transformations: </p>
  <pre>
CompletableFuture.supplyAsync(() -&gt; &quot;Task 1&quot;)
    .thenApply(result -&gt; result + &quot; transformed&quot;)
    .thenApply(result -&gt; result + &quot; again&quot;)
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>64. How can you handle a timeout for an asynchronous task with a custom exception?</h2>
  <p>Use completeOnTimeout() with a custom exception: </p>
  <pre>
CompletableFuture.supplyAsync(() -&gt; {
    try { Thread.sleep(5000); } catch (InterruptedException e) { }
    return &quot;Task completed&quot;;
})
.completeOnTimeout(&quot;Timeout Exception&quot;, 2, TimeUnit.SECONDS)
.thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>65. How do you execute a task after multiple futures complete?</h2>
  <p>Use thenRun() to execute after multiple futures: </p>
  <pre>
CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 1&quot;);
CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 2&quot;);
CompletableFuture.allOf(task1, task2)
    .thenRun(() -&gt; System.out.println(&quot;All tasks completed&quot;));
        </pre>
  </p>
</div>
<div class="question">
  <h2>66. How do you chain multiple futures and perform an action when any of them completes?</h2>
  <p>Use CompletableFuture.anyOf() to execute on any task completion: </p>
  <pre>
CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 1&quot;);
CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 2&quot;);
CompletableFuture.anyOf(task1, task2)
    .thenAccept(result -&gt; System.out.println(&quot;First completed: &quot; + result));
        </pre>
  </p>
</div>
<div class="question">
  <h2>67. How can you create a CompletableFuture from an existing value?</h2>
  <p>Use completedFuture() to create a future from a value: </p>
  <pre>
CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture(&quot;Already Completed&quot;);
future.thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>68. How do you combine multiple futures and handle the exception for all of them?</h2>
  <p>Use exceptionally() for exception handling in combined futures: </p>
  <pre>
CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 1&quot;);
CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 2&quot;);
CompletableFuture.allOf(task1, task2)
    .exceptionally(ex -&gt; {
        System.out.println(&quot;Exception: &quot; + ex.getMessage());
        return null;
    });
        </pre>
  </p>
</div>
<div class="question">
  <h2>69. How can you use CompletableFuture to execute multiple tasks concurrently?</h2>
  <p>Use multiple supplyAsync() calls to execute tasks concurrently: </p>
  <pre>
CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 1&quot;);
CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 2&quot;);
task1.thenAccept(System.out::println);
task2.thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>70. How do you apply a function to the result of a completed CompletableFuture?</h2>
  <p>Use thenApply() to apply a function: </p>
  <pre>
CompletableFuture.supplyAsync(() -&gt; &quot;Task completed&quot;)
    .thenApply(result -&gt; result + &quot; and transformed&quot;)
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<p>&nbsp;</p>
<h1>Set 8: CompletableFuture &amp; Asynchronous Programming</h1>
<div class="question">
  <h2>71. How do you combine multiple asynchronous tasks and get the first successful result?</h2>
  <p>Use anyOf() to get the first successful result: </p>
  <pre>
CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &quot;Result from Task 1&quot;);
CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &quot;Result from Task 2&quot;);
CompletableFuture.anyOf(task1, task2)
    .thenAccept(result -&gt; System.out.println(&quot;First completed: &quot; + result));
        </pre>
  </p>
</div>
<div class="question">
  <h2>72. How can you handle multiple CompletableFutures in a sequential manner?</h2>
  <p>Use thenCompose() to handle futures sequentially: </p>
  <pre>
CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 1&quot;);
task1.thenCompose(result -&gt; CompletableFuture.supplyAsync(() -&gt; result + &quot; -&gt; Task 2&quot;))
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>73. How do you run a task in a different thread pool using CompletableFuture?</h2>
  <p>Use the <code>Executor</code> parameter in supplyAsync() to run a task in a different thread pool: </p>
  <pre>
Executor executor = Executors.newFixedThreadPool(2);
CompletableFuture&lt;String&gt; task = CompletableFuture.supplyAsync(() -&gt; &quot;Task executed in custom thread pool&quot;, executor);
task.thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>74. How can you perform an action on the result of a CompletableFuture but without affecting its result?</h2>
  <p>Use thenAccept() to perform an action without changing the result: </p>
  <pre>
CompletableFuture&lt;String&gt; task = CompletableFuture.supplyAsync(() -&gt; &quot;Task completed&quot;);
task.thenAccept(result -&gt; System.out.println(&quot;Processed: &quot; + result));
        </pre>
  </p>
</div>
<div class="question">
  <h2>75. How do you handle an exception in a CompletableFuture chain?</h2>
  <p>Use exceptionally() to handle exceptions: </p>
  <pre>
CompletableFuture&lt;String&gt; task = CompletableFuture.supplyAsync(() -&gt; {
    throw new RuntimeException(&quot;Something went wrong&quot;);
});
task.exceptionally(ex -&gt; &quot;Default value due to exception: &quot; + ex.getMessage())
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>76. How can you block and get the result of a CompletableFuture?</h2>
  <p>Use get() to block and retrieve the result: </p>
  <pre>
CompletableFuture&lt;String&gt; task = CompletableFuture.supplyAsync(() -&gt; &quot;Task result&quot;);
String result = task.get();
System.out.println(result);
        </pre>
  </p>
</div>
<div class="question">
  <h2>77. How do you schedule a CompletableFuture to run after a delay?</h2>
  <p>Use completeOnTimeout() to schedule a delayed execution: </p>
  <pre>
CompletableFuture&lt;String&gt; task = CompletableFuture.supplyAsync(() -&gt; &quot;Delayed task&quot;);
task.completeOnTimeout(&quot;Timeout result&quot;, 2, TimeUnit.SECONDS)
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>78. How can you ensure a task executes after a certain amount of time?</h2>
  <p>Use delayedExecutor() to execute a task after a delay: </p>
  <pre>
ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
CompletableFuture&lt;String&gt; task = CompletableFuture.supplyAsync(() -&gt; &quot;Delayed task&quot;, executor);
task.completeOnTimeout(&quot;Completed after timeout&quot;, 2, TimeUnit.SECONDS)
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>79. How can you chain tasks to run only when all previous tasks complete?</h2>
  <p>Use thenCompose() to chain tasks sequentially, ensuring one task starts after the previous one finishes: </p>
  <pre>
CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &quot;First task&quot;);
task1.thenCompose(result -&gt; CompletableFuture.supplyAsync(() -&gt; result + &quot; -&gt; Second task&quot;))
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>80. How do you run a task when a CompletableFuture is completed regardless of success or failure?</h2>
  <p>Use whenComplete() to run after completion: </p>
  <pre>
CompletableFuture&lt;String&gt; task = CompletableFuture.supplyAsync(() -&gt; &quot;Completed task&quot;);
task.whenComplete((result, ex) -&gt; {
    if (ex != null) {
        System.out.println(&quot;Error: &quot; + ex.getMessage());
    } else {
        System.out.println(&quot;Result: &quot; + result);
    }
});
        </pre>
  </p>
</div>
<p>&nbsp;</p>
<h1>Set 9: CompletableFuture &amp; Asynchronous Programming</h1>
<div class="question">
  <h2>81. How do you run tasks asynchronously and combine the results?</h2>
  <p>Use thenCombine() to run two tasks in parallel and combine their results: </p>
  <pre>
CompletableFuture&lt;Integer&gt; task1 = CompletableFuture.supplyAsync(() -&gt; 10);
CompletableFuture&lt;Integer&gt; task2 = CompletableFuture.supplyAsync(() -&gt; 20);
task1.thenCombine(task2, (result1, result2) -&gt; result1 + result2)
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>82. How can you perform a task only after a CompletableFuture has been completed?</h2>
  <p>Use thenRun() to perform a task after the CompletableFuture completes: </p>
  <pre>
CompletableFuture&lt;String&gt; task = CompletableFuture.supplyAsync(() -&gt; &quot;Task completed&quot;);
task.thenRun(() -&gt; System.out.println(&quot;Post-task action executed&quot;));
        </pre>
  </p>
</div>
<div class="question">
  <h2>83. How do you create a CompletableFuture that returns a constant value?</h2>
  <p>Use completedFuture() to create a CompletableFuture with a predefined result: </p>
  <pre>
CompletableFuture&lt;String&gt; task = CompletableFuture.completedFuture(&quot;Constant Value&quot;);
task.thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>84. How can you wait for a collection of CompletableFutures to complete?</h2>
  <p>Use allOf() to wait for all tasks to finish: </p>
  <pre>
CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 1&quot;);
CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 2&quot;);
CompletableFuture&lt;Void&gt; allTasks = CompletableFuture.allOf(task1, task2);
allTasks.thenRun(() -&gt; System.out.println(&quot;All tasks completed&quot;));
        </pre>
  </p>
</div>
<div class="question">
  <h2>85. How do you run a task asynchronously after a previous task completes?</h2>
  <p>Use thenCompose() to run a task asynchronously after another task completes: </p>
  <pre>
CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 1 completed&quot;);
task1.thenCompose(result -&gt; CompletableFuture.supplyAsync(() -&gt; result + &quot; -&gt; Task 2&quot;))
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>86. How can you get a result from a CompletableFuture with a timeout?</h2>
  <p>Use get() with a timeout parameter: </p>
  <pre>
CompletableFuture&lt;String&gt; task = CompletableFuture.supplyAsync(() -&gt; &quot;Completed after delay&quot;);
String result = task.get(2, TimeUnit.SECONDS);
System.out.println(result);
        </pre>
  </p>
</div>
<div class="question">
  <h2>87. How do you handle a cancellation of a CompletableFuture?</h2>
  <p>Use cancel() to cancel a CompletableFuture: </p>
  <pre>
CompletableFuture&lt;String&gt; task = CompletableFuture.supplyAsync(() -&gt; {
    try { Thread.sleep(5000); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }
    return &quot;Completed&quot;;
});
task.cancel(true);
System.out.println(&quot;Task canceled: &quot; + task.isCancelled());
        </pre>
  </p>
</div>
<div class="question">
  <h2>88. How can you run a task asynchronously that produces a result and use it in the next step?</h2>
  <p>Use thenApply() to transform the result of an asynchronous task: </p>
  <pre>
CompletableFuture&lt;Integer&gt; task = CompletableFuture.supplyAsync(() -&gt; 10);
task.thenApply(result -&gt; result * 2)
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>89. How can you run tasks asynchronously and handle any exceptions?</h2>
  <p>Use handle() to process results or handle exceptions: </p>
  <pre>
CompletableFuture&lt;String&gt; task = CompletableFuture.supplyAsync(() -&gt; {
    if (true) throw new RuntimeException(&quot;Error!&quot;);
    return &quot;Completed successfully&quot;;
});
task.handle((result, ex) -&gt; {
    if (ex != null) {
        System.out.println(&quot;Error: &quot; + ex.getMessage());
    } else {
        System.out.println(&quot;Result: &quot; + result);
    }
});
        </pre>
  </p>
</div>
<div class="question">
  <h2>90. How can you create a CompletableFuture chain with multiple stages?</h2>
  <p>Use a combination of thenApply() and thenAccept() to create a chain of operations: </p>
  <pre>
CompletableFuture&lt;String&gt; task = CompletableFuture.supplyAsync(() -&gt; &quot;Task 1&quot;);
task.thenApply(result -&gt; result + &quot; -&gt; Task 2&quot;)
    .thenApply(result -&gt; result + &quot; -&gt; Task 3&quot;)
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<p>&nbsp;</p>
<h1>Set 10: CompletableFuture &amp; Asynchronous Programming</h1>
<div class="question">
  <h2>91. How do you handle multiple independent tasks with a common final result?</h2>
  <p>Use thenCombine() to handle multiple independent tasks: </p>
  <pre>
CompletableFuture&lt;Integer&gt; task1 = CompletableFuture.supplyAsync(() -&gt; 1);
CompletableFuture&lt;Integer&gt; task2 = CompletableFuture.supplyAsync(() -&gt; 2);
task1.thenCombine(task2, (result1, result2) -&gt; result1 + result2)
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>92. How do you create a CompletableFuture that runs a callback only after a task completes?</h2>
  <p>Use thenAccept() to run a callback after a task finishes: </p>
  <pre>
CompletableFuture&lt;String&gt; task = CompletableFuture.supplyAsync(() -&gt; &quot;Task Result&quot;);
task.thenAccept(result -&gt; System.out.println(&quot;Callback executed with: &quot; + result));
        </pre>
  </p>
</div>
<div class="question">
  <h2>93. How can you create a task that runs after a certain delay?</h2>
  <p>Use delay with sleep() inside a CompletableFuture: </p>
  <pre>
CompletableFuture&lt;String&gt; delayedTask = CompletableFuture.supplyAsync(() -&gt; {
    try { Thread.sleep(2000); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }
    return &quot;Delayed Task Result&quot;;
});
delayedTask.thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>94. How can you execute tasks sequentially in an asynchronous manner?</h2>
  <p>Use thenCompose() to chain tasks sequentially: </p>
  <pre>
CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &quot;Start&quot;);
task1.thenCompose(result -&gt; CompletableFuture.supplyAsync(() -&gt; result + &quot; -&gt; Next&quot;))
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>95. How do you handle multiple tasks that can run independently?</h2>
  <p>Use allOf() to handle multiple independent tasks: </p>
  <pre>
CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 1&quot;);
CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 2&quot;);
CompletableFuture&lt;Void&gt; allTasks = CompletableFuture.allOf(task1, task2);
allTasks.thenRun(() -&gt; System.out.println(&quot;Both tasks are completed&quot;));
        </pre>
  </p>
</div>
<div class="question">
  <h2>96. How do you run a task asynchronously and return a result in a non-blocking way?</h2>
  <p>Use supplyAsync() to run tasks asynchronously and return a result: </p>
  <pre>
CompletableFuture&lt;String&gt; task = CompletableFuture.supplyAsync(() -&gt; &quot;Task completed&quot;);
task.thenAccept(result -&gt; System.out.println(&quot;Result: &quot; + result));
        </pre>
  </p>
</div>
<div class="question">
  <h2>97. How do you create a CompletableFuture chain with error handling?</h2>
  <p>Use exceptionally() to handle errors in the chain: </p>
  <pre>
CompletableFuture&lt;String&gt; task = CompletableFuture.supplyAsync(() -&gt; {
    if (true) throw new RuntimeException(&quot;Error occurred&quot;);
    return &quot;Task Result&quot;;
});
task.exceptionally(ex -&gt; &quot;Error handled: &quot; + ex.getMessage())
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>98. How can you combine multiple futures and continue with one final result?</h2>
  <p>Use thenCombine() for combining futures: </p>
  <pre>
CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; 100);
CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; 200);
future1.thenCombine(future2, (result1, result2) -&gt; result1 + result2)
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<div class="question">
  <h2>99. How do you use runAsync to execute a task without needing a result?</h2>
  <p>Use runAsync() when you don’t need a result: </p>
  <pre>
CompletableFuture.runAsync(() -&gt; System.out.println(&quot;Task completed without a result&quot;));
        </pre>
  </p>
</div>
<div class="question">
  <h2>100. How can you combine multiple asynchronous tasks with a success handler?</h2>
  <p>Use thenApply() to handle successful results: </p>
  <pre>
CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 1&quot;);
CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &quot;Task 2&quot;);
task1.thenCombine(task2, (result1, result2) -&gt; result1 + &quot; &amp; &quot; + result2)
    .thenApply(result -&gt; &quot;Combined Result: &quot; + result)
    .thenAccept(System.out::println);
        </pre>
  </p>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
</body>
</html>
