<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Untitled Document</title>
<style type="text/css">
<!--
.question {            margin-bottom: 20px;
}
-->
</style>
</head>

<body>
<h2>Deadlocks, Race Conditions, Starvation - Set 1</h2>
<div class="question">
  <h3>1. What is a deadlock?</h3>
  <p><strong>Answer:</strong> A deadlock is a situation in a multi-threaded or multi-process system where two or more processes are blocked indefinitely, each waiting for the other to release resources. This results in a standstill where no process can proceed.</p>
</div>
<div class="question">
  <h3>2. What is a race condition?</h3>
  <p><strong>Answer:</strong> A race condition occurs when the behavior of a software system depends on the relative timing of events such as the execution order of threads. When two or more threads access shared data concurrently without proper synchronization, it can lead to inconsistent or unintended results.</p>
</div>
<div class="question">
  <h3>3. What is starvation in the context of concurrent systems?</h3>
  <p><strong>Answer:</strong> Starvation occurs when a thread or process is perpetually denied the resources it needs to proceed because other processes are continuously being prioritized. This results in the blocked thread or process never getting a chance to execute.</p>
</div>
<div class="question">
  <h3>4. How can deadlocks be prevented in a system?</h3>
  <p><strong>Answer:</strong> Deadlocks can be prevented using techniques such as:</p>
  <ul>
    <li>Resource ordering: Ensuring that all processes request resources in a predefined order to avoid circular wait conditions.</li>
    <li>Timeouts: Implementing timeouts for resource requests to break deadlocks if a process is blocked for too long.</li>
    <li>Resource allocation graphs: Using graphs to detect and avoid cycles that could lead to deadlocks.</li>
  </ul>
</div>
<div class="question">
  <h3>5. How can race conditions be avoided?</h3>
  <p><strong>Answer:</strong> Race conditions can be avoided by using synchronization mechanisms such as:</p>
  <ul>
    <li>Locks (e.g., mutexes or semaphores) to control access to shared resources.</li>
    <li>Atomic operations that ensure data consistency even when multiple threads access the same resource simultaneously.</li>
    <li>Thread-safe data structures that automatically handle concurrency without causing race conditions.</li>
  </ul>
</div>
<div class="question">
  <h3>6. How can starvation be prevented?</h3>
  <p><strong>Answer:</strong> Starvation can be prevented by using techniques such as:</p>
  <ul>
    <li>Fair scheduling algorithms: Ensuring that all processes or threads get a fair share of the CPU time (e.g., Round Robin, Fair Queuing).</li>
    <li>Priority aging: Gradually increasing the priority of processes that have been waiting for a long time.</li>
    <li>Deadlock avoidance strategies: By preventing deadlocks, we reduce the likelihood of starvation occurring.</li>
  </ul>
</div>
<div class="question">
  <h3>7. What is a common condition that can lead to deadlocks?</h3>
  <p><strong>Answer:</strong> A common condition that leads to deadlocks is circular waiting, where each process in a set is waiting for a resource that another process in the set holds. This forms a cycle of dependencies, causing all processes to be blocked.</p>
</div>
<div class="question">
  <h3>8. Can deadlocks occur in single-threaded applications?</h3>
  <p><strong>Answer:</strong> No, deadlocks cannot occur in single-threaded applications because only one process is running at a time. Deadlocks arise in multi-threaded or multi-process systems where multiple processes are competing for the same resources.</p>
</div>
<div class="question">
  <h3>9. What is the difference between a deadlock and a race condition?</h3>
  <p><strong>Answer:</strong> A deadlock occurs when two or more processes are stuck, waiting for each other to release resources, resulting in a complete standstill. A race condition, on the other hand, occurs when the outcome of a program depends on the timing of thread execution, leading to unpredictable behavior.</p>
</div>
<div class="question">
  <h3>10. How can deadlocks be detected?</h3>
  <p><strong>Answer:</strong> Deadlocks can be detected using techniques like:</p>
  <ul>
    <li>Resource allocation graphs to check for cycles.</li>
    <li>Timeouts and retries to break potential deadlocks.</li>
    <li>Monitoring tools that track resource usage and process states in real-time to detect blocked processes.</li>
  </ul>
</div>
<p>&nbsp;</p>
<h2>Deadlocks, Race Conditions, Starvation - Set 2</h2>
<div class="question">
  <h3>11. What are the four necessary conditions for a deadlock to occur?</h3>
  <p><strong>Answer:</strong> The four necessary conditions for a deadlock to occur are:</p>
  <ul>
    <li>Mutual exclusion: Only one process can use a resource at a time.</li>
    <li>Hold and wait: A process holding at least one resource is waiting to acquire additional resources held by other processes.</li>
    <li>No preemption: Resources cannot be forcibly removed from processes holding them.</li>
    <li>Circular wait: A set of processes are each waiting for a resource held by the next process in the cycle.</li>
  </ul>
</div>
<div class="question">
  <h3>12. What is the difference between preemptive and non-preemptive scheduling?</h3>
  <p><strong>Answer:</strong> In preemptive scheduling, a process can be interrupted and forced to yield the CPU before it finishes executing, allowing other processes to run. In non-preemptive scheduling, a process runs to completion without being interrupted by the scheduler.</p>
</div>
<div class="question">
  <h3>13. What is a common way to avoid race conditions in a program?</h3>
  <p><strong>Answer:</strong> A common way to avoid race conditions is to use synchronization mechanisms, such as mutexes (mutual exclusion locks), semaphores, or critical sections. These mechanisms ensure that only one thread can access a shared resource at a time.</p>
</div>
<div class="question">
  <h3>14. How does a deadlock detection algorithm work?</h3>
  <p><strong>Answer:</strong> A deadlock detection algorithm typically works by monitoring the resource allocation and process states in the system. It checks for cycles in the resource allocation graph, which indicates the presence of a deadlock. Once a deadlock is detected, the system can take corrective actions, such as killing or rolling back processes.</p>
</div>
<div class="question">
  <h3>15. Can starvation happen if there is no priority scheduling?</h3>
  <p><strong>Answer:</strong> Yes, starvation can still occur even in non-priority-based scheduling systems. If some processes are continuously blocked because others are consuming resources, they may never get the chance to execute, resulting in starvation.</p>
</div>
<div class="question">
  <h3>16. What is a resource allocation graph?</h3>
  <p><strong>Answer:</strong> A resource allocation graph is a graphical representation used to track resource allocations and process requests in a system. Nodes represent processes and resources, and edges represent the allocation and request of resources. A cycle in the graph indicates a potential deadlock.</p>
</div>
<div class="question">
  <h3>17. How can race conditions lead to data corruption?</h3>
  <p><strong>Answer:</strong> Race conditions can lead to data corruption when multiple threads or processes access shared data concurrently without proper synchronization. If one process updates data while another is reading or modifying it, inconsistent or corrupted data may result.</p>
</div>
<div class="question">
  <h3>18. What is the role of atomic operations in preventing race conditions?</h3>
  <p><strong>Answer:</strong> Atomic operations ensure that a particular task is completed entirely by a single thread or process without interruption. This prevents other threads from accessing or modifying the data in the middle of the operation, effectively preventing race conditions.</p>
</div>
<div class="question">
  <h3>19. How can priority inversion contribute to starvation?</h3>
  <p><strong>Answer:</strong> Priority inversion occurs when a lower-priority process holds a resource needed by a higher-priority process, causing the higher-priority process to wait. If other intermediate-priority processes preempt the lower-priority process, the higher-priority process may be blocked indefinitely, leading to starvation.</p>
</div>
<p>&nbsp;</p>
<h2>Deadlocks, Race Conditions, Starvation - Set 3</h2>
<div class="question">
  <h3>20. How does the &quot;Wait-Die&quot; scheme avoid deadlocks?</h3>
  <p><strong>Answer:</strong> The &quot;Wait-Die&quot; scheme is a deadlock prevention technique used in databases. In this scheme, older processes are allowed to wait for resources held by younger processes, while younger processes requesting resources held by older processes are aborted (they &quot;die&quot;). This prevents circular wait conditions and thus avoids deadlocks.</p>
</div>
<div class="question">
  <h3>21. What is the &quot;Wound-Wait&quot; scheme in deadlock avoidance?</h3>
  <p><strong>Answer:</strong> The &quot;Wound-Wait&quot; scheme is similar to the &quot;Wait-Die&quot; scheme but with a slight difference. In this scheme, younger processes requesting resources held by older processes are immediately aborted (wounded), while older processes can wait for resources held by younger ones. This prevents deadlocks by ensuring no circular waits.</p>
</div>
<div class="question">
  <h3>22. How can mutual exclusion contribute to deadlock?</h3>
  <p><strong>Answer:</strong> Mutual exclusion is one of the four necessary conditions for a deadlock. When a resource can only be held by one process at a time, and multiple processes are trying to acquire the same resource, mutual exclusion leads to situations where processes are blocked and waiting for each other, causing a deadlock.</p>
</div>
<div class="question">
  <h3>23. Can race conditions occur in single-threaded applications?</h3>
  <p><strong>Answer:</strong> No, race conditions cannot occur in single-threaded applications because there is no concurrent execution of threads. Race conditions arise in multi-threaded or multi-process systems when two or more threads/processes try to access shared resources simultaneously.</p>
</div>
<div class="question">
  <h3>24. How does a semaphore help in avoiding race conditions?</h3>
  <p><strong>Answer:</strong> A semaphore is a synchronization tool that manages access to a shared resource by multiple threads. By using a semaphore to limit the number of threads that can access a resource concurrently, race conditions can be prevented by ensuring that only one thread has access to the resource at any given time.</p>
</div>
<div class="question">
  <h3>25. What is the difference between a deadlock and a livelock?</h3>
  <p><strong>Answer:</strong> A deadlock occurs when processes are blocked indefinitely, waiting for resources held by each other. A livelock, on the other hand, occurs when processes are continuously active but unable to make progress because they keep changing states in response to each other, preventing any process from completing its task.</p>
</div>
<div class="question">
  <h3>26. What is starvation in terms of thread scheduling?</h3>
  <p><strong>Answer:</strong> Starvation occurs when a thread is perpetually denied the resources it needs to execute. This can happen in a scheduling system where higher-priority threads keep preempting lower-priority threads, causing the lower-priority threads to never get executed.</p>
</div>
<div class="question">
  <h3>27. What is a critical section in programming?</h3>
  <p><strong>Answer:</strong> A critical section is a part of a program where shared resources are accessed. To avoid race conditions, only one thread should be allowed to execute the critical section at a time. This is usually achieved by using synchronization mechanisms such as locks or semaphores.</p>
</div>
<div class="question">
  <h3>28. What is the role of the &quot;banker's algorithm&quot; in deadlock avoidance?</h3>
  <p><strong>Answer:</strong> The banker's algorithm is a deadlock avoidance algorithm that allocates resources to processes based on their maximum future needs. It checks if a process can safely be granted the requested resources without causing a deadlock. If granting the request would lead to an unsafe state, the request is denied.</p>
</div>
<p>&nbsp;</p>
<h2>Deadlocks, Race Conditions, Starvation - Set 4</h2>
<div class="question">
  <h3>29. What is the role of &quot;timeout&quot; in deadlock detection?</h3>
  <p><strong>Answer:</strong> A timeout mechanism can be used in deadlock detection by forcing processes to wait for a specified period before releasing the resources they hold. If a process does not receive a resource within the timeout period, it is assumed that a deadlock may have occurred, and corrective actions are taken.</p>
</div>
<div class="question">
  <h3>30. How does &quot;Resource Allocation Graph&quot; (RAG) help detect deadlocks?</h3>
  <p><strong>Answer:</strong> A Resource Allocation Graph (RAG) is used to represent the allocation and request relationships between processes and resources. By identifying cycles in the graph, we can detect potential deadlocks. A cycle indicates that a set of processes are waiting for each other, thus creating a deadlock.</p>
</div>
<div class="question">
  <h3>31. What are some techniques to prevent deadlocks?</h3>
  <p><strong>Answer:</strong> Deadlock prevention techniques include:</p>
  <ul>
    <li>Eliminating one of the four necessary conditions for deadlock (mutual exclusion, hold and wait, no preemption, and circular wait).</li>
    <li>Resource ordering: Define a strict order in which resources must be requested to prevent circular wait.</li>
    <li>Preemptive resource allocation: Force processes to release resources when deadlock is detected.</li>
  </ul>
</div>
<div class="question">
  <h3>32. What is the &quot;Two-Phase Locking Protocol&quot; in database management systems?</h3>
  <p><strong>Answer:</strong> The Two-Phase Locking Protocol is a concurrency control method that ensures serializability in a database system. In this protocol, a transaction must acquire all the locks it needs before it releases any locks. The two phases are: the growing phase (where locks are acquired) and the shrinking phase (where locks are released).</p>
</div>
<div class="question">
  <h3>33. How does a lock-free data structure help avoid race conditions?</h3>
  <p><strong>Answer:</strong> A lock-free data structure is designed to allow multiple threads to access and modify the structure without using traditional locking mechanisms. It typically uses atomic operations like compare-and-swap (CAS) to ensure that only one thread can modify the data at a time, preventing race conditions.</p>
</div>
<div class="question">
  <h3>34. What is the difference between optimistic and pessimistic locking?</h3>
  <p><strong>Answer:</strong> Optimistic locking assumes that no conflicts will occur and allows processes to proceed without locking resources, only checking for conflicts when committing changes. Pessimistic locking, on the other hand, locks the resources ahead of time, ensuring no other process can access them during the operation, even at the cost of potential performance degradation.</p>
</div>
<div class="question">
  <h3>35. What is &quot;Thread Starvation&quot; in multithreading?</h3>
  <p><strong>Answer:</strong> Thread starvation occurs when a thread is never allocated CPU time due to the higher priority of other threads. In a multithreaded environment, if a low-priority thread is perpetually preempted by higher-priority threads, it may never get a chance to run, resulting in starvation.</p>
</div>
<div class="question">
  <h3>36. What is a potential downside of using the &quot;Wait-Die&quot; scheme?</h3>
  <p><strong>Answer:</strong> The downside of the &quot;Wait-Die&quot; scheme is that it can lead to higher process termination rates, especially for younger processes, as they are aborted when they request resources held by older processes. This can reduce system throughput if many processes are repeatedly aborted.</p>
</div>
<div class="question">
  <h3>37. How can &quot;fair scheduling&quot; help prevent starvation?</h3>
  <p><strong>Answer:</strong> Fair scheduling algorithms, such as Round Robin or Weighted Fair Queuing, allocate CPU time equally among processes, preventing starvation. By ensuring that every process gets a fair share of CPU time, no process is left waiting indefinitely, thus preventing starvation.</p>
</div>
<p>&nbsp;</p>
<h2>Deadlocks, Race Conditions, Starvation - Set 5</h2>
<div class="question">
  <h3>38. What is a &quot;deadlock detection algorithm&quot;?</h3>
  <p><strong>Answer:</strong> A deadlock detection algorithm is a method used to detect deadlocks in a system. These algorithms check the resource allocation state periodically and look for cycles in the system's Resource Allocation Graph (RAG). If a cycle is found, deadlock has occurred.</p>
</div>
<div class="question">
  <h3>39. How does the &quot;priority inversion&quot; problem relate to starvation?</h3>
  <p><strong>Answer:</strong> Priority inversion occurs when a lower-priority task holds a resource needed by a higher-priority task. If the lower-priority task is preempted by an even lower-priority task, the higher-priority task may starve and never get the resource. This leads to starvation for the high-priority task.</p>
</div>
<div class="question">
  <h3>40. How can &quot;Transaction Timeout&quot; contribute to deadlock prevention?</h3>
  <p><strong>Answer:</strong> Transaction timeout can help prevent deadlock by limiting how long a transaction will wait for resources. If a transaction exceeds the time limit, it will abort and release its resources, preventing a deadlock from forming if it were in a circular wait condition.</p>
</div>
<div class="question">
  <h3>41. How does &quot;lock contention&quot; affect system performance?</h3>
  <p><strong>Answer:</strong> Lock contention occurs when multiple threads try to acquire the same lock simultaneously. This can lead to performance degradation, as threads spend time waiting for the lock instead of performing actual work. High lock contention can also increase the risk of deadlocks and race conditions.</p>
</div>
<div class="question">
  <h3>42. What is the purpose of a &quot;deadlock detection graph&quot;?</h3>
  <p><strong>Answer:</strong> A deadlock detection graph is a representation of the state of resources and processes in a system, used to detect deadlocks. It typically includes nodes representing processes and resources, with edges indicating requests and allocations. Cycles in this graph indicate deadlock.</p>
</div>
<div class="question">
  <h3>43. What are the risks of using &quot;locks&quot; in multithreading?</h3>
  <p><strong>Answer:</strong> The risks of using locks in multithreading include deadlocks, where two or more threads wait for each other indefinitely, and lock contention, where threads are delayed because they are competing for the same lock. Both of these issues can reduce performance and complicate system design.</p>
</div>
<div class="question">
  <h3>44. How does &quot;deadlock recovery&quot; differ from &quot;deadlock prevention&quot;?</h3>
  <p><strong>Answer:</strong> Deadlock recovery involves taking corrective action after a deadlock has occurred, such as aborting processes or preempting resources. Deadlock prevention, on the other hand, involves designing the system in such a way that deadlocks are avoided altogether by preventing one of the four necessary deadlock conditions from occurring.</p>
</div>
<div class="question">
  <h3>45. What is the role of &quot;deadlock avoidance&quot; in a database management system?</h3>
  <p><strong>Answer:</strong> Deadlock avoidance in a database management system involves ensuring that transactions are executed in a way that avoids deadlock conditions. This can be done by using techniques like resource ordering or employing algorithms like the Banker's algorithm, which checks the system's state to ensure that granting a resource will not lead to deadlock.</p>
</div>
<div class="question">
  <h3>46. What is the effect of &quot;starvation&quot; in real-time systems?</h3>
  <p><strong>Answer:</strong> In real-time systems, starvation can be particularly problematic because critical tasks with high priority may not get the resources they need, leading to missed deadlines and potentially catastrophic system failures. Real-time scheduling algorithms must be designed to prevent starvation and ensure timely execution of tasks.</p>
</div>
<p>&nbsp;</p>
<h2>Deadlocks, Race Conditions, Starvation - Set 6</h2>
<div class="question">
  <h3>47. How does &quot;deadlock prevention&quot; work in a multi-threaded system?</h3>
  <p><strong>Answer:</strong> In a multi-threaded system, deadlock prevention works by ensuring that at least one of the four necessary conditions for deadlock (mutual exclusion, hold and wait, no preemption, and circular wait) does not occur. This can be done by using techniques like limiting resource requests or requiring threads to acquire all resources at once.</p>
</div>
<div class="question">
  <h3>48. What is &quot;race condition&quot; and how can it be prevented?</h3>
  <p><strong>Answer:</strong> A race condition occurs when multiple threads access shared resources concurrently in an unpredictable order, leading to inconsistent results. Race conditions can be prevented by using synchronization techniques like locks, semaphores, and atomic operations to ensure only one thread can access the resource at a time.</p>
</div>
<div class="question">
  <h3>49. What is &quot;starvation&quot; and how does it differ from deadlock?</h3>
  <p><strong>Answer:</strong> Starvation occurs when a process is perpetually denied access to necessary resources, often due to higher-priority processes. Unlike deadlock, where two or more processes wait for each other indefinitely, starvation involves one process being indefinitely delayed, even though other processes may be able to complete.</p>
</div>
<div class="question">
  <h3>50. What are &quot;lock-free&quot; data structures and how do they help prevent deadlocks?</h3>
  <p><strong>Answer:</strong> Lock-free data structures allow concurrent threads to access and modify shared data without using traditional locking mechanisms. By using atomic operations (e.g., compare-and-swap), they prevent the need for locks, which helps eliminate deadlocks and reduces contention between threads.</p>
</div>
<div class="question">
  <h3>51. What is a &quot;priority inversion&quot; problem and how can it lead to starvation?</h3>
  <p><strong>Answer:</strong> Priority inversion occurs when a higher-priority thread is waiting for a lower-priority thread to release a resource. This can lead to starvation if lower-priority threads continuously preempt higher-priority ones, preventing them from ever acquiring the resource.</p>
</div>
<div class="question">
  <h3>52. How does &quot;transaction locking&quot; help in preventing race conditions?</h3>
  <p><strong>Answer:</strong> Transaction locking prevents race conditions by ensuring that only one transaction can access a shared resource at a time. When a transaction locks a resource, other transactions must wait until the lock is released, preventing simultaneous conflicting access and ensuring data consistency.</p>
</div>
<div class="question">
  <h3>53. What are &quot;semantics of deadlock-free scheduling&quot;?</h3>
  <p><strong>Answer:</strong> Deadlock-free scheduling semantics ensure that processes are scheduled in such a way that deadlock conditions are avoided. This can be achieved by guaranteeing that resources are allocated to processes in an order that prevents circular waiting, or by enforcing policies that avoid hold-and-wait situations.</p>
</div>
<div class="question">
  <h3>54. How does &quot;deadlock detection&quot; impact system performance?</h3>
  <p><strong>Answer:</strong> Deadlock detection can impact system performance because it requires monitoring and analyzing the resource allocation state. Periodically checking for deadlocks can consume CPU cycles and system resources, potentially reducing overall system throughput if not handled efficiently.</p>
</div>
<div class="question">
  <h3>55. What is the &quot;Banker's algorithm&quot; and how does it help prevent deadlocks?</h3>
  <p><strong>Answer:</strong> The Banker's algorithm is a resource allocation and deadlock avoidance algorithm that checks whether a system is in a safe state before allocating resources. It ensures that a process can always finish if it requests resources, thus preventing deadlocks by avoiding unsafe resource allocations.</p>
</div>
<p>&nbsp;</p>
<h2>Deadlocks, Race Conditions, Starvation - Set 7</h2>
<div class="question">
  <h3>56. What is &quot;livelock,&quot; and how does it differ from deadlock?</h3>
  <p><strong>Answer:</strong> Livelock occurs when two or more processes continuously change states in response to each other but never make progress. Unlike deadlock, where processes are stuck waiting indefinitely, in livelock, they keep executing but fail to complete their tasks.</p>
</div>
<div class="question">
  <h3>57. How can &quot;fair scheduling&quot; help prevent starvation?</h3>
  <p><strong>Answer:</strong> Fair scheduling ensures that all threads or processes receive a fair share of CPU time and resources, preventing any single process from being indefinitely delayed. Techniques like round-robin scheduling and aging help in preventing starvation.</p>
</div>
<div class="question">
  <h3>58. What is &quot;aging&quot; in scheduling, and how does it mitigate starvation?</h3>
  <p><strong>Answer:</strong> Aging is a technique used in scheduling where a process's priority is gradually increased the longer it waits in the queue. This prevents lower-priority processes from being indefinitely postponed due to high-priority processes dominating execution.</p>
</div>
<div class="question">
  <h3>59. How can &quot;wait-die&quot; and &quot;wound-wait&quot; schemes help prevent deadlocks?</h3>
  <p><strong>Answer:</strong> These are deadlock prevention techniques used in database systems: </p>
  <ul>
    <li><strong>Wait-Die:</strong> A younger process requesting a resource held by an older process is forced to wait, while an older process can take resources from a younger one.</li>
    <li><strong>Wound-Wait:</strong> A younger process takes resources from an older process, forcing the older process to restart if necessary, preventing circular wait.</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>60. How do optimistic concurrency control methods prevent race conditions?</h3>
  <p><strong>Answer:</strong> Optimistic concurrency control assumes that conflicts are rare and allows multiple transactions to proceed without locking. Before committing, the system checks for conflicts and rolls back transactions if needed, ensuring data consistency without causing race conditions.</p>
</div>
<div class="question">
  <h3>61. What is the role of &quot;deadlock avoidance&quot; in operating systems?</h3>
  <p><strong>Answer:</strong> Deadlock avoidance ensures that a system never enters an unsafe state by analyzing resource allocation requests before granting them. Algorithms like the Banker's algorithm determine whether granting a request will lead to deadlock and deny the request if necessary.</p>
</div>
<div class="question">
  <h3>62. How do mutexes help in preventing race conditions?</h3>
  <p><strong>Answer:</strong> A mutex (mutual exclusion) is a synchronization mechanism that ensures only one thread can access a shared resource at a time. By locking and unlocking resources, mutexes prevent multiple threads from modifying shared data simultaneously, thereby avoiding race conditions.</p>
</div>
<div class="question">
  <h3>63. What is &quot;deadlock recovery,&quot; and how does it work?</h3>
  <p><strong>Answer:</strong> Deadlock recovery involves detecting deadlocks and taking corrective action to break them. This can be done by aborting one or more processes, preempting resources from a deadlocked process, or rolling back transactions to a safe state.</p>
</div>
<div class="question">
  <h3>64. What is &quot;circular wait,&quot; and how does it contribute to deadlocks?</h3>
  <p><strong>Answer:</strong> Circular wait is a condition where two or more processes hold resources while waiting for resources held by other processes, forming a circular chain. This leads to a deadlock where no process can proceed because each one is waiting for another to release resources.</p>
</div>
<div class="question">
  <h3>65. How do &quot;atomic operations&quot; help prevent race conditions?</h3>
  <p><strong>Answer:</strong> Atomic operations ensure that a sequence of instructions is executed as a single, uninterruptible unit. This prevents race conditions by ensuring that shared resources are updated consistently, without interference from other threads.</p>
</div>
<p>&nbsp;</p>
<h2>Deadlocks, Race Conditions, Starvation - Set 8</h2>
<div class="question">
  <h3>66. What is the &quot;dining philosophers problem,&quot; and how is it related to deadlocks?</h3>
  <p><strong>Answer:</strong> The dining philosophers problem is a classic synchronization problem that demonstrates how deadlocks can occur when multiple processes compete for limited resources. Philosophers (threads) pick up two chopsticks (resources), and if not managed correctly, they can all end up waiting indefinitely, causing a deadlock.</p>
</div>
<div class="question">
  <h3>67. How does &quot;priority inheritance&quot; help prevent priority inversion?</h3>
  <p><strong>Answer:</strong> Priority inheritance is a mechanism where a lower-priority thread temporarily inherits the higher priority of a blocked thread waiting for a resource. This prevents priority inversion, where a low-priority thread holds a resource needed by a high-priority thread, causing delays.</p>
</div>
<div class="question">
  <h3>68. What is a &quot;spinlock,&quot; and when should it be used?</h3>
  <p><strong>Answer:</strong> A spinlock is a type of lock where a thread continuously checks for a resource instead of sleeping. It is useful for short, critical sections where context switching overhead is high, but it can waste CPU cycles if used inefficiently.</p>
</div>
<div class="question">
  <h3>69. What is the &quot;Readers-Writers Problem,&quot; and how does it relate to starvation?</h3>
  <p><strong>Answer:</strong> The Readers-Writers problem involves multiple readers and writers accessing shared data. If writers get priority, readers may starve; if readers dominate, writers may starve. Proper synchronization mechanisms like read-write locks help balance access.</p>
</div>
<div class="question">
  <h3>70. How can semaphores help prevent deadlocks?</h3>
  <p><strong>Answer:</strong> Semaphores control access to resources by allowing a fixed number of processes to access a resource at a time. Using them correctly can prevent circular wait and hold-and-wait conditions, thereby avoiding deadlocks.</p>
</div>
<div class="question">
  <h3>71. How does &quot;timeout&quot; help in deadlock detection?</h3>
  <p><strong>Answer:</strong> A timeout mechanism automatically releases a resource if a process has been waiting too long. This prevents indefinite waiting and helps detect potential deadlocks.</p>
</div>
<div class="question">
  <h3>72. What is &quot;lock ordering,&quot; and how does it prevent deadlocks?</h3>
  <p><strong>Answer:</strong> Lock ordering ensures that multiple threads acquire locks in a consistent, predefined order. This prevents circular waits, a key condition for deadlocks.</p>
</div>
<div class="question">
  <h3>73. How does Java's &quot;ReentrantLock&quot; help in handling deadlocks?</h3>
  <p><strong>Answer:</strong> Java's <code>ReentrantLock</code> provides explicit locking with features like try-lock (non-blocking acquisition) and timed lock acquisition, which help avoid deadlocks by preventing indefinite blocking.</p>
</div>
<div class="question">
  <h3>74. What is &quot;transaction rollback,&quot; and how does it help in deadlock resolution?</h3>
  <p><strong>Answer:</strong> Transaction rollback undoes partially completed transactions when a deadlock is detected, freeing up resources and allowing other transactions to proceed.</p>
</div>
<div class="question">
  <h3>75. What is a &quot;wait graph,&quot; and how is it used in deadlock detection?</h3>
  <p><strong>Answer:</strong> A wait graph represents processes as nodes and resource dependencies as edges. A cycle in the graph indicates a potential deadlock.</p>
</div>
<p>&nbsp;</p>
<h2>Deadlocks, Race Conditions, Starvation - Set 9</h2>
<div class="question">
  <h3>76. What is a &quot;Banker's Algorithm,&quot; and how does it prevent deadlocks?</h3>
  <p><strong>Answer:</strong> Banker's Algorithm is a deadlock avoidance algorithm that ensures a system stays in a safe state by allocating resources only if they do not lead to an unsafe state, where a deadlock could occur.</p>
</div>
<div class="question">
  <h3>77. How does &quot;wait-die&quot; and &quot;wound-wait&quot; help prevent deadlocks?</h3>
  <p><strong>Answer:</strong> These are deadlock prevention schemes: </p>
  <ul>
    <li><strong>Wait-Die:</strong> A younger process waits if an older process holds a resource; otherwise, it aborts.</li>
    <li><strong>Wound-Wait:</strong> An older process forces a younger process to abort (wound), preventing deadlocks.</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>78. How does Java's &quot;Thread.yield()&quot; impact thread execution?</h3>
  <p><strong>Answer:</strong> The <code>Thread.yield()</code> method suggests that the current thread should allow other threads of the same or higher priority to execute, reducing chances of starvation.</p>
</div>
<div class="question">
  <h3>79. What is the &quot;hold and wait&quot; condition in deadlocks?</h3>
  <p><strong>Answer:</strong> Hold and wait occurs when a thread holds one resource while waiting for another. This condition is one of the necessary causes of deadlocks.</p>
</div>
<div class="question">
  <h3>80. How do atomic variables help prevent race conditions in Java?</h3>
  <p><strong>Answer:</strong> Java provides atomic variables (e.g., <code>AtomicInteger</code>) that use low-level CPU instructions to ensure thread-safe updates without locks, preventing race conditions.</p>
</div>
<div class="question">
  <h3>81. How does the &quot;Test-and-Set&quot; instruction help with mutual exclusion?</h3>
  <p><strong>Answer:</strong> The Test-and-Set instruction is an atomic operation that helps achieve mutual exclusion by ensuring that only one thread can modify a shared resource at a time.</p>
</div>
<div class="question">
  <h3>82. What is a &quot;live lock,&quot; and how is it different from deadlock?</h3>
  <p><strong>Answer:</strong> In a live lock, threads constantly change state in response to other threads but make no progress, while in a deadlock, threads remain indefinitely blocked.</p>
</div>
<div class="question">
  <h3>83. How can Java's &quot;Thread.join()&quot; cause deadlocks?</h3>
  <p><strong>Answer:</strong> If two threads call <code>join()</code> on each other, they will wait indefinitely, causing a deadlock.</p>
</div>
<div class="question">
  <h3>84. What is &quot;fairness&quot; in Java locks, and how does it impact starvation?</h3>
  <p><strong>Answer:</strong> Fair locks (<code>new ReentrantLock(true)</code>) ensure that the longest waiting thread gets the lock first, reducing starvation.</p>
</div>
<div class="question">
  <h3>85. How can thread priorities cause starvation in Java?</h3>
  <p><strong>Answer:</strong> If high-priority threads dominate execution, low-priority threads may never get CPU time, leading to starvation.</p>
</div>
<p>&nbsp;</p>
<h2>Deadlocks, Race Conditions, Starvation - Set 10</h2>
<div class="question">
  <h3>86. What is the difference between optimistic and pessimistic locking?</h3>
  <p><strong>Answer:</strong> </p>
  <ul>
    <li><strong>Optimistic Locking:</strong> Assumes conflicts are rare and only checks for conflicts at commit time.</li>
    <li><strong>Pessimistic Locking:</strong> Locks resources when reading or modifying to prevent conflicts.</li>
  </ul>
  </p>
</div>
<div class="question">
  <h3>87. How can a spinlock prevent race conditions?</h3>
  <p><strong>Answer:</strong> A spinlock continuously checks a condition (busy-waiting) instead of blocking, reducing context switches but increasing CPU usage.</p>
</div>
<div class="question">
  <h3>88. How can Java's ReadWriteLock help reduce deadlocks?</h3>
  <p><strong>Answer:</strong> It separates read and write locks, allowing multiple readers but only one writer, reducing contention and the likelihood of deadlocks.</p>
</div>
<div class="question">
  <h3>89. How do timestamps help prevent deadlocks?</h3>
  <p><strong>Answer:</strong> Timestamp ordering ensures older transactions are given priority, preventing circular wait and thus avoiding deadlocks.</p>
</div>
<div class="question">
  <h3>90. What is an &quot;orphaned lock,&quot; and how can it cause problems?</h3>
  <p><strong>Answer:</strong> An orphaned lock occurs when a thread holding a lock crashes or exits without releasing it, leading to deadlocks.</p>
</div>
<div class="question">
  <h3>91. What is priority inversion, and how does it relate to starvation?</h3>
  <p><strong>Answer:</strong> Priority inversion happens when a high-priority thread waits for a lower-priority thread, which may lead to starvation if the low-priority thread never gets CPU time.</p>
</div>
<div class="question">
  <h3>92. How does &quot;backoff&quot; help reduce race conditions?</h3>
  <p><strong>Answer:</strong> A backoff strategy introduces a small delay before retrying an operation, reducing contention and improving stability in concurrent environments.</p>
</div>
<div class="question">
  <h3>93. How can Java's &quot;CompletableFuture&quot; help avoid thread starvation?</h3>
  <p><strong>Answer:</strong> It enables asynchronous, non-blocking execution, preventing unnecessary thread blocking and improving resource availability.</p>
</div>
<div class="question">
  <h3>94. How does &quot;exponential backoff&quot; help prevent starvation?</h3>
  <p><strong>Answer:</strong> Exponential backoff increases wait time between retries, allowing fair access to resources and preventing continuous failure loops.</p>
</div>
<div class="question">
  <h3>95. How does the &quot;happens-before&quot; relationship in Java help avoid race conditions?</h3>
  <p><strong>Answer:</strong> It defines a guaranteed execution order between operations, ensuring visibility and preventing inconsistent states in multi-threaded applications.</p>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
</body>
</html>
