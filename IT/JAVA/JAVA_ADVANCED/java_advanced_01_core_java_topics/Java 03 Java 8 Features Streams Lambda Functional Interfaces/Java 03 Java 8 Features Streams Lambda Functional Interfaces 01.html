<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Java 8+ Features (Streams, Lambda, Functional Interfaces, Optional) - Questions & Answers</title>
<style type="text/css">
<!--
.style1 {font-family: Arial, Helvetica, sans-serif}
-->
</style>
<link href="../../../../../ESTILOS.css" rel="stylesheet" type="text/css">
<style type="text/css">
<!--
.style2 {font-size: 36}
-->
</style>
</head>
<body>
    <h1 class="style1">Java 8+ Features (Streams, Lambda, Functional Interfaces, Optional) - Questions & Answers</h1>
    <h2 class="style1"><a href="Java 03 Java 8 Features Streams Lambda Functional Interfaces 01.mp3" target="_blank">Audio 1</a> - <a href="Java 03 Java 8 Features Streams Lambda Functional Interfaces 02.mp3" target="_blank">Audio 2</a></h2>
    <p>
      <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            padding: 20px;
            background-color: #f8f9fa;
        }
        h2, h3 {
            text-align: center;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            background: #fff;
            box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1);
        }
        th, td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
        }
        th {
            background-color: #007bff;
            color: white;
        }
        pre {
            background-color: #f4f4f4;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 14px;
        }
    </style>
    </p>
<table border="0">
<thead>
        <tr>
            <th class="texto6Copy2">Feature</th>
            <th class="texto6Copy2">Question</th>
            <th class="texto6Copy2">Answer</th>
            <th class="texto6Copy2">Advantages</th>
            <th class="texto6Copy2">Disadvantages</th>
            <th class="texto6Copy2">Use Cases</th>
            <th class="texto6Copy2">Java Code Example</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td rowspan="4" class="solo_borde1"><b>Streams</b></td>
          <td class="texto2">What is a stream in Java?</td>
            <td>A stream is a sequence of elements supporting sequential and parallel aggregate operations. It allows for functional-style operations on data.</td>
            <td>Enables declarative programming. Allows easy parallel processing. Combines multiple operations in a pipeline.</td>
            <td>May incur overhead due to internal iteration. Not suitable for small datasets.</td>
            <td>Processing collections in a functional style. Example: filtering and transforming a list of users based on age.</td>
            <td><pre>List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);<br>List&lt;Integer&gt; squared = numbers.stream().map(x -&gt; x * x).collect(Collectors.toList());</pre></td>
        </tr>
        <tr>
          <th class="texto6Copy2">Question</th>
          <th class="texto6Copy2">Answer</th>
          <th class="texto6Copy2">Advantages</th>
          <th class="texto6Copy2">Disadvantages</th>
          <th class="texto6Copy2">Use Cases</th>
          <th class="texto6Copy2">Java Code Example</th>
        </tr>
        <tr>
            <td class="texto2">What are common operations in Streams?</td>
            <td>map(), filter(), reduce(), collect(), forEach(), sorted(), distinct()</td>
            <td>Simplifies complex data transformations. Allows lazy evaluation for better performance.</td>
            <td>Limited to only processing data; doesn't work for non-sequential access patterns.</td>
            <td>Transforming, aggregating, or filtering data from lists or streams. Example: finding the sum of all ages in a list.</td>
            <td><pre>int sum = numbers.stream().mapToInt(Integer::intValue).sum();</pre></td>
        </tr>
        <tr>
          <th class="texto6Copy2">Question</th>
          <th class="texto6Copy2">Answer</th>
          <th class="texto6Copy2">Advantages</th>
          <th class="texto6Copy2">Disadvantages</th>
          <th class="texto6Copy2">Use Cases</th>
          <th class="texto6Copy2">Java Code Example</th>
        </tr>
        <tr>
            <td rowspan="4" class="solo_borde1"><b>Lambda Expressions</b></td>
          <td class="texto2">What is a lambda expression?</td>
            <td>A lambda expression is a concise way to express instances of single-method interfaces (functional interfaces) using an expression body.</td>
            <td>Shortens code and removes boilerplate. Makes code more readable and functional.</td>
            <td>Can be harder to understand for new developers. Lack of explicit type declarations may confuse debugging.</td>
            <td>Implementing event listeners, sorting lists, filtering data in streams.</td>
            <td><pre>List&lt;Integer&gt; numbers = Arrays.asList(3, 1, 4, 5, 2);<br>numbers.sort((a, b) -&gt; a.compareTo(b));</pre></td>
        </tr>
        <tr>
          <th class="texto6Copy2">Question</th>
          <th class="texto6Copy2">Answer</th>
          <th class="texto6Copy2">Advantages</th>
          <th class="texto6Copy2">Disadvantages</th>
          <th class="texto6Copy2">Use Cases</th>
          <th class="texto6Copy2">Java Code Example</th>
        </tr>
        <tr>
            <td class="texto2">Give an example of a simple lambda expression in Java.</td>
            <td>(int a, int b) -&gt; a + b for adding two integers.</td>
            <td>Simple to write, read, and use.</td>
            <td>No function name, so debugging can be tricky.</td>
            <td>Simple arithmetic or comparisons inside streams, event handling, etc.</td>
            <td><pre>BinaryOperator&lt;Integer&gt; add = (a, b) -&gt; a + b;<br>System.out.println(add.apply(5, 10));</pre></td>
        </tr>
        <tr>
          <th class="texto6Copy2">Question</th>
          <th class="texto6Copy2">Answer</th>
          <th class="texto6Copy2">Advantages</th>
          <th class="texto6Copy2">Disadvantages</th>
          <th class="texto6Copy2">Use Cases</th>
          <th class="texto6Copy2">Java Code Example</th>
        </tr>
        <tr>
            <td rowspan="3" class="solo_borde1"><b>Functional Interfaces</b></td>
            <td class="texto2">What is a functional interface?</td>
            <td>A functional interface is an interface with a single abstract method, used as the target type for lambda expressions and method references.</td>
            <td>Promotes immutability and clear behavior definition. Easily used with lambdas.</td>
            <td>May limit functionality if you want to add more abstract methods.</td>
            <td>Designing custom callback functions, handling asynchronous operations, etc.</td>
            <td><pre>@FunctionalInterface<br>public interface MyFunctionalInterface {<br>    void execute();<br>}</pre></td>
        </tr>
        <tr>
          <th class="texto6Copy2">Question</th>
          <th class="texto6Copy2">Answer</th>
          <th class="texto6Copy2">Advantages</th>
          <th class="texto6Copy2">Disadvantages</th>
          <th class="texto6Copy2">Use Cases</th>
          <th class="texto6Copy2">Java Code Example</th>
        </tr>
        <tr>
            <td class="texto2">Can functional interfaces have multiple methods?</td>
            <td>Yes, but they must have exactly one abstract method to be considered a functional interface. Default and static methods don't count.</td>
            <td>Multiple default methods are allowed.</td>
            <td>If multiple abstract methods are added, it ceases to be a functional interface, violating Java's standards.</td>
            <td>Custom handlers where the interface provides default behavior for some methods and abstract for others.</td>
            <td><pre>@FunctionalInterface<br>public interface MyInterface {<br>    void method1();<br>    default void method2() { System.out.println("Default method"); }<br>}</pre></td>
        </tr>
        <tr>
            <td rowspan="4" class="solo_borde1"><b>Optional</b></td>
            <th class="texto6Copy2">Question</th>
            <th class="texto6Copy2">Answer</th>
            <th class="texto6Copy2">Advantages</th>
            <th class="texto6Copy2">Disadvantages</th>
            <th class="texto6Copy2">Use Cases</th>
            <th class="texto6Copy2">Java Code Example</th>
        </tr>
        <tr>
            <td class="texto2">How do you create an `Optional`?</td>
            <td>You can use `Optional.of()`, `Optional.ofNullable()`, or `Optional.empty()` to create an Optional instance.</td>
            <td>Provides a clear way to handle missing values without relying on `null`.</td>
            <td>Requires additional method chaining for handling absence of value.</td>
            <td>Checking and handling configuration options, responses from services, etc.</td>
            <td><pre>Optional&lt;String&gt; empty = Optional.empty();<br>System.out.println(empty.orElse("Default"));</pre></td>
        </tr>
        <tr>
          <th class="texto6Copy2">Question</th>
          <th class="texto6Copy2">Answer</th>
          <th class="texto6Copy2">Advantages</th>
          <th class="texto6Copy2">Disadvantages</th>
          <th class="texto6Copy2">Use Cases</th>
          <th class="texto6Copy2">Java Code Example</th>
        </tr>
        <tr>
            <td class="texto2">How do you avoid `NoSuchElementException` with `Optional`?</td>
            <td>Use `Optional.isPresent()` or `Optional.orElse()` to handle cases where the value might be absent, avoiding exceptions.</td>
            <td>Helps ensure safer operations with defaults or alternate behavior when the value is absent.</td>
            <td>Overuse may lead to verbose or overcomplicated code.</td>
            <td>Checking if a value exists in a configuration setting, optional database return values, etc.</td>
            <td><pre>Optional&lt;String&gt; name = Optional.empty();<br>name.ifPresentOrElse(System.out::println, () -&gt; System.out.println("No name"));</pre></td>
        </tr>
    </tbody>
</table>
<h2 align="left" class="style1">Set 1</h2>
<ol class="style1">
        <li>
            <strong>What is a lambda expression in Java?</strong><br>
            <p><em>Answer:</em> A lambda expression is a way to provide clear and concise syntax for writing anonymous methods (implementations of functional interfaces). It allows you to express instances of single-method interfaces (functional interfaces) in a much simpler way. The general syntax is: 
            <code>(parameters) -> expression</code>.</p>
        </li>
        <li>
            <strong>What is the purpose of the `Optional` class in Java?</strong><br>
            <p><em>Answer:</em> The `Optional` class is used to represent a value that may or may not be present. It helps to avoid `NullPointerException` by providing methods to handle the absence of a value in a functional way, using methods like `ifPresent()`, `orElse()`, and `map()`.</p>
        </li>
        <li>
            <strong>What is a functional interface in Java?</strong><br>
            <p><em>Answer:</em> A functional interface in Java is an interface that contains exactly one abstract method. Functional interfaces can have multiple default or static methods. They are used primarily to represent lambda expressions or method references. The `@FunctionalInterface` annotation is used to indicate a functional interface.</p>
        </li>
        <li>
            <strong>How can you use a lambda expression to filter a list of integers in Java?</strong><br>
            <p><em>Answer:</em> You can use a lambda expression with Java Streams to filter a list of integers. For example:
            <pre>List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
            numbers.stream()
                   .filter(n -> n % 2 == 0)
                   .forEach(System.out::println);</pre>
            This will print the even numbers in the list.</p>
        </li>
        <li>
            <strong>What are the benefits of using Java Streams?</strong><br>
            <p><em>Answer:</em> Java Streams provide a high-level abstraction for working with sequences of data. Benefits include:
          <ul>
                    <li>Concise code using operations like map, filter, reduce, etc.</li>
                    <li>Support for parallel processing, making it easier to work with large datasets efficiently.</li>
                    <li>Functional programming style, improving readability and maintainability of code.</li>
          </ul>
            </p>
        </li>
        <li>
            <strong>What is the difference between `map()` and `flatMap()` in Java Streams?</strong><br>
            <p><em>Answer:</em> 
          <ul>
                    <li>The `map()` method transforms each element in the stream to another object.</li>
                    <li>The `flatMap()` method is used when you want to transform each element into multiple elements (i.e., a stream of streams) and then flatten the result into a single stream.</li>
          </ul>
                Example:
                <pre>List<String> words = Arrays.asList("apple", "banana", "cherry");
                words.stream()
                     .map(String::toUpperCase)
                     .forEach(System.out::println);</pre>
                <pre>List<List<String>> listOfLists = Arrays.asList(Arrays.asList("apple", "banana"), Arrays.asList("cherry"));
                listOfLists.stream()
                           .flatMap(Collection::stream)
                           .forEach(System.out::println);</pre>
            </p>
        </li>
        <li>
            <strong>What is the purpose of the `filter()` method in Java Streams?</strong><br>
            <p><em>Answer:</em> The `filter()` method in Java Streams is used to exclude elements from a stream based on a given predicate (a condition). It returns a new stream that contains only the elements that satisfy the condition.</p>
        </li>
        <li>
            <strong>How can you create a stream from a collection in Java?</strong><br>
            <p><em>Answer:</em> You can create a stream from a collection using the `stream()` method. For example:
            <pre>List<Integer> numbers = Arrays.asList(1, 2, 3, 4);
            Stream<Integer> numberStream = numbers.stream();</pre>
            You can then use this stream to perform operations like filtering or mapping.</p>
        </li>
        <li>
            <strong>What is the `forEach()` method in Java Streams?</strong><br>
            <p><em>Answer:</em> The `forEach()` method is used to iterate over all the elements in a stream and perform an action on each element. It is a terminal operation and is often used for side-effect operations, such as printing elements.</p>
        </li>
    </ol>
    <h1>Java 8+ Features (Streams, Lambda, Functional Interfaces, Optional) - Questions & Answers</h1>
    <h2>Set 2</h2>
    <ol>
      <li> <strong>What is the `reduce()` method in Java Streams?</strong><br>
          <p><em>Answer:</em> The `reduce()` method in Java Streams is a terminal operation that takes a binary operator and returns a single value by combining all the elements of the stream. It is often used for aggregation operations such as sum, max, or concatenation.</p>
      </li>
      <li> <strong>What is the purpose of the `Optional.orElse()` method?</strong><br>
          <p><em>Answer:</em> The `orElse()` method in the `Optional` class is used to return the value contained within the `Optional` if present, or a default value if it is empty. This helps avoid `NullPointerException` by providing a fallback value.</p>
      </li>
      <li> <strong>What is the `map()` function in the context of `Optional` in Java?</strong><br>
          <p><em>Answer:</em> The `map()` function in `Optional` is used to transform the value inside the `Optional` if it is present. If the `Optional` is empty, `map()` returns an empty `Optional` instead of applying the transformation.</p>
      </li>
      <li> <strong>What is method reference in Java?</strong><br>
          <p><em>Answer:</em> A method reference is a shorthand notation of a lambda expression that calls a method. It uses the `::` operator to refer to a method by its name. For example, <code>list.forEach(System.out::println);</code> is a method reference equivalent to <code>list.forEach(item -> System.out.println(item));</code></p>
      </li>
      <li> <strong>How do you create a stream from an array in Java?</strong><br>
          <p><em>Answer:</em> You can create a stream from an array using the `Arrays.stream()` method. For example:
          <pre>String[] words = {"apple", "banana", "cherry"};
            Stream<String> wordStream = Arrays.stream(words);</pre>
        This creates a stream that can be processed with stream operations.
        </p>
      </li>
      <li> <strong>What is the difference between `Optional.get()` and `Optional.orElse()`?</strong><br>
          <p><em>Answer:</em> The `get()` method retrieves the value contained in the `Optional` if it is present, but throws a `NoSuchElementException` if the `Optional` is empty. The `orElse()` method provides a fallback value if the `Optional` is empty, making it safer to use in most cases.</p>
      </li>
      <li> <strong>How do you use a `Consumer` functional interface in Java?</strong><br>
          <p><em>Answer:</em> The `Consumer` interface represents an operation that accepts a single input argument and returns no result. It is often used with the `forEach()` method in streams to perform actions on each element. For example:
          <pre>List<String> words = Arrays.asList("apple", "banana", "cherry");
            words.forEach(word -> System.out.println(word));</pre>
        </p>
      </li>
      <li> <strong>What is the use of `Collectors.toList()` in Java Streams?</strong><br>
          <p><em>Answer:</em> The `Collectors.toList()` is a collector used in Java Streams to accumulate the elements of the stream into a new `List`. It is commonly used in conjunction with the `collect()` method to gather the results of a stream operation into a collection.</p>
      </li>
      <li> <strong>What is the `Supplier` functional interface in Java?</strong><br>
          <p><em>Answer:</em> The `Supplier` functional interface represents a function that takes no arguments and returns a result. It is often used when you need to generate values, such as creating a new object. For example:
          <pre>Supplier<String> stringSupplier = () -> "Hello, World!";
            System.out.println(stringSupplier.get());</pre>
        </p>
      </li>
      <li> <strong>How does `Stream.sorted()` work in Java?</strong><br>
          <p><em>Answer:</em> The `sorted()` method in Java Streams is used to sort the elements of a stream. It returns a stream consisting of the elements of the original stream, sorted according to their natural order or by a provided comparator.</p>
      </li>
    </ol>
    <h1>Java 8+ Features (Streams, Lambda, Functional Interfaces, Optional) - Questions & Answers</h1>
    <h2>Set 3</h2>
    <ol>
      <li> <strong>What does the `Optional.ifPresent()` method do?</strong><br>
          <p><em>Answer:</em> The `ifPresent()` method in `Optional` is used to execute a given action if the value is present. It takes a `Consumer` as an argument and applies it if the `Optional` contains a value, otherwise it does nothing.</p>
      </li>
      <li> <strong>What is the difference between `Optional.isPresent()` and `Optional.ifPresent()`?</strong><br>
          <p><em>Answer:</em> The `isPresent()` method returns a boolean indicating whether the value is present inside the `Optional`. The `ifPresent()` method, on the other hand, accepts a `Consumer` and performs an action if the value is present.</p>
      </li>
      <li> <strong>How do you use `Optional.map()` in Java?</strong><br>
          <p><em>Answer:</em> The `map()` method is used to transform the value inside the `Optional` if it is present. If the value is not present, it returns an empty `Optional`. It takes a `Function` as an argument. For example:
          <pre>Optional<String> name = Optional.of("Java");
            Optional<String> upperCaseName = name.map(String::toUpperCase);</pre>
        </p>
      </li>
      <li> <strong>What is the `Predicate` functional interface in Java?</strong><br>
          <p><em>Answer:</em> The `Predicate` interface represents a function that takes an argument and returns a boolean value. It is often used for filtering or matching elements based on a condition. For example:
          <pre>Predicate<Integer> isEven = n -> n % 2 == 0;</pre>
        </p>
      </li>
      <li> <strong>How do you create a parallel stream in Java?</strong><br>
          <p><em>Answer:</em> You can create a parallel stream by calling the `parallelStream()` method on a collection. A parallel stream can perform operations concurrently, improving performance for large datasets. For example:
          <pre>List<Integer> numbers = Arrays.asList(1, 2, 3, 4);
            numbers.parallelStream()
                   .forEach(System.out::println);</pre>
        </p>
      </li>
      <li> <strong>What is the `BiFunction` interface in Java?</strong><br>
          <p><em>Answer:</em> The `BiFunction` interface is a functional interface that represents a function that accepts two arguments and returns a result. It is commonly used when you need to combine two values to produce a result. For example:
          <pre>BiFunction add = (a, b) -> a + b;</pre>
        </p>
      </li>
      <li> <strong>How do you use the `flatMap()` method with Optional?</strong><br>
          <p><em>Answer:</em> The `flatMap()` method in `Optional` is used to transform the value inside the `Optional` to another `Optional`. It is used when the transformation itself may return an empty `Optional`, and you want to avoid nested Optionals. For example:
          <pre>Optional<String> name = Optional.of("Java");
            Optional<String> upperCaseName = name.flatMap(n -> Optional.of(n.toUpperCase()));</pre>
        </p>
      </li>
      <li> <strong>What is the `Function` functional interface in Java?</strong><br>
          <p><em>Answer:</em> The `Function` interface represents a function that takes one argument and produces a result. It is commonly used for transformations and operations on elements. For example:
          <pre>Function stringLength = s -> s.length();</pre>
        </p>
      </li>
      <li> <strong>What is the use of `Collectors.joining()` in Java Streams?</strong><br>
          <p><em>Answer:</em> The `Collectors.joining()` method is a collector used to concatenate the elements of a stream into a single string. You can also specify delimiters, prefixes, and suffixes. For example:
          <pre>List<String> words = Arrays.asList("apple", "banana", "cherry");
            String result = words.stream()
                                 .collect(Collectors.joining(", ", "[", "]"));
            System.out.println(result);</pre>
        </p>
      </li>
    </ol>
    <h1>Java 8+ Features (Streams, Lambda, Functional Interfaces, Optional) - Questions & Answers</h1>
    <h2>Set 4</h2>
    <ol>
      <li> <strong>What is the `Optional.orElseGet()` method in Java?</strong><br>
          <p><em>Answer:</em> The `orElseGet()` method is used to provide a fallback value for an empty `Optional`. Unlike `orElse()`, which takes a fixed value, `orElseGet()` takes a `Supplier` that is only invoked if the `Optional` is empty.</p>
      </li>
      <li> <strong>How do you chain multiple `Optional` methods?</strong><br>
          <p><em>Answer:</em> You can chain multiple `Optional` methods like `map()`, `flatMap()`, or `filter()` to perform transformations or checks sequentially. For example:
          <pre>Optional<String> name = Optional.of("Java");
            Optional<String> upperName = name.map(String::toUpperCase)
                                           .filter(n -> n.startsWith("J"));</pre>
        </p>
      </li>
      <li> <strong>What is the `Comparator.comparing()` method in Java?</strong><br>
          <p><em>Answer:</em> The `Comparator.comparing()` method is a static method in the `Comparator` interface used to create a comparator based on a key extracted from the objects being compared. It is often used for sorting. For example:
          <pre>Comparator<String> byLength = Comparator.comparing(String::length);</pre>
        </p>
      </li>
      <li> <strong>How does the `Stream.forEach()` method work?</strong><br>
          <p><em>Answer:</em> The `forEach()` method in a stream is a terminal operation that iterates over each element of the stream and applies a specified action (e.g., printing or modifying the element). It is commonly used for side effects. For example:
          <pre>List<String> words = Arrays.asList("apple", "banana", "cherry");
            words.stream().forEach(System.out::println);</pre>
        </p>
      </li>
      <li> <strong>What is the `Stream.anyMatch()` method in Java?</strong><br>
          <p><em>Answer:</em> The `anyMatch()` method in a stream returns `true` if any element of the stream satisfies the given predicate. It is a short-circuiting operation, meaning it stops as soon as it finds a matching element.</p>
      </li>
      <li> <strong>What is the `Stream.allMatch()` method in Java?</strong><br>
          <p><em>Answer:</em> The `allMatch()` method in a stream returns `true` if all elements in the stream satisfy the given predicate. It is a short-circuiting operation that stops as soon as a non-matching element is found.</p>
      </li>
      <li> <strong>What is the difference between `map()` and `flatMap()` in Java Streams?</strong><br>
          <p><em>Answer:</em> The `map()` method applies a function to each element of the stream and returns a new stream with transformed elements. The `flatMap()` method, on the other hand, applies a function that returns a stream itself and flattens the results into a single stream. It is used when the transformation function produces a stream of values.</p>
      </li>
      <li> <strong>What is the `Optional.filter()` method in Java?</strong><br>
          <p><em>Answer:</em> The `filter()` method in `Optional` is used to check if the value inside the `Optional` satisfies a given predicate. If the value is present and matches the predicate, it is returned wrapped in the `Optional`; otherwise, an empty `Optional` is returned.</p>
      </li>
      <li> <strong>How do you use `Optional.empty()` in Java?</strong><br>
          <p><em>Answer:</em> The `Optional.empty()` method creates an empty `Optional` instance. It is often used to represent the absence of a value without using `null`. For example:
          <pre>Optional<String> emptyName = Optional.empty();</pre>
        </p>
      </li>
      <li> <strong>What does `Stream.collect()` do in Java?</strong><br>
          <p><em>Answer:</em> The `collect()` method is a terminal operation that transforms the elements of a stream into a different form, such as a collection (e.g., `List`, `Set`, `Map`). It takes a `Collector` as an argument. For example:
          <pre>List<String> collected = stream.collect(Collectors.toList());</pre>
        </p>
      </li>
    </ol>
    <h1>Java 8+ Features (Streams, Lambda, Functional Interfaces, Optional) - Questions & Answers</h1>
    <h2>Set 5</h2>
    <ol>
      <li> <strong>What is the `Stream.reduce()` method used for in Java?</strong><br>
          <p><em>Answer:</em> The `reduce()` method is a terminal operation that performs a reduction on the elements of a stream using an associative accumulation function and returns an `Optional` containing the reduced value. For example, summing the elements of a stream:
          <pre>Optional<Integer> sum = stream.reduce((a, b) -> a + b);</pre>
        </p>
      </li>
      <li> <strong>What is the `Optional.orElse()` method in Java?</strong><br>
          <p><em>Answer:</em> The `orElse()` method provides a fallback value when the `Optional` is empty. It returns the value inside the `Optional` if present, otherwise it returns the specified default value. For example:
          <pre>String name = optionalName.orElse("Unknown");</pre>
        </p>
      </li>
      <li> <strong>What is the `Function.andThen()` method in Java?</strong><br>
          <p><em>Answer:</em> The `andThen()` method is used to chain two functions. It first applies the current function, then applies the second function to the result of the first. For example:
          <pre>Function multiplyBy2 = x -> x * 2;
            Function add3 = x -> x + 3;
            Function combined = multiplyBy2.andThen(add3);</pre>
        </p>
      </li>
      <li> <strong>What does the `Stream.peek()` method do?</strong><br>
          <p><em>Answer:</em> The `peek()` method allows you to perform an action on each element of the stream without consuming the stream. It is often used for debugging or logging intermediate results. However, it is not recommended for production code due to its side effects.</p>
      </li>
      <li> <strong>How do you use `Optional.flatMap()` in Java?</strong><br>
          <p><em>Answer:</em> The `flatMap()` method is used to transform the value inside the `Optional` into another `Optional`. It is useful when the transformation may result in an empty `Optional`, and you want to avoid nested `Optional` instances. For example:
          <pre>Optional<String> name = Optional.of("Java");
            Optional<String> upperName = name.flatMap(n -> Optional.of(n.toUpperCase()));</pre>
        </p>
      </li>
      <li> <strong>What is the `Stream.sorted()` method used for?</strong><br>
          <p><em>Answer:</em> The `sorted()` method in a stream is used to sort the elements of the stream. It can be used with the natural ordering or a custom comparator. For example:
          <pre>stream.sorted(Comparator.naturalOrder()).forEach(System.out::println);</pre>
        </p>
      </li>
      <li> <strong>How can you use `Stream.map()` with custom objects?</strong><br>
          <p><em>Answer:</em> The `map()` method can be used with custom objects by providing a function that transforms each object to another value. For example, to extract the `name` property from a list of objects:
          <pre>List<Person> persons = Arrays.asList(new Person("John"), new Person("Jane"));
            List<String> names = persons.stream()
                                       .map(Person::getName)
                                       .collect(Collectors.toList());</pre>
        </p>
      </li>
      <li> <strong>What is the purpose of the `Stream.distinct()` method?</strong><br>
          <p><em>Answer:</em> The `distinct()` method is used to eliminate duplicate elements in a stream. It returns a stream containing only the distinct elements based on their `equals()` method. For example:
          <pre>List<Integer> numbers = Arrays.asList(1, 2, 2, 3, 4);
            numbers.stream().distinct().forEach(System.out::println);</pre>
        </p>
      </li>
      <li> <strong>What is a functional interface in Java?</strong><br>
          <p><em>Answer:</em> A functional interface is an interface that has exactly one abstract method. It can have multiple default or static methods, but only one abstract method. These interfaces are used primarily as the basis for lambda expressions and method references. Examples include `Runnable`, `Callable`, `Comparator`, and `Predicate`.</p>
      </li>
    </ol>
    <p>&nbsp;</p>
    <h1>Java 8+ Features (Streams, Lambda, Functional Interfaces, Optional) - Questions & Answers</h1>
    <h2>Set 6</h2>
    <ol>
      <li> <strong>What is the `Optional.map()` method in Java?</strong><br>
          <p><em>Answer:</em> The `map()` method in `Optional` is used to apply a function to the value inside the `Optional` if present, and return a new `Optional` containing the transformed value. If the `Optional` is empty, it returns an empty `Optional`. For example:
          <pre>Optional<String> name = Optional.of("John");
            Optional<String> upperName = name.map(String::toUpperCase);</pre>
        </p>
      </li>
      <li> <strong>What is a `Predicate` functional interface in Java?</strong><br>
          <p><em>Answer:</em> The `Predicate` functional interface represents a boolean-valued function that takes one argument. It is used primarily in filter operations. Example:
          <pre>Predicate<String> isNotEmpty = s -> !s.isEmpty();</pre>
        </p>
      </li>
      <li> <strong>How do you create a lambda expression that accepts two parameters?</strong><br>
          <p><em>Answer:</em> You can create a lambda expression with two parameters by using the following syntax:
          <pre>(param1, param2) -> { /* body */ }</pre>
        Example:
        <pre>BiFunction sum = (a, b) -> a + b;</pre>
        </p>
      </li>
      <li> <strong>What is the `Stream.flatMap()` method in Java?</strong><br>
          <p><em>Answer:</em> The `flatMap()` method is used to flatten a stream of streams into a single stream. It is often used when the transformation function returns a stream and you want to merge them into one. Example:
          <pre>Stream<List<Integer>> listStream = Stream.of(Arrays.asList(1, 2), Arrays.asList(3, 4));
            listStream.flatMap(List::stream).forEach(System.out::println);</pre>
        </p>
      </li>
      <li> <strong>What does the `Optional.isPresent()` method do?</strong><br>
          <p><em>Answer:</em> The `isPresent()` method returns `true` if the `Optional` contains a non-null value, and `false` if it is empty. Example:
          <pre>Optional<String> name = Optional.of("John");
            if (name.isPresent()) {
                System.out.println(name.get());
            }</pre>
        </p>
      </li>
      <li> <strong>How does the `Optional.ifPresent()` method work?</strong><br>
          <p><em>Answer:</em> The `ifPresent()` method in `Optional` is used to perform an action on the value inside the `Optional` if it is present. If the `Optional` is empty, the action is not performed. Example:
          <pre>Optional<String> name = Optional.of("John");
            name.ifPresent(n -> System.out.println("Name: " + n));</pre>
        </p>
      </li>
      <li> <strong>How can you use `Stream.filter()` in Java?</strong><br>
          <p><em>Answer:</em> The `filter()` method is used to select elements from a stream based on a given predicate. It returns a new stream with only those elements that satisfy the predicate. Example:
          <pre>List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
            List<Integer> evenNumbers = numbers.stream().filter(n -> n % 2 == 0).collect(Collectors.toList());</pre>
        </p>
      </li>
      <li> <strong>What is the purpose of `Stream.limit()` in Java?</strong><br>
          <p><em>Answer:</em> The `limit()` method is used to truncate a stream to a specified size, returning a new stream that contains the first `n` elements. Example:
          <pre>List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
            List<Integer> firstThree = numbers.stream().limit(3).collect(Collectors.toList());</pre>
        </p>
      </li>
      <li> <strong>What is the `Function.identity()` method in Java?</strong><br>
          <p><em>Answer:</em> The `Function.identity()` method returns a function that always returns its input argument. It is commonly used in operations like `Collectors.toMap()`. Example:
          <pre>Function identity = Function.identity();
            String result = identity.apply("Hello");</pre>
        </p>
      </li>
      <li> <strong>How do you use `Stream.concat()` in Java?</strong><br>
          <p><em>Answer:</em> The `concat()` method is used to concatenate two streams into one. It returns a new stream containing the elements from both streams. Example:
          <pre>Stream<String> stream1 = Stream.of("Java", "Python");
            Stream<String> stream2 = Stream.of("C++", "JavaScript");
            Stream<String> combinedStream = Stream.concat(stream1, stream2);
            combinedStream.forEach(System.out::println);</pre>
        </p>
      </li>
    </ol>
    <h1>Java 8+ Features (Streams, Lambda, Functional Interfaces, Optional) - Questions & Answers</h1>
    <h2>Set 7</h2>
    <ol>
      <li> <strong>What is the difference between `Stream.map()` and `Stream.flatMap()` in Java?</strong><br>
          <p><em>Answer:</em> The `map()` method is used to transform each element of the stream into a new form, whereas `flatMap()` is used when each element of the stream can be mapped to another stream, and those streams are merged into a single stream. For example:
          <pre>Stream<String> words = Stream.of("Hello", "World");
            words.map(String::toUpperCase).forEach(System.out::println);</pre>
                <pre>Stream<List<String>> nestedWords = Stream.of(Arrays.asList("Java", "Python"), Arrays.asList("C++"));
            nestedWords.flatMap(List::stream).forEach(System.out::println);</pre>
        </p>
      </li>
      <li> <strong>What is the use of `Supplier` functional interface in Java?</strong><br>
          <p><em>Answer:</em> The `Supplier` functional interface represents a supplier of results. It does not take any input and returns a result. It is typically used in scenarios where you need to generate or supply data, like in `Stream.generate()`. Example:
          <pre>Supplier<Double> randomValue = () -> Math.random();
            System.out.println(randomValue.get());</pre>
        </p>
      </li>
      <li> <strong>What is the `Stream.collect()` method in Java?</strong><br>
          <p><em>Answer:</em> The `collect()` method is a terminal operation that transforms the elements of a stream into a different form, usually a collection like a `List`, `Set`, or `Map`. It takes a `Collector` as an argument. Example:
          <pre>List<String> words = Stream.of("Java", "Python", "C++")
                                        .collect(Collectors.toList());</pre>
        </p>
      </li>
      <li> <strong>How can you create a stream from an array in Java?</strong><br>
          <p><em>Answer:</em> You can create a stream from an array using the `Arrays.stream()` method or the `Stream.of()` method. Example:
          <pre>String[] languages = {"Java", "Python", "C++"};
            Stream<String> stream = Arrays.stream(languages);</pre>
        </p>
      </li>
      <li> <strong>What is the `Optional.orElseGet()` method in Java?</strong><br>
          <p><em>Answer:</em> The `orElseGet()` method provides a fallback value using a supplier when the `Optional` is empty. It is different from `orElse()` because `orElseGet()` takes a supplier and only computes the value if the `Optional` is empty. Example:
          <pre>Optional<String> name = Optional.empty();
            String defaultName = name.orElseGet(() -> "Unknown");</pre>
        </p>
      </li>
      <li> <strong>What is the purpose of `Stream.peek()` method in Java?</strong><br>
          <p><em>Answer:</em> The `peek()` method is an intermediate operation used to inspect or perform actions on each element of the stream without modifying it. It is often used for debugging or logging purposes. Example:
          <pre>List<Integer> numbers = Arrays.asList(1, 2, 3, 4);
            numbers.stream()
                   .peek(System.out::println)
                   .collect(Collectors.toList());</pre>
        </p>
      </li>
      <li> <strong>What is the `Optional.ifPresentOrElse()` method in Java?</strong><br>
          <p><em>Answer:</em> The `ifPresentOrElse()` method allows you to perform an action if the value is present, or provide a fallback action if the value is empty. It is useful for performing two actions based on the presence of a value. Example:
          <pre>Optional<String> name = Optional.of("Java");
            name.ifPresentOrElse(
                n -> System.out.println("Name: " + n),
                () -> System.out.println("No name available")
            );</pre>
        </p>
      </li>
      <li> <strong>How does the `Stream.allMatch()` method work?</strong><br>
          <p><em>Answer:</em> The `allMatch()` method is a terminal operation that checks whether all elements of the stream satisfy the given predicate. It returns `true` if all elements match, otherwise `false`. Example:
          <pre>List<Integer> numbers = Arrays.asList(2, 4, 6);
            boolean allEven = numbers.stream().allMatch(n -> n % 2 == 0);</pre>
        </p>
      </li>
      <li> <strong>What is the `Stream.forEachOrdered()` method in Java?</strong><br>
          <p><em>Answer:</em> The `forEachOrdered()` method is used to ensure that elements are processed in the order they appear in the stream, especially when using parallel streams. Example:
          <pre>List<Integer> numbers = Arrays.asList(1, 2, 3, 4);
            numbers.parallelStream().forEachOrdered(System.out::println);</pre>
        </p>
      </li>
    </ol>
    <p>&nbsp;</p>
    <h1>Java 8+ Features (Streams, Lambda, Functional Interfaces, Optional) - Questions & Answers</h1>
    <h2>Set 8</h2>
    <ol>
      <li> <strong>What is a functional interface in Java?</strong><br>
          <p><em>Answer:</em> A functional interface in Java is an interface that has exactly one abstract method. It may have multiple default or static methods. Functional interfaces are used as the basis for lambda expressions. Example:
          <pre>@FunctionalInterface
            public interface MyFunctionalInterface {
                void performAction();
            }</pre>
        </p>
      </li>
      <li> <strong>What is the `Optional.orElse()` method in Java?</strong><br>
          <p><em>Answer:</em> The `orElse()` method returns the value if present; otherwise, it returns the default value passed as an argument. Example:
          <pre>Optional<String> name = Optional.of("Java");
            String result = name.orElse("Unknown");</pre>
        </p>
      </li>
      <li> <strong>How do you create a `Stream` from a `List` in Java?</strong><br>
          <p><em>Answer:</em> You can create a `Stream` from a `List` using the `stream()` method. Example:
          <pre>List<String> list = Arrays.asList("Java", "Python", "C++");
            Stream<String> stream = list.stream();</pre>
        </p>
      </li>
      <li> <strong>What does the `Optional.isPresent()` method do?</strong><br>
          <p><em>Answer:</em> The `isPresent()` method checks if a value is present in the `Optional` object. It returns `true` if the value is present, otherwise `false`. Example:
          <pre>Optional<String> name = Optional.of("Java");
            boolean isPresent = name.isPresent();</pre>
        </p>
      </li>
      <li> <strong>What is the `Stream.distinct()` method used for in Java?</strong><br>
          <p><em>Answer:</em> The `distinct()` method is an intermediate operation that filters out duplicate elements from a stream. It ensures that only unique elements are present in the resulting stream. Example:
          <pre>Stream<Integer> numbers = Stream.of(1, 2, 3, 1, 2);
            numbers.distinct().forEach(System.out::println);</pre>
        </p>
      </li>
      <li> <strong>What is the purpose of `Stream.filter()` method?</strong><br>
          <p><em>Answer:</em> The `filter()` method is an intermediate operation that allows you to filter elements from a stream based on a condition provided by a predicate. Example:
          <pre>List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
            numbers.stream().filter(n -> n % 2 == 0).forEach(System.out::println);</pre>
        </p>
      </li>
      <li> <strong>How can you create an immutable `List` using Java 8?</strong><br>
          <p><em>Answer:</em> You can create an immutable list using `List.of()` in Java 8. Example:
          <pre>List<String> immutableList = List.of("Java", "Python", "C++");</pre>
        </p>
      </li>
      <li> <strong>What is the `Stream.reduce()` method in Java?</strong><br>
          <p><em>Answer:</em> The `reduce()` method is a terminal operation that performs a reduction on the elements of the stream using an associative accumulation function and returns an `Optional`. Example:
          <pre>List<Integer> numbers = Arrays.asList(1, 2, 3, 4);
            int sum = numbers.stream().reduce(0, Integer::sum);</pre>
        </p>
      </li>
      <li> <strong>What is the `Function` functional interface in Java?</strong><br>
          <p><em>Answer:</em> The `Function` interface represents a function that takes one argument and returns a result. It is commonly used in `Stream.map()` for transformations. Example:
          <pre>Function lengthFunction = str -> str.length();
            System.out.println(lengthFunction.apply("Java"));</pre>
        </p>
      </li>
      <li> <strong>What is the `Optional.get()` method in Java?</strong><br>
          <p><em>Answer:</em> The `get()` method is used to retrieve the value contained in the `Optional` object. It throws `NoSuchElementException` if the value is not present. Example:
          <pre>Optional<String> name = Optional.of("Java");
            String value = name.get();</pre>
        </p>
      </li>
    </ol>
    <h1>Java 8+ Features (Streams, Lambda, Functional Interfaces, Optional) - Questions & Answers</h1>
    <h2>Set 9</h2>
    <ol>
      <li> <strong>What is the `Stream.forEach()` method in Java?</strong><br>
          <p><em>Answer:</em> The `forEach()` method is a terminal operation that performs the given action for each element of the stream. Example:
          <pre>List<String> list = Arrays.asList("Java", "Python", "C++");
            list.stream().forEach(System.out::println);</pre>
        </p>
      </li>
      <li> <strong>What does `Optional.ifPresent()` do in Java?</strong><br>
          <p><em>Answer:</em> The `ifPresent()` method performs the given action if a value is present, otherwise does nothing. Example:
          <pre>Optional<String> name = Optional.of("Java");
            name.ifPresent(System.out::println);</pre>
        </p>
      </li>
      <li> <strong>What is the purpose of `Stream.collect()` method in Java?</strong><br>
          <p><em>Answer:</em> The `collect()` method is a terminal operation that transforms the elements of a stream into a different form, usually a collection like a list or a map. Example:
          <pre>List<Integer> numbers = Arrays.asList(1, 2, 3, 4);
            List<Integer> evenNumbers = numbers.stream().filter(n -> n % 2 == 0).collect(Collectors.toList());</pre>
        </p>
      </li>
      <li> <strong>What is the `Optional.orElseThrow()` method in Java?</strong><br>
          <p><em>Answer:</em> The `orElseThrow()` method returns the value if present, otherwise throws an exception provided by the caller. Example:
          <pre>Optional<String> name = Optional.empty();
            String value = name.orElseThrow(() -> new IllegalArgumentException("No value present"));</pre>
        </p>
      </li>
      <li> <strong>How do you use `Stream.map()` to transform a stream?</strong><br>
          <p><em>Answer:</em> The `map()` method is an intermediate operation that transforms each element of the stream using a given function. Example:
          <pre>List<String> words = Arrays.asList("java", "python", "c++");
            List<String> uppercased = words.stream().map(String::toUpperCase).collect(Collectors.toList());</pre>
        </p>
      </li>
      <li> <strong>What is the `Stream.flatMap()` method used for in Java?</strong><br>
          <p><em>Answer:</em> The `flatMap()` method is an intermediate operation that flattens a stream of streams into a single stream. Example:
          <pre>List<List<String>> listOfLists = Arrays.asList(Arrays.asList("a", "b"), Arrays.asList("c", "d"));
            List<String> flatList = listOfLists.stream().flatMap(List::stream).collect(Collectors.toList());</pre>
        </p>
      </li>
      <li> <strong>How does the `Stream.peek()` method work in Java?</strong><br>
          <p><em>Answer:</em> The `peek()` method is an intermediate operation that allows you to perform an action on each element of the stream without modifying the stream itself. It is mainly used for debugging. Example:
          <pre>List<Integer> numbers = Arrays.asList(1, 2, 3, 4);
            numbers.stream().peek(n -> System.out.println("Number: " + n)).collect(Collectors.toList());</pre>
        </p>
      </li>
      <li> <strong>What is the difference between `map()` and `flatMap()` in Java?</strong><br>
          <p><em>Answer:</em> The `map()` method is used to transform each element of the stream into another form, whereas `flatMap()` is used to flatten a stream of collections into a single stream. Example:
          <pre>List<String> words = Arrays.asList("java", "python", "c++");
            Stream<String> mapped = words.stream().map(String::toUpperCase);
            List<List<String>> listOfLists = Arrays.asList(Arrays.asList("a", "b"), Arrays.asList("c", "d"));
            Stream<String> flattened = listOfLists.stream().flatMap(List::stream);</pre>
        </p>
      </li>
      <li> <strong>What does `Stream.anyMatch()` do in Java?</strong><br>
          <p><em>Answer:</em> The `anyMatch()` method is a short-circuiting terminal operation that checks if any element of the stream satisfies the given predicate. It returns `true` if any element matches, otherwise `false`. Example:
          <pre>List<Integer> numbers = Arrays.asList(1, 2, 3, 4);
            boolean result = numbers.stream().anyMatch(n -> n > 3);</pre>
        </p>
      </li>
      <li> <strong>What is the `Optional.map()` method in Java?</strong><br>
          <p><em>Answer:</em> The `map()` method in `Optional` allows you to transform the value contained inside the `Optional` if it is present, and returns a new `Optional`. Example:
          <pre>Optional<String> name = Optional.of("Java");
            Optional<String> uppercased = name.map(String::toUpperCase);</pre>
        </p>
      </li>
    </ol>
    <h1>Java 8+ Features (Streams, Lambda, Functional Interfaces, Optional) - Questions & Answers</h1>
    <h2>Set 10</h2>
    <ol>
      <li> <strong>What is the purpose of `Stream.reduce()` in Java?</strong><br>
          <p><em>Answer:</em> The `reduce()` method is a terminal operation that performs a reduction on the elements of the stream using an associative accumulation function and returns an `Optional` value. Example:
          <pre>List<Integer> numbers = Arrays.asList(1, 2, 3, 4);
            int sum = numbers.stream().reduce(0, Integer::sum);</pre>
        </p>
      </li>
      <li> <strong>How does the `Optional.orElse()` method work in Java?</strong><br>
          <p><em>Answer:</em> The `orElse()` method returns the value contained in the `Optional` if it is present, otherwise it returns the provided default value. Example:
          <pre>Optional<String> name = Optional.ofNullable(null);
            String result = name.orElse("Default Name");</pre>
        </p>
      </li>
      <li> <strong>What is a `Supplier` functional interface in Java?</strong><br>
          <p><em>Answer:</em> A `Supplier` is a functional interface that represents a function that supplies a value of a certain type without taking any arguments. Example:
          <pre>Supplier<String> supplier = () -> "Hello, World!";
            String message = supplier.get();</pre>
        </p>
      </li>
      <li> <strong>How do you use `Optional.filter()` in Java?</strong><br>
          <p><em>Answer:</em> The `filter()` method allows you to apply a predicate to an `Optional`. If the value is present and satisfies the predicate, the `Optional` is returned, otherwise, an empty `Optional` is returned. Example:
          <pre>Optional<Integer> number = Optional.of(10);
            Optional<Integer> result = number.filter(n -> n > 5);</pre>
        </p>
      </li>
      <li> <strong>What is a `Function` functional interface in Java?</strong><br>
          <p><em>Answer:</em> A `Function` is a functional interface that represents a function that accepts one argument and produces a result. Example:
          <pre>Function square = x -> x * x;
            int result = square.apply(5);</pre>
        </p>
      </li>
      <li> <strong>What is the difference between `map()` and `flatMap()` when used with `Optional`?</strong><br>
          <p><em>Answer:</em> When using `Optional`, `map()` transforms the value inside the `Optional` if present, whereas `flatMap()` can be used if the transformation function itself returns an `Optional`. Example:
          <pre>Optional<String> name = Optional.of("Java");
            Optional<String> uppercased = name.map(String::toUpperCase);
            Optional<Optional<String>> result = name.flatMap(n -> Optional.of(n.toUpperCase()));</pre>
        </p>
      </li>
      <li> <strong>What is a `Predicate` functional interface in Java?</strong><br>
          <p><em>Answer:</em> A `Predicate` is a functional interface that represents a function that takes one argument and returns a boolean value, typically used for testing conditions. Example:
          <pre>Predicate<Integer> isEven = x -> x % 2 == 0;
            boolean result = isEven.test(4);</pre>
        </p>
      </li>
      <li> <strong>How does `Stream.allMatch()` work in Java?</strong><br>
          <p><em>Answer:</em> The `allMatch()` method is a short-circuiting terminal operation that checks if all elements of the stream satisfy the given predicate. It returns `true` if all elements match, otherwise `false`. Example:
          <pre>List<Integer> numbers = Arrays.asList(2, 4, 6, 8);
            boolean result = numbers.stream().allMatch(n -> n % 2 == 0);</pre>
        </p>
      </li>
      <li> <strong>What is the `Stream.distinct()` method used for in Java?</strong><br>
          <p><em>Answer:</em> The `distinct()` method is an intermediate operation that removes duplicate elements from the stream. Example:
          <pre>List<Integer> numbers = Arrays.asList(1, 1, 2, 3, 3);
            List<Integer> distinctNumbers = numbers.stream().distinct().collect(Collectors.toList());</pre>
        </p>
      </li>
      <li> <strong>What is `Stream.count()` used for in Java?</strong><br>
          <p><em>Answer:</em> The `count()` method is a terminal operation that returns the number of elements in the stream. Example:
          <pre>List<Integer> numbers = Arrays.asList(1, 2, 3, 4);
            long count = numbers.stream().count();</pre>
        </p>
      </li>
    </ol>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
</body>
</html>
