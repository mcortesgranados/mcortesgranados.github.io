<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Java Memory Management (Heap, Stack, GC) - Questions & Answers</title>
<style type="text/css">
<!--
.style1 {font-family: Arial, Helvetica, sans-serif}
-->
</style>
</head>
<body>
    <h1 class="style1">Java Memory Management (Heap, Stack, GC) - Questions & Answers</h1>
    <h2 class="style1">Set 5</h2>
    <ol class="style1">
        <li>
            <strong>What is the difference between "minor GC" and "major GC" in Java?</strong><br>
            <p><em>Answer:</em> 
                <ul>
                    <li>Minor GC is a garbage collection that occurs in the young generation (Eden and survivor spaces). It is typically faster and occurs more frequently.</li>
                    <li>Major GC (or Full GC) happens in the old generation and may involve compaction of the entire heap. It takes longer and happens less frequently.</li>
                </ul>
            </p>
        </li>
        <li>
            <strong>What is the "Permanent Generation" in Java memory management?</strong><br>
            <p><em>Answer:</em> The Permanent Generation (PermGen) was an area of the heap that stored class metadata, method information, and other static data. In Java 8 and later, the PermGen space was replaced by Metaspace, which dynamically resizes based on the application's needs.</p>
        </li>
        <li>
            <strong>What is "Metaspace" in Java, and how does it differ from "PermGen"?</strong><br>
            <p><em>Answer:</em> Metaspace is the memory area in Java that replaced the Permanent Generation (PermGen) in Java 8. Unlike PermGen, which had a fixed size, Metaspace dynamically expands based on the class metadata, reducing the risk of `OutOfMemoryError` related to class loading.</p>
        </li>
        <li>
            <strong>What is the "GC pause" in Java?</strong><br>
            <p><em>Answer:</em> A GC pause is the time during which the application is paused for garbage collection to take place. During this time, the applicationâ€™s execution is suspended while the garbage collector reclaims unused memory.</p>
        </li>
        <li>
            <strong>What is the role of the JVM (Java Virtual Machine) in memory management?</strong><br>
            <p><em>Answer:</em> The JVM manages memory allocation and deallocation for Java programs. It controls memory in the heap (for objects) and stack (for method calls), as well as performing garbage collection to reclaim unused objects.</p>
        </li>
        <li>
            <strong>How does the JVM decide when to perform garbage collection?</strong><br>
            <p><em>Answer:</em> The JVM decides when to perform garbage collection based on several factors, including heap usage, the amount of free memory, and the garbage collection algorithm being used. It may trigger GC when memory usage exceeds a threshold or when a certain amount of objects need to be reclaimed.</p>
        </li>
        <li>
            <strong>What is the role of "weak references" in Java memory management?</strong><br>
            <p><em>Answer:</em> Weak references in Java allow objects to be garbage collected when there are no strong references to them, even if they are still referenced weakly. This is useful for implementing memory-sensitive caches or listeners.</p>
        </li>
        <li>
            <strong>What is "reference counting" in the context of garbage collection?</strong><br>
            <p><em>Answer:</em> Reference counting is a garbage collection technique where each object has a counter that tracks how many references exist to that object. When the reference count drops to zero, the object can be garbage collected. However, reference counting is unable to detect circular references.</p>
        </li>
        <li>
            <strong>What is the role of "finalize()" method in garbage collection?</strong><br>
            <p><em>Answer:</em> The `finalize()` method in Java allows objects to perform cleanup tasks (like releasing resources) before being garbage collected. However, its use is discouraged because it is unpredictable and not guaranteed to be called.</p>
        </li>
        <li>
            <strong>How can you manually suggest the JVM to run garbage collection in Java?</strong><br>
            <p><em>Answer:</em> You can manually suggest garbage collection in Java by calling `System.gc()`. However, this is only a request to the JVM, and the garbage collector may not run immediately or at all, as the JVM itself decides when to run garbage collection based on its internal policies.</p>
        </li>
    </ol>
</body>
</html>
