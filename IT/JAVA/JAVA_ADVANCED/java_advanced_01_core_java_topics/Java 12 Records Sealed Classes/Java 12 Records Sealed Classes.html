<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Untitled Document</title>
<style type="text/css">
<!--
.style1 {font-family: Arial, Helvetica, sans-serif}
-->
</style>
</head>

<body>
<h1 class="style1">Records &amp; Sealed Classes (Java 14+) - Q&amp;A Set 1</h1>
<h2 class="style1"><a href="Java 12 Records Sealed Classes.html" target="_blank">Audio 1</a></h2>
<ol class="style1">
  <li> <strong>What is a record in Java?</strong><br />
    A record in Java is a special kind of class introduced in Java 14 as a preview feature and finalized in Java 16. It is a quick way of declaring classes that are intended to be used as data carriers, automatically providing a constructor, accessors, `equals()`, `hashCode()`, and `toString()` methods.<br />
    Example:<br />
    <pre><code>
                public record Person(String name, int age) {}
                
                public class RecordExample {
                    public static void main(String[] args) {
                        Person person = new Person(&quot;John&quot;, 25);
                        System.out.println(person.name()); // Outputs: John
                    }
                }
            </code></pre>
  </li>
  <br />
  <li> <strong>How do records differ from regular classes in Java?</strong><br />
    Records are a special kind of class that automatically provides immutable fields, a constructor, `equals()`, `hashCode()`, and `toString()` methods. In contrast, regular classes require you to manually define these methods and handle immutability.<br />
    Example:<br />
    <pre><code>
                public record Book(String title, String author) {} // Immutability is implicit
                
                // Regular class would require more boilerplate code:
                public class BookRegular {
                    private final String title;
                    private final String author;
                    // Constructor, getters, equals, hashCode, toString need to be defined manually
                }
            </code></pre>
  </li>
  <br />
  <li> <strong>Can you extend a record in Java?</strong><br />
    No, records cannot be extended by other classes. Records implicitly extend `java.lang.Record`, which is final, and thus they cannot be subclassed.<br />
    Example:<br />
    <pre><code>
                // This would not compile:
                public record ExtendedPerson(String name, int age) extends Person {} // Error: cannot extend record class
            </code></pre>
  </li>
  <br />
  <li> <strong>Can a record have instance methods?</strong><br />
    Yes, records can have instance methods in addition to the automatically provided methods like `equals()`, `hashCode()`, and `toString()`. You can add additional behavior specific to your data structure.<br />
    Example:<br />
    <pre><code>
                public record Person(String name, int age) {
                    public String getInfo() {
                        return name + &quot; is &quot; + age + &quot; years old.&quot;;
                    }
                }

                public class RecordMethodExample {
                    public static void main(String[] args) {
                        Person person = new Person(&quot;John&quot;, 25);
                        System.out.println(person.getInfo()); // Outputs: John is 25 years old.
                    }
                }
            </code></pre>
  </li>
  <br />
  <li> <strong>What is a sealed class in Java?</strong><br />
    A sealed class is a class that restricts which other classes or interfaces can extend or implement it. Introduced in Java 15, sealed classes allow you to control the inheritance hierarchy and define a set of allowed subclasses.<br />
    Example:<br />
    <pre><code>
                public sealed class Shape permits Circle, Square {}

                public final class Circle extends Shape {}
                public final class Square extends Shape {}
                
                // This would cause a compilation error:
                // public class Rectangle extends Shape {} // Error: Rectangle is not allowed
            </code></pre>
  </li>
  <br />
  <li> <strong>What is the benefit of using sealed classes in Java?</strong><br />
    Sealed classes provide better control over the class hierarchy, making the code easier to maintain and understand. They allow you to restrict inheritance to a predefined set of subclasses, reducing the risk of unintended subclassing.<br />
    Example:<br />
    <pre><code>
                public sealed class Vehicle permits Car, Bike {}
                public final class Car extends Vehicle {}
                public final class Bike extends Vehicle {}
            </code></pre>
  </li>
  <br />
  <li> <strong>What are the key components of a record in Java?</strong><br />
    The key components of a record in Java are the components (fields) defined in the parentheses, which are automatically declared as `final` and provided with getter methods.<br />
    Example:<br />
    <pre><code>
                public record Person(String name, int age) {}
                // The record implicitly provides:
                // - final fields: name and age
                // - getter methods: name(), age()
                // - equals(), hashCode(), and toString() methods
            </code></pre>
  </li>
  <br />
  <li> <strong>Can you define constructors in records?</strong><br />
    Yes, records can have constructors, but the primary constructor is automatically provided based on the parameters in the record declaration. You can define additional constructors if necessary.<br />
    Example:<br />
    <pre><code>
                public record Person(String name, int age) {
                    public Person(String name) {
                        this(name, 18); // Default age is 18
                    }
                }
            </code></pre>
  </li>
  <br />
  <li> <strong>How do sealed classes work with interfaces?</strong><br />
    Sealed classes can implement interfaces, and you can specify which classes are allowed to implement them using the `permits` clause. The same inheritance restrictions apply to both classes and interfaces.<br />
    Example:<br />
  </li>
</ol>
<pre class="style1"><code>
                public sealed interface Shape permits Circle, Square {}

                public final class Circle implements Shape {}
                public final class Square implements Shape {}
            </code>




    </pre>
<h1 class="style1">Records &amp; Sealed Classes (Java 14+) - Q&amp;A Set 2</h1>
<ol class="style1">
  <li> <strong>Can sealed classes be abstract in Java?</strong><br />
    Yes, sealed classes can be abstract. The `abstract` keyword can be used with a sealed class, allowing you to define abstract methods that must be implemented by its permitted subclasses.<br />
    Example:<br />
    <pre><code>
                public sealed abstract class Animal permits Dog, Cat {}

                public final class Dog extends Animal {
                    @Override
                    public void makeSound() {
                        System.out.println(&quot;Woof&quot;);
                    }
                }

                public final class Cat extends Animal {
                    @Override
                    public void makeSound() {
                        System.out.println(&quot;Meow&quot;);
                    }
                }
            </code></pre>
  </li>
  <br />
  <li> <strong>Can you use records with generics in Java?</strong><br />
    Yes, you can use records with generics. Like regular classes, records can be parameterized with type parameters to create flexible data structures.<br />
    Example:<br />
    <pre><code>
                public record Box<T>(T value) {}

                public class RecordGenericsExample {
                    public static void main(String[] args) {
                        Box<String> stringBox = new Box&lt;&gt;(&quot;Hello&quot;);
                        System.out.println(stringBox.value()); // Outputs: Hello
                    }
                }
            </code></pre>
  </li>
  <br />
  <li> <strong>Can you extend a sealed interface in Java?</strong><br />
    Yes, you can extend a sealed interface, just as you would with regular interfaces. However, you can only extend the sealed interface within the allowed set of permitted classes or interfaces.<br />
    Example:<br />
    <pre><code>
                public sealed interface Shape permits Circle, Square {}

                public non-sealed interface Drawable extends Shape {}

                public final class Circle implements Drawable {}
                public final class Square implements Drawable {}
            </code></pre>
  </li>
  <br />
  <li> <strong>What does the `permits` keyword do in a sealed class?</strong><br />
    The `permits` keyword defines the set of classes or interfaces that are allowed to extend or implement a sealed class or interface. This creates a restricted and controlled class hierarchy.<br />
    Example:<br />
    <pre><code>
                public sealed class Vehicle permits Car, Bike {}

                public final class Car extends Vehicle {}
                public final class Bike extends Vehicle {}
            </code></pre>
  </li>
  <br />
  <li> <strong>Can a record implement an interface in Java?</strong><br />
    Yes, a record can implement one or more interfaces, just like a regular class. Records can define additional behavior by implementing interfaces, providing more flexibility.<br />
    Example:<br />
    <pre><code>
                public interface Named {
                    String getName();
                }

                public record Person(String name, int age) implements Named {
                    @Override
                    public String getName() {
                        return name;
                    }
                }

                public class RecordInterfaceExample {
                    public static void main(String[] args) {
                        Person person = new Person(&quot;Alice&quot;, 30);
                        System.out.println(person.getName()); // Outputs: Alice
                    }
                }
            </code></pre>
  </li>
  <br />
  <li> <strong>Can a record be used as a key in a HashMap?</strong><br />
    Yes, records can be used as keys in a `HashMap` because they automatically generate the `hashCode()` and `equals()` methods, which are essential for hash-based collections.<br />
    Example:<br />
    <pre><code>
                public record Person(String name, int age) {}

                public class RecordHashMapExample {
                    public static void main(String[] args) {
                        Map map = new HashMap&lt;&gt;();
                        Person person = new Person(&quot;John&quot;, 25);
                        map.put(person, &quot;Engineer&quot;);
                        System.out.println(map.get(person)); // Outputs: Engineer
                    }
                }
            </code></pre>
  </li>
  <br />
  <li> <strong>What happens if you try to extend a sealed class from outside its permitted classes?</strong><br />
    If you try to extend a sealed class from outside its permitted classes, it will result in a compilation error. Only the specified classes or interfaces in the `permits` clause are allowed to extend or implement the sealed class.<br />
    Example:<br />
    <pre><code>
                public sealed class Vehicle permits Car {}

                // This will cause a compilation error:
                // public class Bike extends Vehicle {} // Error: Bike is not permitted
            </code></pre>
  </li>
  <br />
  <li> <strong>What does a `non-sealed` class do in a sealed class hierarchy?</strong><br />
    A `non-sealed` class is a subclass of a sealed class that allows further subclassing outside the permitted set of subclasses. It is used when you want to allow additional subclasses beyond the restricted hierarchy.<br />
    Example:<br />
    <pre><code>
                public sealed class Animal permits Dog {}

                public non-sealed class Dog extends Animal {}

                public class SuperDog extends Dog {} // This is allowed because Dog is non-sealed
            </code></pre>
  </li>
  <br />
  <li> <strong>Can you modify the fields of a record after it is created?</strong><br />
    No, the fields of a record are implicitly `final`, meaning they cannot be modified after the record is created. Records are immutable by design.<br />
    Example:<br />
    <pre><code>
                public record Person(String name, int age) {}

                // This would not compile:
                // person.name = &quot;John&quot;; // Error: cannot assign a value to final variable 'name'
            </code></pre>
  </li>
</ol>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<h1 class="style1">Records &amp; Sealed Classes (Java 14+) - Q&amp;A Set 3</h1>
<ol class="style1">
  <li> <strong>What is the benefit of using records over regular classes in Java?</strong><br />
    Records provide a compact syntax for data-carrying classes. They automatically generate constructors, `equals()`, `hashCode()`, and `toString()` methods, reducing boilerplate code and improving readability.<br />
    Example:<br />
    <pre><code>
                public record Book(String title, String author, int year) {}
            </code></pre>
  </li>
  <br />
  <li> <strong>Can a record be used with `var` in Java?</strong><br />
    Yes, records can be used with `var` for local variable declarations. The type of the variable is inferred based on the assigned value.<br />
    Example:<br />
    <pre><code>
                var book = new Book(&quot;1984&quot;, &quot;George Orwell&quot;, 1949);
                System.out.println(book.title()); // Outputs: 1984
            </code></pre>
  </li>
  <br />
  <li> <strong>What is the main difference between a `sealed` class and an `abstract` class in Java?</strong><br />
    A `sealed` class restricts which classes or interfaces can extend it by explicitly listing the permitted subclasses, while an `abstract` class can be extended by any other class, unless otherwise restricted.<br />
    Example (sealed class):<br />
    <pre><code>
                public sealed class Vehicle permits Car, Bike {}
            </code></pre>
  </li>
  <br />
  <li> <strong>Can sealed classes have constructors?</strong><br />
    Yes, sealed classes can have constructors, and these constructors can be private or protected to prevent direct instantiation of the class.<br />
    Example:<br />
    <pre><code>
                public sealed class Shape {
                    private final String name;
                    public Shape(String name) {
                        this.name = name;
                    }
                }
            </code></pre>
  </li>
  <br />
  <li> <strong>Can you change the `permits` list of a sealed class after it is defined?</strong><br />
    No, the `permits` list in a sealed class is fixed and cannot be modified after the class is compiled. Once the allowed subclasses are defined, they are set for the lifetime of the class.<br />
    Example:<br />
    <pre><code>
                // This is final and cannot be changed once defined
                public sealed class Animal permits Dog, Cat {}
            </code></pre>
  </li>
  <br />
  <li> <strong>Are records mutable or immutable in Java?</strong><br />
    Records are immutable by design. Once a record is created, its fields cannot be changed, which is why the fields are implicitly declared as `final`.<br />
    Example:<br />
    <pre><code>
                public record Person(String name, int age) {}

                // This would not compile:
                // person.name = &quot;John&quot;; // Error: cannot assign a value to final variable 'name'
            </code></pre>
  </li>
  <br />
  <li> <strong>What happens if a sealed class has no `permits` clause?</strong><br />
    If a sealed class does not have a `permits` clause, it cannot be extended. It is effectively a final class, and no subclasses can be created for it.<br />
    Example:<br />
    <pre><code>
                public sealed class Vehicle {}
                // No subclasses can extend Vehicle since it lacks a permits clause
            </code></pre>
  </li>
  <br />
  <li> <strong>Can you instantiate a record without specifying its fields in Java?</strong><br />
    No, records are value-based and require the fields to be specified at instantiation, as they are part of the constructor.<br />
    Example:<br />
    <pre><code>
                // This would not compile:
                // Book book = new Book(); // Error: constructor requires arguments
            </code></pre>
  </li>
  <br />
  <li> <strong>How do records differ from data classes in other languages like Kotlin?</strong><br />
    Records in Java are similar to data classes in Kotlin, as they are designed to hold immutable data. However, Java records automatically generate several methods such as `equals()`, `hashCode()`, and `toString()`, whereas in Kotlin, you must manually define these methods if needed.<br />
    Example (Java record):<br />
    <pre><code>
                public record Book(String title, String author) {}
            </code></pre>
  </li>
</ol>
<h1 class="style1">Records &amp; Sealed Classes (Java 14+) - Q&amp;A Set 4</h1>
<ol class="style1">
  <li> <strong>Can a sealed class implement interfaces?</strong><br />
    Yes, a sealed class can implement interfaces just like any other class in Java. The subclasses of the sealed class can also implement interfaces.<br />
    Example:<br />
    <pre><code>
                public sealed class Vehicle implements Transportable permits Car, Bike {}

                interface Transportable {
                    void transport();
                }
            </code></pre>
  </li>
  <br />
  <li> <strong>What is the purpose of `non-sealed` classes in Java?</strong><br />
    A `non-sealed` class is a subclass of a sealed class that is not restricted by the `permits` clause. It allows further extension of that class.<br />
    Example:<br />
    <pre><code>
                public non-sealed class Car extends Vehicle {}
            </code></pre>
  </li>
  <br />
  <li> <strong>How do you declare a record with a custom method in Java?</strong><br />
    You can add custom methods to a record, just like a normal class. The fields of the record can also be used in those methods.<br />
    Example:<br />
    <pre><code>
                public record Person(String name, int age) {
                    public String greeting() {
                        return &quot;Hello, my name is &quot; + name + &quot; and I am &quot; + age + &quot; years old.&quot;;
                    }
                }
            </code></pre>
  </li>
  <br />
  <li> <strong>Can you inherit from a sealed interface?</strong><br />
    Yes, a sealed interface can be extended by other interfaces or implemented by classes, but like sealed classes, it restricts which interfaces and classes can implement or extend it.<br />
    Example:<br />
    <pre><code>
                public sealed interface Shape permits Circle, Rectangle {}

                public final class Circle implements Shape {}
                public final class Rectangle implements Shape {}
            </code></pre>
  </li>
  <br />
  <li> <strong>Are records allowed to have static fields in Java?</strong><br />
    Yes, records can have static fields, as they are regular classes in most respects, except for the automatically generated methods.<br />
    Example:<br />
    <pre><code>
                public record Book(String title, String author) {
                    public static int totalBooks = 0;

                    public Book {
                        totalBooks++;
                    }
                }
            </code></pre>
  </li>
  <br />
  <li> <strong>How does Java handle pattern matching with records?</strong><br />
    Pattern matching in Java allows you to match a record’s components in a `switch` expression or `instanceof` check.<br />
    Example:<br />
    <pre><code>
                public record Person(String name, int age) {}

                Person person = new Person(&quot;Alice&quot;, 30);
                if (person instanceof Person p) {
                    System.out.println(p.name()); // Alice
                }
            </code></pre>
  </li>
  <br />
  <li> <strong>Can a record extend another record in Java?</strong><br />
    No, records cannot extend other records. However, they can implement interfaces.<br />
    Example:<br />
    <pre><code>
                // This would not compile:
                // public record Employee extends Person {} // Error
            </code></pre>
  </li>
  <br />
  <li> <strong>Can a sealed class be abstract?</strong><br />
    Yes, a sealed class can be abstract. It can be used as a base class with restrictions on which classes can extend it.<br />
    Example:<br />
    <pre><code>
                public sealed abstract class Animal permits Dog, Cat {}

                public final class Dog extends Animal {}
                public final class Cat extends Animal {}
            </code></pre>
  </li>
  <br />
  <li> <strong>How can you enforce immutability in a record's components?</strong><br />
    All components of a record are implicitly `final`, meaning they cannot be reassigned. This ensures that records are immutable after they are created.<br />
    Example:<br />
    <pre><code>
                public record Book(String title, String author) {}
                // The fields `title` and `author` cannot be changed after instantiation.
            </code></pre>
  </li>
  <br />
  <li> <strong>Can sealed classes have non-public constructors?</strong><br />
    Yes, sealed classes can have private or protected constructors to control the creation of instances.<br />
    Example:<br />
    <pre><code>
                public sealed class Shape {
                    private Shape() {}
                }
            </code></pre>
  </li>
</ol>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<h1 class="style1">Records &amp; Sealed Classes (Java 14+) - Q&amp;A Set 5</h1>
<ol class="style1">
  <li> <strong>What are the advantages of using records in Java?</strong><br />
    Records provide a compact syntax for declaring classes that are intended to only store immutable data. They automatically generate useful methods like `equals()`, `hashCode()`, `toString()`, and more.<br />
    Example:<br />
    <pre><code>
                public record Point(int x, int y) {}
                // Automatically generated methods like equals(), hashCode(), and toString()
            </code></pre>
  </li>
  <br />
  <li> <strong>Can you use a record as a supertype in inheritance?</strong><br />
    No, records cannot be extended. They are implicitly `final` and do not support inheritance.<br />
    Example:<br />
    <pre><code>
                // This would not compile:
                // public record Circle extends Point {} // Error
            </code></pre>
  </li>
  <br />
  <li> <strong>How does a record differ from a data class in Kotlin?</strong><br />
    Both serve similar purposes, but in Java, records automatically generate methods like `equals()`, `hashCode()`, and `toString()` while enforcing immutability. Kotlin's `data` classes also provide similar features but are more flexible in some cases.<br />
    Example:<br />
    <pre><code>
                // Java Record:
                public record User(String name, int age) {}

                // Kotlin Data Class:
                data class User(val name: String, val age: Int)
            </code></pre>
  </li>
  <br />
  <li> <strong>Can a sealed class be abstract and still have non-sealed subclasses?</strong><br />
    Yes, a sealed class can be abstract and still allow non-sealed subclasses. The key restriction is that only the specified subclasses (as mentioned in the `permits` clause) can extend the sealed class unless it is marked `non-sealed`.<br />
    Example:<br />
    <pre><code>
                public sealed abstract class Animal permits Dog, Cat {}
                public non-sealed class Dog extends Animal {}
            </code></pre>
  </li>
  <br />
  <li> <strong>How can you change a record to a non-immutable class?</strong><br />
    Records, by definition, are immutable. To make it mutable, you would have to replace it with a standard class and provide your own getters, setters, and other methods.<br />
    Example:<br />
    <pre><code>
                // Mutable class instead of record:
                public class Person {
                    private String name;
                    private int age;

                    public Person(String name, int age) {
                        this.name = name;
                        this.age = age;
                    }

                    public String getName() { return name; }
                    public void setName(String name) { this.name = name; }
                }
            </code></pre>
  </li>
  <br />
  <li> <strong>Can you instantiate a record without using its constructor?</strong><br />
    No, you must use the constructor of the record to instantiate it. You cannot manually create a new instance without passing the required values to the constructor.<br />
    Example:<br />
    <pre><code>
                public record Book(String title, String author) {}

                // Valid:
                Book book = new Book(&quot;The Hobbit&quot;, &quot;J.R.R. Tolkien&quot;);

                // Invalid (no constructor):
                // Book book = new Book(); // Error
            </code></pre>
  </li>
  <br />
  <li> <strong>What happens if a sealed class does not have any subclasses?</strong><br />
    If a sealed class does not have any subclasses, it remains a valid class but has no direct usage. You cannot extend it in any other classes.<br />
    Example:<br />
    <pre><code>
                public sealed class EmptyShape {}
                // No other classes can extend EmptyShape.
            </code></pre>
  </li>
  <br />
  <li> <strong>Can you override methods in a record class?</strong><br />
    Yes, you can override methods in a record class, including the automatically generated methods like `toString()`, `equals()`, and `hashCode()`, or any other method.<br />
    Example:<br />
    <pre><code>
                public record Employee(String name, String position) {
                    @Override
                    public String toString() {
                        return name + &quot; works as a &quot; + position;
                    }
                }
            </code></pre>
  </li>
  <br />
  <li> <strong>How do you define a sealed interface in Java?</strong><br />
    A sealed interface is defined using the `sealed` keyword, just like a sealed class. You can specify which interfaces or classes are allowed to implement the sealed interface.<br />
    Example:<br />
    <pre><code>
                public sealed interface Shape permits Circle, Rectangle {}
            </code></pre>
  </li>
  <br />
  <li> <strong>Can a record implement multiple interfaces?</strong><br />
    Yes, a record can implement multiple interfaces, just like a regular class.<br />
    Example:<br />
    <pre><code>
                public record Person(String name, int age) implements Greetable, Identifiable {}
                
                interface Greetable {
                    void greet();
                }

                interface Identifiable {
                    String getId();
                }
            </code></pre>
  </li>
</ol>
<p class="style1">&nbsp;</p>
<h1 class="style1">Records &amp; Sealed Classes (Java 14+) - Q&amp;A Set 6</h1>
<ol class="style1">
  <li> <strong>Can a record class extend another class?</strong><br />
    No, a record class cannot extend another class because it is implicitly `final`. However, it can implement interfaces.<br />
    Example:<br />
    <pre><code>
                // Invalid:
                // public record MyRecord extends AnotherClass {} // Error

                // Valid:
                public record MyRecord implements MyInterface {}
            </code></pre>
  </li>
  <br />
  <li> <strong>What happens if a sealed class has a non-sealed subclass?</strong><br />
    A non-sealed subclass allows further inheritance, meaning that classes can extend the non-sealed subclass freely. This is useful when you want to restrict inheritance within the sealed class hierarchy but still allow it for certain subclasses.<br />
    Example:<br />
    <pre><code>
                public sealed class Animal permits Dog {}

                public non-sealed class Dog extends Animal {}

                // Any class can extend Dog
                public class Bulldog extends Dog {}
            </code></pre>
  </li>
  <br />
  <li> <strong>Can a sealed class have an abstract method?</strong><br />
    Yes, a sealed class can have abstract methods, just like a normal abstract class. The subclasses must implement the abstract methods.<br />
    Example:<br />
    <pre><code>
                public sealed class Shape permits Circle, Rectangle {
                    public abstract void draw();
                }
            </code></pre>
  </li>
  <br />
  <li> <strong>Can a record be used as a key in a HashMap?</strong><br />
    Yes, a record can be used as a key in a HashMap because the `equals()` and `hashCode()` methods are automatically generated based on the record's fields.<br />
    Example:<br />
    <pre><code>
                public record Point(int x, int y) {}

                Map map = new HashMap&lt;&gt;();
                Point point = new Point(1, 2);
                map.put(point, &quot;Point A&quot;);
            </code></pre>
  </li>
  <br />
  <li> <strong>Can you define a record with mutable fields?</strong><br />
    No, records are inherently immutable. If you need mutable fields, you should use a regular class instead of a record.<br />
    Example:<br />
    <pre><code>
                // Invalid:
                // public record MutableRecord(String name) { 
                //     private String name; 
                // } // Error
                
                // Valid: Use a regular class for mutable fields.
                public class MutableClass {
                    private String name;
                }
            </code></pre>
  </li>
  <br />
  <li> <strong>How do you create a compact constructor for a record in Java?</strong><br />
    You can define a compact constructor in a record to add additional validation or logic when initializing the fields.<br />
    Example:<br />
    <pre><code>
                public record Person(String name, int age) {
                    public Person {
                        if (age &lt; 0) throw new IllegalArgumentException(&quot;Age cannot be negative&quot;);
                    }
                }
            </code></pre>
  </li>
  <br />
  <li> <strong>What is the purpose of the `permits` keyword in sealed classes?</strong><br />
    The `permits` keyword is used in sealed classes to specify the allowed subclasses that can extend the sealed class. It restricts subclassing to only the specified classes or interfaces.<br />
    Example:<br />
    <pre><code>
                public sealed class Shape permits Circle, Square {}
            </code></pre>
  </li>
  <br />
  <li> <strong>Can a sealed class implement interfaces?</strong><br />
    Yes, a sealed class can implement one or more interfaces, just like a regular class. The restriction only applies to the inheritance hierarchy.<br />
    Example:<br />
    <pre><code>
                public sealed class Shape implements Drawable {
                    public void draw() {
                        System.out.println(&quot;Drawing a shape&quot;);
                    }
                }
            </code></pre>
  </li>
  <br />
  <li> <strong>What is a practical use case for sealed classes?</strong><br />
    Sealed classes are useful when you want to define a closed set of related types, such as when modeling domain-specific logic where the set of possible subclasses is finite and known at compile time.<br />
    Example: Modeling different types of shapes in a drawing application.<br />
    Example:<br />
    <pre><code>
                public sealed class Shape permits Circle, Rectangle, Triangle {}
            </code></pre>
  </li>
</ol>
<p class="style1">&nbsp;</p>
<h1 class="style1">Records &amp; Sealed Classes (Java 14+) - Q&amp;A Set 7</h1>
<ol class="style1">
  <li> <strong>Can a record class implement multiple interfaces?</strong><br />
    Yes, a record class can implement multiple interfaces. This allows you to add behavior to records via interfaces.<br />
    Example:<br />
    <pre><code>
                public record Person(String name, int age) implements Drawable, Comparable<Person> {
                    public void draw() {
                        System.out.println(&quot;Drawing person &quot; + name);
                    }

                    @Override
                    public int compareTo(Person other) {
                        return this.age - other.age;
                    }
                }
            </code></pre>
  </li>
  <br />
  <li> <strong>Are sealed classes automatically abstract in Java?</strong><br />
    Yes, sealed classes are implicitly abstract unless they are declared as `final` or they have no methods.<br />
    Example:<br />
    <pre><code>
                public sealed class Shape permits Circle, Rectangle {
                    public abstract void draw(); // Abstract method
                }
            </code></pre>
  </li>
  <br />
  <li> <strong>What is the primary purpose of records in Java?</strong><br />
    The primary purpose of records is to provide a compact, immutable data structure for modeling simple data objects. Records automatically generate methods like `toString()`, `equals()`, and `hashCode()` based on the fields.<br />
    Example:<br />
    <pre><code>
                public record Point(int x, int y) {} // Immutable, compact data model
            </code></pre>
  </li>
  <br />
  <li> <strong>Can a sealed class be extended outside of its permitted subclass list?</strong><br />
    No, a sealed class can only be extended by the classes listed in its `permits` clause. If a class is not in the `permits` list, it cannot extend the sealed class.<br />
    Example:<br />
    <pre><code>
                public sealed class Animal permits Dog, Cat {}

                // Invalid:
                // public class Bird extends Animal {} // Error
            </code></pre>
  </li>
  <br />
  <li> <strong>Can you mix regular classes and records in the same inheritance hierarchy?</strong><br />
    No, a record cannot extend a regular class or vice versa. Records can only extend other records if required, and they cannot extend a class.<br />
    Example:<br />
    <pre><code>
                // Invalid:
                // public record Person extends Animal {} // Error
            </code></pre>
  </li>
  <br />
  <li> <strong>Can a record be declared abstract?</strong><br />
    No, records are implicitly final and cannot be declared abstract. You can't inherit from a record, and you don't need to declare them abstract.<br />
    Example:<br />
    <pre><code>
                // Invalid:
                // public abstract record Person(String name) {} // Error
            </code></pre>
  </li>
  <br />
  <li> <strong>How does inheritance work in a sealed class hierarchy?</strong><br />
    In a sealed class hierarchy, inheritance is restricted to the classes listed in the `permits` clause of the sealed class. This allows for more controlled and predictable subclassing.<br />
    Example:<br />
    <pre><code>
                public sealed class Vehicle permits Car, Truck {}
            </code></pre>
  </li>
  <br />
  <li> <strong>Can sealed interfaces exist in Java?</strong><br />
    Yes, sealed interfaces are allowed in Java. Like sealed classes, they can limit which classes or interfaces can implement or extend them.<br />
    Example:<br />
    <pre><code>
                public sealed interface Shape permits Circle, Square {}
            </code></pre>
  </li>
  <br />
  <li> <strong>Can you use a sealed class with a `final` modifier?</strong><br />
    Yes, a sealed class can be `final`, meaning it cannot be extended. When a class is both `final` and sealed, it effectively becomes a fully closed class hierarchy.<br />
    Example:<br />
    <pre><code>
                public sealed final class Shape {} // Cannot be extended by any class
            </code></pre>
  </li>
</ol>
<h1 class="style1">Records &amp; Sealed Classes (Java 14+) - Q&amp;A Set 8</h1>
<ol class="style1">
  <li> <strong>Can you define a record with additional methods?</strong><br />
    Yes, records can have additional methods, just like regular classes. These methods are typically used for added behavior that is not part of the state representation.<br />
    Example:<br />
    <pre><code>
                public record Person(String name, int age) {
                    public String greet() {
                        return &quot;Hello, my name is &quot; + name;
                    }
                }
            </code></pre>
  </li>
  <br />
  <li> <strong>Can you create a sealed class hierarchy with both final and non-final subclasses?</strong><br />
    Yes, you can have both final and non-final subclasses in a sealed class hierarchy. The `final` subclass will prevent further inheritance, while the non-final subclass can be extended by other classes.<br />
    Example:<br />
    <pre><code>
                public sealed class Animal permits Dog, Cat {}

                public final class Dog extends Animal {} // Cannot be extended

                public non-sealed class Cat extends Animal {} // Can be extended
            </code></pre>
  </li>
  <br />
  <li> <strong>Can a sealed class be used with a pattern matching feature in Java?</strong><br />
    Yes, sealed classes are especially useful with pattern matching in Java. You can match on the specific subclasses of a sealed class using `instanceof` or other pattern matching features introduced in newer versions of Java.<br />
    Example:<br />
    <pre><code>
                public sealed class Shape permits Circle, Rectangle {}

                public void printShapeDetails(Shape shape) {
                    switch (shape) {
                        case Circle c -&gt; System.out.println(&quot;Circle with radius &quot; + c.radius());
                        case Rectangle r -&gt; System.out.println(&quot;Rectangle with length &quot; + r.length() + &quot; and width &quot; + r.width());
                    }
                }
            </code></pre>
  </li>
  <br />
  <li> <strong>How do you override methods in a record class?</strong><br />
    You can override methods in a record class just like in a normal class. The automatically generated methods like `toString()`, `equals()`, and `hashCode()` can also be overridden.<br />
    Example:<br />
    <pre><code>
                public record Person(String name, int age) {
                    @Override
                    public String toString() {
                        return &quot;Person[name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;
                    }
                }
            </code></pre>
  </li>
  <br />
  <li> <strong>Can you serialize a record object?</strong><br />
    Yes, record objects can be serialized, as long as they implement `Serializable` (which they do by default if the record's fields are `Serializable`).<br />
    Example:<br />
    <pre><code>
                import java.io.*;

                public record Person(String name, int age) implements Serializable {}

                public class SerializeExample {
                    public static void main(String[] args) throws IOException {
                        Person person = new Person(&quot;Alice&quot;, 30);
                        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;person.ser&quot;))) {
                            out.writeObject(person);
                        }
                    }
                }
            </code></pre>
  </li>
  <br />
  <li> <strong>Can a record have a constructor with parameters?</strong><br />
    Yes, records can have a constructor, but it is automatically generated based on the fields. You can define a custom constructor if needed, to add additional validation or logic.<br />
    Example:<br />
    <pre><code>
                public record Person(String name, int age) {
                    public Person {
                        if (age &lt; 0) throw new IllegalArgumentException(&quot;Age cannot be negative&quot;);
                    }
                }
            </code></pre>
  </li>
  <br />
  <li> <strong>What happens if you try to extend a record?</strong><br />
    You cannot extend a record in Java, because records are implicitly `final`. You can implement interfaces, but inheritance is not allowed.<br />
    Example:<br />
    <pre><code>
                // Invalid:
                // public record ExtendedPerson(String name) extends Person {} // Error
            </code></pre>
  </li>
  <br />
  <li> <strong>Can you define a sealed class with no permitted subclasses?</strong><br />
    Yes, you can define a sealed class without any permitted subclasses, which makes the class fully sealed. This can be useful when you want to restrict further subclassing at all.<br />
    Example:<br />
    <pre><code>
                public sealed class FinalClass {} // No permits clause, no subclassing allowed
            </code></pre>
  </li>
  <br />
  <li> <strong>Are sealed classes and records compatible?</strong><br />
    Yes, you can use sealed classes and records together. A sealed class can have a record as one of its permitted subclasses, and a record can implement interfaces that may be used in a sealed class hierarchy.<br />
    Example:<br />
    <pre><code>
                public sealed class Shape permits Circle, Square {}

                public record Circle(double radius) implements Shape {}
            </code></pre>
  </li>
</ol>
<h1 class="style1">Records &amp; Sealed Classes (Java 14+) - Q&amp;A Set 9</h1>
<ol class="style1">
  <li> <strong>Can a sealed class extend another sealed class?</strong><br />
    Yes, a sealed class can extend another sealed class. However, the subclasses of the extending sealed class must also be declared within the `permits` clause.<br />
    Example:<br />
    <pre><code>
                public sealed class Animal permits Dog, Cat {}
                public sealed class Dog extends Animal permits Bulldog {}
            </code></pre>
  </li>
  <br />
  <li> <strong>Can a record be abstract?</strong><br />
    No, a record cannot be abstract because it is inherently intended to represent immutable data structures. Records are implicitly final, so they cannot be extended.<br />
    Example:<br />
    <pre><code>
                // Invalid:
                // public abstract record Person(String name, int age) {} // Error
            </code></pre>
  </li>
  <br />
  <li> <strong>Can you have a static field in a record?</strong><br />
    Yes, you can have static fields in a record. However, static fields are not part of the record's state and do not affect the automatically generated methods such as `toString()`, `equals()`, and `hashCode()`.<br />
    Example:<br />
    <pre><code>
                public record Person(String name, int age) {
                    private static int totalCount = 0;

                    public Person {
                        totalCount++;
                    }

                    public static int getTotalCount() {
                        return totalCount;
                    }
                }
            </code></pre>
  </li>
  <br />
  <li> <strong>Can a sealed class be abstract?</strong><br />
    Yes, a sealed class can be abstract. It can have abstract methods that subclasses must implement.<br />
    Example:<br />
    <pre><code>
                public sealed class Shape permits Circle, Rectangle {
                    public abstract double area();
                }
            </code></pre>
  </li>
  <br />
  <li> <strong>Can you use `instanceof` to check for types in a sealed class hierarchy?</strong><br />
    Yes, you can use `instanceof` to check for types in a sealed class hierarchy, which can be very useful in pattern matching.<br />
    Example:<br />
    <pre><code>
                public sealed class Shape permits Circle, Rectangle {}

                public void checkShapeType(Shape shape) {
                    if (shape instanceof Circle) {
                        System.out.println(&quot;It's a Circle&quot;);
                    } else if (shape instanceof Rectangle) {
                        System.out.println(&quot;It's a Rectangle&quot;);
                    }
                }
            </code></pre>
  </li>
  <br />
  <li> <strong>Can a record implement interfaces?</strong><br />
    Yes, records can implement interfaces just like regular classes. However, they cannot extend other classes as they are implicitly `final`.<br />
    Example:<br />
    <pre><code>
                public record Person(String name, int age) implements Comparable<Person> {
                    @Override
                    public int compareTo(Person other) {
                        return Integer.compare(this.age, other.age);
                    }
                }
            </code></pre>
  </li>
  <br />
  <li> <strong>How can you ensure a record is immutable?</strong><br />
    Records are immutable by default because all their fields are implicitly `final` and they provide a constructor to initialize them. However, if you want to ensure the immutability of complex objects, you should also ensure that the fields are deeply immutable.<br />
    Example:<br />
    <pre><code>
                public record Address(String street, String city) {}

                public record Person(String name, Address address) {
                    public Person {
                        address = new Address(address.street(), address.city()); // Deep copy if needed
                    }
                }
            </code></pre>
  </li>
  <br />
  <li> <strong>Can you inherit from a sealed class and make your class non-sealed?</strong><br />
    Yes, you can inherit from a sealed class and make your subclass `non-sealed`. This allows further subclassing beyond that subclass.<br />
    Example:<br />
    <pre><code>
                public sealed class Animal permits Dog {}
                public non-sealed class Dog extends Animal {} // This can be subclassed further
            </code></pre>
  </li>
  <br />
  <li> <strong>Are records always thread-safe?</strong><br />
    Records are inherently thread-safe only if all fields within the record are immutable. Since records provide final fields, they are thread-safe as long as they do not hold references to mutable objects.<br />
    Example:<br />
    <pre><code>
                public record Person(String name, int age) {} // Thread-safe as both fields are immutable
            </code></pre>
  </li>
</ol>
<h1 class="style1">Records &amp; Sealed Classes (Java 14+) - Q&amp;A Set 10</h1>
<ol class="style1">
  <li> <strong>Can you define a constructor in a record?</strong><br />
    Yes, you can define a constructor in a record, but the compiler will automatically provide a constructor that takes parameters for all the fields. You can define a custom constructor to add validation or transformation logic.<br />
    Example:<br />
    <pre><code>
                public record Person(String name, int age) {
                    public Person {
                        if (age &lt; 0) throw new IllegalArgumentException(&quot;Age cannot be negative&quot;);
                    }
                }
            </code></pre>
  </li>
  <br />
  <li> <strong>Can sealed classes be used with pattern matching?</strong><br />
    Yes, sealed classes work well with pattern matching in Java, allowing more concise and readable code for type checks. In combination with `instanceof`, this enables a clean way to handle different subclasses.<br />
    Example:<br />
    <pre><code>
                public sealed class Shape permits Circle, Rectangle {}

                public void printArea(Shape shape) {
                    switch (shape) {
                        case Circle c -&gt; System.out.println(&quot;Area: &quot; + c.radius() * c.radius());
                        case Rectangle r -&gt; System.out.println(&quot;Area: &quot; + r.length() * r.width());
                    }
                }
            </code></pre>
  </li>
  <br />
  <li> <strong>Can you create a record with private fields?</strong><br />
    In a record, the fields are implicitly `private final` and are accessed through the automatically generated getter methods. You cannot make the fields explicitly private or change their access modifiers.<br />
    Example:<br />
    <pre><code>
                public record Person(String name, int age) {} // Fields are implicitly private
            </code></pre>
  </li>
  <br />
  <li> <strong>Can a sealed class have abstract methods?</strong><br />
    Yes, a sealed class can have abstract methods, and subclasses that are declared in the `permits` clause must implement those abstract methods.<br />
    Example:<br />
    <pre><code>
                public sealed class Shape permits Circle, Rectangle {
                    public abstract double area();
                }
            </code></pre>
  </li>
  <br />
  <li> <strong>What happens if you do not define a `permits` clause in a sealed class?</strong><br />
    If you do not define a `permits` clause in a sealed class, it means that no subclass is allowed, making the class implicitly final.<br />
    Example:<br />
    <pre><code>
                public sealed class Animal {} // No subclasses allowed
            </code></pre>
  </li>
  <br />
  <li> <strong>How can you modify a record's data?</strong><br />
    Since records are immutable by default, you cannot modify their fields directly. However, you can create a new instance of the record with modified values.<br />
    Example:<br />
    <pre><code>
                public record Person(String name, int age) {}

                Person person = new Person(&quot;John&quot;, 30);
                Person updatedPerson = new Person(person.name(), 31); // Create a new instance
            </code></pre>
  </li>
  <br />
  <li> <strong>Can a sealed class have a constructor?</strong><br />
    Yes, a sealed class can have a constructor. However, subclasses defined in the `permits` clause can use the constructor to initialize their own state.<br />
    Example:<br />
    <pre><code>
                public sealed class Animal permits Dog, Cat {
                    private final String name;

                    public Animal(String name) {
                        this.name = name;
                    }
                }
            </code></pre>
  </li>
  <br />
  <li> <strong>Can you inherit from a record?</strong><br />
    No, a record cannot be subclassed, as it is implicitly `final`. This ensures the immutability and integrity of the data it holds.<br />
    Example:<br />
    <pre><code>
                // Invalid:
                // public record Employee(String name, int id) extends Person {} // Error
            </code></pre>
  </li>
  <br />
  <li> <strong>Are there any restrictions on using records with generics?</strong><br />
    There are no restrictions on using records with generics. Records can be used with generics just like regular classes.<br />
    Example:<br />
    <pre><code>
                public record Box<T>(T item) {}
                Box<String> box = new Box&lt;&gt;(&quot;Hello&quot;);
            </code></pre>
  </li>
</ol>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
</body>
</html>
