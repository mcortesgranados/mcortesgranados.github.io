<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OOP Principles - Questions & Answers</title>
    <style type="text/css">
<!--
.style1 {font-family: Arial, Helvetica, sans-serif}
-->
    </style>
</head>
<body>
    <h1 class="style1">Object-Oriented Programming (OOP) Principles - Questions & Answers</h1>
    <h2 class="style1">Set 8</h2>
    <ol class="style1">
        <li>
            <strong>What is "polymorphism" in OOP?</strong><br>
            <p><em>Answer:</em> Polymorphism allows objects of different classes to be treated as objects of a common superclass. It enables the same method or operation to behave differently depending on the type of object it is called on.</p>
        </li>
        <li>
            <strong>Can you provide an example of polymorphism in Java?</strong><br>
            <pre>
class Animal {
    void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    @Override
    void sound() {
        System.out.println("Cat meows");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal animal1 = new Dog();
        Animal animal2 = new Cat();
        
        animal1.sound();  // Outputs: Dog barks
        animal2.sound();  // Outputs: Cat meows
    }
}
            </pre>
            <p><em>Answer:</em> The `sound` method is overridden in both `Dog` and `Cat` classes. When the `sound` method is called on `animal1` and `animal2`, it produces different outputs, demonstrating polymorphism.</p>
        </li>
        <li>
            <strong>What is the concept of "method overloading" in Java?</strong><br>
            <p><em>Answer:</em> Method overloading refers to defining multiple methods with the same name but different parameter lists. It allows different behaviors based on the number or type of parameters passed.</p>
        </li>
        <li>
            <strong>Can you provide an example of method overloading in Java?</strong><br>
            <pre>
class Calculator {
    int add(int a, int b) {
        return a + b;
    }

    double add(double a, double b) {
        return a + b;
    }

    public static void main(String[] args) {
        Calculator calc = new Calculator();
        System.out.println(calc.add(10, 20));    // Outputs: 30
        System.out.println(calc.add(10.5, 20.5));  // Outputs: 31.0
    }
}
            </pre>
            <p><em>Answer:</em> The `add` method is overloaded: one method accepts `int` parameters, and the other accepts `double` parameters. The appropriate method is called based on the argument types.</p>
        </li>
        <li>
            <strong>What is the difference between "abstract class" and "interface" in Java?</strong><br>
            <p><em>Answer:</em> 
            - An **abstract class** can have both abstract (unimplemented) and concrete (implemented) methods. It can have member variables and constructors.
            - An **interface** can only have abstract methods (until Java 8 introduced default and static methods). A class that implements an interface must provide implementations for all its methods.            </p>
        </li>
        <li>
            <strong>Can you provide an example of using an interface in Java?</strong><br>
            <pre>
interface Animal {
    void sound();
}

class Dog implements Animal {
    public void sound() {
        System.out.println("Dog barks");
    }
}

class Cat implements Animal {
    public void sound() {
        System.out.println("Cat meows");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal dog = new Dog();
        Animal cat = new Cat();
        
        dog.sound();  // Outputs: Dog barks
        cat.sound();  // Outputs: Cat meows
    }
}
            </pre>
            <p><em>Answer:</em> The `Animal` interface defines a `sound` method that both `Dog` and `Cat` classes implement. Each class provides its own implementation of the `sound` method.</p>
        </li>
        <li>
            <strong>What is the concept of "constructor chaining" in Java?</strong><br>
            <p><em>Answer:</em> Constructor chaining is the process of calling one constructor from another constructor in the same class or from a superclass constructor. It can be done using the `this` or `super` keyword.</p>
        </li>
        <li>
            <strong>Can you provide an example of constructor chaining in Java?</strong><br>
            <pre>
class Person {
    private String name;
    private int age;

    // Constructor with two parameters
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // Constructor with one parameter
    public Person(String name) {
        this(name, 0);  // Calling the two-parameter constructor
    }

    public void displayInfo() {
        System.out.println("Name: " + name);
        System.out.println("Age: " + age);
    }

    public static void main(String[] args) {
        Person person1 = new Person("Alice", 30);
        Person person2 = new Person("Bob");
        person1.displayInfo();  // Outputs: Name: Alice
                                //          Age: 30
        person2.displayInfo();  // Outputs: Name: Bob
                                //          Age: 0
    }
}
            </pre>
            <p><em>Answer:</em> The constructor with one parameter calls the constructor with two parameters, demonstrating constructor chaining.</p>
        </li>
        <li>
            <strong>What is the concept of "super" in Java?</strong><br>
            <p><em>Answer:</em> The `super` keyword is used to refer to the immediate superclass of a class. It is used to call the superclass constructor or access its methods and fields.</p>
        </li>
        <li>
            <strong>Can you provide an example of using the `super` keyword in Java?</strong><br>
            <pre>
class Animal {
    void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        super.sound();  // Calling the superclass method
        System.out.println("Dog barks");
    }

    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.sound();  // Outputs: Animal makes a sound
                      //          Dog barks
    }
}
            </pre>
            <p><em>Answer:</em> The `Dog` class uses `super.sound()` to call the `sound` method of the `Animal` superclass before executing its own implementation.</p>
        </li>
    </ol>
</body>
</html>
