<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OOP Principles - Questions & Answers</title>
    <style type="text/css">
<!--
.style1 {font-family: Arial, Helvetica, sans-serif}
-->
    </style>
</head>
<body>
    <h1 class="style1">Object-Oriented Programming (OOP) Principles - Questions & Answers</h1>
    <h2 class="style1">Set 9</h2>
    <ol class="style1">
        <li>
            <strong>What is the concept of "inheritance" in OOP?</strong><br>
            <p><em>Answer:</em> Inheritance is a mechanism in OOP where one class inherits properties and behaviors (methods) from another class. This allows for code reuse and can model hierarchical relationships between classes.</p>
        </li>
        <li>
            <strong>Can you provide an example of inheritance in Java?</strong><br>
            <pre>
class Animal {
    void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    void sound() {
        System.out.println("Dog barks");
    }

    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.sound();  // Outputs: Dog barks
    }
}
            </pre>
            <p><em>Answer:</em> The `Dog` class inherits the `sound` method from the `Animal` class, but overrides it to provide its own implementation.</p>
        </li>
        <li>
            <strong>What is the difference between "overriding" and "overloading" in Java?</strong><br>
            <p><em>Answer:</em> 
            - **Method Overloading** is when multiple methods have the same name but differ in the number or type of parameters.
            - **Method Overriding** occurs when a subclass provides its own implementation of a method already defined in its superclass.</p>
        </li>
        <li>
            <strong>Can you provide an example of method overriding in Java?</strong><br>
            <pre>
class Animal {
    void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Dog barks");
    }

    public static void main(String[] args) {
        Animal animal = new Dog();
        animal.sound();  // Outputs: Dog barks
    }
}
            </pre>
            <p><em>Answer:</em> The `Dog` class overrides the `sound` method of the `Animal` class to provide its own behavior. The method is called on an object of type `Animal` but it executes the `Dog` version of `sound` due to dynamic method dispatch.</p>
        </li>
        <li>
            <strong>What is "encapsulation" in OOP?</strong><br>
            <p><em>Answer:</em> Encapsulation is the practice of hiding the internal details of an object and only exposing necessary parts of it. This is typically achieved by defining private fields and providing public getter and setter methods to access and modify them.</p>
        </li>
        <li>
            <strong>Can you provide an example of encapsulation in Java?</strong><br>
            <pre>
class Person {
    private String name;
    private int age;

    // Getter and Setter for name
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }

    // Getter and Setter for age
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        if(age > 0) {
            this.age = age;
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Person person = new Person();
        person.setName("Alice");
        person.setAge(25);
        System.out.println(person.getName());  // Outputs: Alice
        System.out.println(person.getAge());   // Outputs: 25
    }
}
            </pre>
            <p><em>Answer:</em> The `Person` class encapsulates the `name` and `age` fields by making them private. It provides getter and setter methods to allow controlled access to these fields.</p>
        </li>
        <li>
            <strong>What is the purpose of the `this` keyword in Java?</strong><br>
            <p><em>Answer:</em> The `this` keyword is used to refer to the current instance of a class. It is commonly used to access instance variables and methods, and to distinguish between instance variables and local variables when they have the same name.</p>
        </li>
        <li>
            <strong>Can you provide an example of using the `this` keyword in Java?</strong><br>
            <pre>
class Person {
    private String name;

    public Person(String name) {
        this.name = name;  // Refers to the instance variable 'name'
    }

    public void displayInfo() {
        System.out.println("Name: " + this.name);  // Refers to the current object's 'name'
    }

    public static void main(String[] args) {
        Person person = new Person("Alice");
        person.displayInfo();  // Outputs: Name: Alice
    }
}
            </pre>
            <p><em>Answer:</em> The `this` keyword is used in the constructor and `displayInfo` method to refer to the current instance's `name` field.</p>
        </li>
        <li>
            <strong>What is the difference between "static" and "non-static" methods in Java?</strong><br>
            <p><em>Answer:</em> 
            - **Static methods** belong to the class rather than to any specific instance of the class. They can be called without creating an object of the class.
            - **Non-static methods** belong to an instance of the class and can only be called on an object of that class.</p>
        </li>
        <li>
            <strong>Can you provide an example of a static method in Java?</strong><br>
            <pre>
class MathOperations {
    static int add(int a, int b) {
        return a + b;
    }

    public static void main(String[] args) {
        System.out.println(MathOperations.add(10, 20));  // Outputs: 30
    }
}
            </pre>
            <p><em>Answer:</em> The `add` method is static and can be called on the class `MathOperations` directly, without creating an instance of the class.</p>
        </li>
    </ol>
</body>
</html>
