<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OOP Principles - Questions & Answers</title>
    <style type="text/css">
<!--
.style1 {font-family: Arial, Helvetica, sans-serif}
-->
    </style>
</head>
<body>
    <h1 class="style1">Object-Oriented Programming (OOP) Principles - Questions & Answers</h1>
    <h2 class="style1">Set 3</h2>
    <ol class="style1">
        <li>
            <strong>What is the difference between '=='' and 'equals()' in Java?</strong><br>
            <p><em>Answer:</em> The `==` operator compares the reference (memory address) of two objects, while the `equals()` method compares the actual content of the objects. `equals()` must be overridden in a class to provide meaningful comparison.</p>
        </li>
        <li>
            <strong>Can you provide an example comparing '==' and 'equals()' in Java?</strong><br>
            <pre>
class Person {
    String name;
    
    Person(String name) {
        this.name = name;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Person person = (Person) obj;
        return name.equals(person.name);
    }
}

public class Main {
    public static void main(String[] args) {
        Person person1 = new Person("John");
        Person person2 = new Person("John");
        
        System.out.println(person1 == person2); // Outputs: false
        System.out.println(person1.equals(person2)); // Outputs: true
    }
}
            </pre>
            <p><em>Answer:</em> In the example, `==` compares the references (false because they are different objects), whereas `equals()` compares the content (true because the names are the same).</p>
        </li>
        <li>
            <strong>What is the difference between 'final', 'finally', and 'finalize' in Java?</strong><br>
            <p><em>Answer:</em> 
            - `final` is used to declare constants, prevent method overriding, or prevent inheritance.
            - `finally` is used to define a block of code that will always be executed, regardless of whether an exception was thrown.
            - `finalize` is a method that is called by the garbage collector before an object is removed from memory.            </p>
        </li>
        <li>
            <strong>Can you provide an example of using 'final', 'finally', and 'finalize'?</strong><br>
            <pre>
class MyClass {
    final int CONSTANT = 10; // 'final' for constant

    void myMethod() {
        try {
            int result = 10 / 0;
        } catch (ArithmeticException e) {
            System.out.println("Error: " + e.getMessage());
        } finally {
            System.out.println("This block always executes.");
        }
    }

    @Override
    protected void finalize() {
        System.out.println("Finalize method called before garbage collection.");
    }
}

public class Main {
    public static void main(String[] args) {
        MyClass obj = new MyClass();
        obj.myMethod();
        obj = null; // The object is ready for garbage collection
        System.gc(); // Request garbage collection
    }
}
            </pre>
            <p><em>Answer:</em> In this example, the `CONSTANT` field is declared as `final`, the `finally` block always runs regardless of an exception, and the `finalize()` method is called by the garbage collector before the object is removed from memory.</p>
        </li>
        <li>
            <strong>What is the concept of "composition" in OOP?</strong><br>
            <p><em>Answer:</em> Composition is a design principle in OOP where one object contains references to other objects, which may be used as part of its functionality. It represents a "has-a" relationship.</p>
        </li>
        <li>
            <strong>Can you provide an example of composition in Java?</strong><br>
            <pre>
class Engine {
    void start() {
        System.out.println("Engine starting");
    }
}

class Car {
    private Engine engine; // Car has an Engine (composition)

    Car(Engine engine) {
        this.engine = engine;
    }

    void startCar() {
        engine.start();
        System.out.println("Car starting");
    }
}

public class Main {
    public static void main(String[] args) {
        Engine engine = new Engine();
        Car car = new Car(engine);
        car.startCar();
    }
}
            </pre>
            <p><em>Answer:</em> In the example, the `Car` class has an `Engine` object, demonstrating a "has-a" relationship, which is composition.</p>
        </li>
        <li>
            <strong>What is the concept of "aggregation" in OOP?</strong><br>
            <p><em>Answer:</em> Aggregation is a special form of association where one object is associated with another but both can exist independently. It represents a "whole-part" relationship but without strong ownership.</p>
        </li>
        <li>
            <strong>Can you provide an example of aggregation in Java?</strong><br>
            <pre>
class Department {
    private String name;
    
    Department(String name) {
        this.name = name;
    }

    String getName() {
        return name;
    }
}

class Employee {
    private String name;
    private Department department; // Employee belongs to Department (aggregation)

    Employee(String name, Department department) {
        this.name = name;
        this.department = department;
    }

    void showInfo() {
        System.out.println("Employee: " + name + ", Department: " + department.getName());
    }
}

public class Main {
    public static void main(String[] args) {
        Department dept = new Department("Engineering");
        Employee emp = new Employee("John", dept);
        emp.showInfo(); // Outputs: Employee: John, Department: Engineering
    }
}
            </pre>
            <p><em>Answer:</em> In the example, the `Employee` object has a reference to a `Department` object, but both can exist independently, which demonstrates aggregation.</p>
        </li>
        <li>
            <strong>What is the concept of "association" in OOP?</strong><br>
            <p><em>Answer:</em> Association is a general term used to describe a relationship between two or more objects, which may be one-to-one, one-to-many, or many-to-many. Unlike composition or aggregation, association does not imply ownership.</p>
        </li>
        <li>
            <strong>Can you provide an example of association in Java?</strong><br>
            <pre>
class Author {
    private String name;

    Author(String name) {
        this.name = name;
    }

    String getName() {
        return name;
    }
}

class Book {
    private String title;
    private Author author; // Book is associated with Author (association)

    Book(String title, Author author) {
        this.title = title;
        this.author = author;
    }

    void displayInfo() {
        System.out.println("Book: " + title + ", Author: " + author.getName());
    }
}

public class Main {
    public static void main(String[] args) {
        Author author = new Author("J.K. Rowling");
        Book book = new Book("Harry Potter", author);
        book.displayInfo(); // Outputs: Book: Harry Potter, Author: J.K. Rowling
    }
}
            </pre>
            <p><em>Answer:</em> In the example, the `Book` object is associated with an `Author` object. This is an association where the objects are related but neither owns the other.</p>
        </li>
    </ol>
</body>
</html>
