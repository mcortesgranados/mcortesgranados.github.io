<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Untitled Document</title>
<style type="text/css">
<!--
.style1 {font-family: Arial, Helvetica, sans-serif}
.style2 {font-family: Arial, Helvetica, sans-serif; font-weight: bold; }
-->
</style>
</head>

<body>
<h1 class="style1">Java Serialization &amp; Deserialization - Questions &amp; Answers</h1>
<p class="style2"><a href="Java 08 Java Serialization Deserialization 01.mp3" target="_blank">Audio 1</a></p>
<h2 class="style1">Set 1</h2>
<ol class="style1">
  <li> <strong>What is serialization in Java?</strong><br />
      <p><em>Answer:</em> Serialization is the process of converting an object into a byte stream so that it can be saved to a file, sent over a network, or stored in a database.</p>
  </li>
  <li> <strong>What is deserialization in Java?</strong><br />
      <p><em>Answer:</em> Deserialization is the process of reconstructing an object from a byte stream, restoring it to its original state.</p>
  </li>
  <li> <strong>Which interface is used for serialization in Java?</strong><br />
      <p><em>Answer:</em> The `java.io.Serializable` interface is used to enable serialization in Java. It is a marker interface with no methods.</p>
  </li>
  <li> <strong>Provide a simple example of serialization in Java.</strong><br />
      <p><em>Answer:</em> Below is an example:</p>
    <pre><code>
import java.io.*;

class Person implements Serializable {
    private static final long serialVersionUID = 1L;
    String name;
    int age;

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

public class SerializeExample {
    public static void main(String[] args) {
        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;person.ser&quot;))) {
            Person p = new Person(&quot;John&quot;, 30);
            out.writeObject(p);
            System.out.println(&quot;Object serialized successfully.&quot;);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
            </code></pre>
  </li>
  <li> <strong>Provide a simple example of deserialization in Java.</strong><br />
      <p><em>Answer:</em> Below is an example:</p>
    <pre><code>
import java.io.*;

public class DeserializeExample {
    public static void main(String[] args) {
        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;person.ser&quot;))) {
            Person p = (Person) in.readObject();
            System.out.println(&quot;Deserialized Person: &quot; + p.name + &quot;, Age: &quot; + p.age);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
            </code></pre>
  </li>
  <li> <strong>What is the role of the serialVersionUID?</strong><br />
      <p><em>Answer:</em> The `serialVersionUID` is a unique identifier for a serialized class. It ensures compatibility during deserialization by verifying that the class version matches.</p>
  </li>
  <li> <strong>What happens if you don't declare serialVersionUID?</strong><br />
      <p><em>Answer:</em> If not declared, Java will generate a default `serialVersionUID`. If the class changes, deserialization may fail with an `InvalidClassException`.</p>
  </li>
  <li> <strong>Can static fields be serialized?</strong><br />
      <p><em>Answer:</em> No, static fields belong to the class rather than an instance, so they are not serialized.</p>
  </li>
  <li> <strong>What is the use of the transient keyword in serialization?</strong><br />
      <p><em>Answer:</em> The `transient` keyword prevents a field from being serialized, useful for sensitive data like passwords.</p>
  </li>
  <li> <strong>Give an example of using transient in serialization.</strong><br />
      <p><em>Answer:</em> Below is an example:</p>
  </li>
</ol>
<pre class="style1"><code>
import java.io.*;

class User implements Serializable {
    private static final long serialVersionUID = 1L;
    String username;
    transient String password; // This will not be serialized

    User(String username, String password) {
        this.username = username;
        this.password = password;
    }
}

public class TransientExample {
    public static void main(String[] args) {
        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;user.ser&quot;))) {
            User u = new User(&quot;admin&quot;, &quot;secret123&quot;);
            out.writeObject(u);
        } catch (IOException e) {
            e.printStackTrace();
        }

        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;user.ser&quot;))) {
            User u = (User) in.readObject();
            System.out.println(&quot;Deserialized User: &quot; + u.username + &quot;, Password: &quot; + u.password); 
            // Password will be null
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
            </code>




    </pre>
<h1 class="style1">Java Serialization &amp; Deserialization - Questions &amp; Answers</h1>
<h2 class="style1">Set 2</h2>
<ol class="style1">
  <li> <strong>What will happen if a superclass does not implement Serializable but a subclass does?</strong><br />
      <p><em>Answer:</em> If a superclass is not serializable, then the fields of the superclass will not be serialized. Only the fields of the subclass will be serialized.</p>
  </li>
  <li> <strong>How can you serialize a non-serializable superclass?</strong><br />
      <p><em>Answer:</em> You need to manually serialize the superclass fields by overriding `writeObject()` and `readObject()` methods.</p>
  </li>
  <li> <strong>Provide an example of serializing a subclass when the superclass is not serializable.</strong><br />
      <p><em>Answer:</em> Below is an example:</p>
    <pre><code>
import java.io.*;

class SuperClass {
    int superValue;

    public SuperClass(int superValue) {
        this.superValue = superValue;
    }
}

class SubClass extends SuperClass implements Serializable {
    private static final long serialVersionUID = 1L;
    int subValue;

    public SubClass(int superValue, int subValue) {
        super(superValue);
        this.subValue = subValue;
    }

    private void writeObject(ObjectOutputStream oos) throws IOException {
        oos.defaultWriteObject();
        oos.writeInt(superValue); // Manually serialize superclass field
    }

    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
        ois.defaultReadObject();
        superValue = ois.readInt(); // Manually deserialize superclass field
    }
}

public class SerializationTest {
    public static void main(String[] args) {
        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;subclass.ser&quot;))) {
            SubClass obj = new SubClass(10, 20);
            out.writeObject(obj);
        } catch (IOException e) {
            e.printStackTrace();
        }

        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;subclass.ser&quot;))) {
            SubClass obj = (SubClass) in.readObject();
            System.out.println(&quot;SuperClass Value: &quot; + obj.superValue);
            System.out.println(&quot;SubClass Value: &quot; + obj.subValue);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
            </code></pre>
  </li>
  <li> <strong>What happens if a class implements Serializable but its object contains a reference to a non-serializable class?</strong><br />
      <p><em>Answer:</em> Serialization will fail with a `NotSerializableException`.</p>
  </li>
  <li> <strong>How do you serialize an object containing non-serializable fields?</strong><br />
      <p><em>Answer:</em> You can either mark those fields as `transient` or implement custom serialization logic using `writeObject()` and `readObject()` methods.</p>
  </li>
  <li> <strong>What is Externalizable in Java?</strong><br />
      <p><em>Answer:</em> The `Externalizable` interface allows more control over serialization by providing `writeExternal()` and `readExternal()` methods.</p>
  </li>
  <li> <strong>Provide an example of using Externalizable.</strong><br />
      <p><em>Answer:</em> Below is an example:</p>
    <pre><code>
import java.io.*;

class Employee implements Externalizable {
    String name;
    int age;

    public Employee() {} // Mandatory no-arg constructor

    public Employee(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public void writeExternal(ObjectOutput out) throws IOException {
        out.writeObject(name);
        out.writeInt(age);
    }

    @Override
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
        name = (String) in.readObject();
        age = in.readInt();
    }
}

public class ExternalizableExample {
    public static void main(String[] args) {
        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;employee.ser&quot;))) {
            Employee emp = new Employee(&quot;Alice&quot;, 28);
            out.writeObject(emp);
        } catch (IOException e) {
            e.printStackTrace();
        }

        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;employee.ser&quot;))) {
            Employee emp = (Employee) in.readObject();
            System.out.println(&quot;Deserialized Employee: &quot; + emp.name + &quot;, Age: &quot; + emp.age);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
            </code></pre>
  </li>
  <li> <strong>What is the difference between Serializable and Externalizable?</strong><br />
      <p><em>Answer:</em> Serializable is marker interface, whereas Externalizable provides complete control over serialization using `writeExternal()` and `readExternal()` methods.</p>
  </li>
  <li> <strong>What happens if a serializable class has an instance of a class that does not implement Serializable?</strong><br />
      <p><em>Answer:</em> A `NotSerializableException` will be thrown unless the field is marked as `transient`.</p>
  </li>
  <li> <strong>Can you serialize an array in Java?</strong><br />
      <p><em>Answer:</em> Yes, if the array elements are serializable.</p>
  </li>
</ol>
<p class="style1">&nbsp;</p>
<h1 class="style1">Java Serialization &amp; Deserialization - Questions &amp; Answers</h1>
<h2 class="style1">Set 3</h2>
<ol class="style1">
  <li> <strong>What is the default serialization process in Java?</strong><br />
      <p><em>Answer:</em> Java provides default serialization using the `ObjectOutputStream` class, which writes objects to an output stream.</p>
  </li>
  <li> <strong>How can you avoid serializing sensitive data?</strong><br />
      <p><em>Answer:</em> Use the `transient` keyword to prevent certain fields from being serialized.</p>
  </li>
  <li> <strong>Provide an example of using transient fields in serialization.</strong><br />
      <p><em>Answer:</em></p>
    <pre><code>
import java.io.*;

class User implements Serializable {
    private static final long serialVersionUID = 1L;
    String username;
    transient String password; // Will not be serialized

    public User(String username, String password) {
        this.username = username;
        this.password = password;
    }
}

public class TransientExample {
    public static void main(String[] args) {
        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;user.ser&quot;))) {
            User user = new User(&quot;john_doe&quot;, &quot;secure123&quot;);
            out.writeObject(user);
        } catch (IOException e) {
            e.printStackTrace();
        }

        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;user.ser&quot;))) {
            User user = (User) in.readObject();
            System.out.println(&quot;Username: &quot; + user.username);
            System.out.println(&quot;Password: &quot; + user.password); // Will print 'null'
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
            </code></pre>
  </li>
  <li> <strong>What is the serialVersionUID in Java?</strong><br />
      <p><em>Answer:</em> `serialVersionUID` is a unique identifier that helps in version control of serialized objects.</p>
  </li>
  <li> <strong>What happens if serialVersionUID is not declared?</strong><br />
      <p><em>Answer:</em> The JVM generates one dynamically, but this can lead to compatibility issues when deserializing objects.</p>
  </li>
  <li> <strong>How do you customize serialization behavior?</strong><br />
      <p><em>Answer:</em> Override `writeObject()` and `readObject()` methods to define custom serialization behavior.</p>
  </li>
  <li> <strong>Provide an example of customizing serialization using writeObject and readObject.</strong><br />
      <p><em>Answer:</em></p>
    <pre><code>
import java.io.*;

class CustomUser implements Serializable {
    private static final long serialVersionUID = 1L;
    String username;
    transient String password;

    public CustomUser(String username, String password) {
        this.username = username;
        this.password = password;
    }

    private void writeObject(ObjectOutputStream oos) throws IOException {
        oos.defaultWriteObject();
        oos.writeObject(password != null ? &quot;encrypted-&quot; + password : null);
    }

    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
        ois.defaultReadObject();
        String encryptedPass = (String) ois.readObject();
        this.password = encryptedPass != null ? encryptedPass.replace(&quot;encrypted-&quot;, &quot;&quot;) : null;
    }
}

public class CustomSerialization {
    public static void main(String[] args) {
        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;customUser.ser&quot;))) {
            CustomUser user = new CustomUser(&quot;john_doe&quot;, &quot;mypassword&quot;);
            out.writeObject(user);
        } catch (IOException e) {
            e.printStackTrace();
        }

        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;customUser.ser&quot;))) {
            CustomUser user = (CustomUser) in.readObject();
            System.out.println(&quot;Username: &quot; + user.username);
            System.out.println(&quot;Password: &quot; + user.password); // Will print &quot;mypassword&quot;
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
            </code></pre>
  </li>
  <li> <strong>Can a static variable be serialized?</strong><br />
      <p><em>Answer:</em> No, because static variables are class-level variables, and serialization applies only to instance variables.</p>
  </li>
  <li> <strong>What happens if a superclass implements Serializable but the subclass does not?</strong><br />
      <p><em>Answer:</em> The subclass will still be serializable since serialization is inherited.</p>
  </li>
  <li> <strong>How can you prevent a class from being serialized?</strong><br />
      <p><em>Answer:</em> Do not implement `Serializable` or implement `writeObject()` and `readObject()` to throw `NotSerializableException`.</p>
  </li>
</ol>
<p class="style1">&nbsp;</p>
<h1 class="style1">Java Serialization &amp; Deserialization - Questions &amp; Answers</h1>
<h2 class="style1">Set 4</h2>
<ol class="style1">
  <li> <strong>Can an interface be serialized in Java?</strong><br />
      <p><em>Answer:</em> No, interfaces cannot be serialized directly since they do not have instance variables.</p>
  </li>
  <li> <strong>What happens if a non-serializable object is part of a serializable class?</strong><br />
      <p><em>Answer:</em> A `NotSerializableException` will be thrown unless the non-serializable object is marked as `transient`.</p>
  </li>
  <li> <strong>What is Externalizable in Java?</strong><br />
      <p><em>Answer:</em> `Externalizable` is an interface that allows full control over the serialization process by implementing `writeExternal()` and `readExternal()` methods.</p>
  </li>
  <li> <strong>Provide an example of using Externalizable.</strong><br />
      <p><em>Answer:</em></p>
    <pre><code>
import java.io.*;

class Employee implements Externalizable {
    private String name;
    private int age;

    public Employee() {} // Default constructor required for Externalizable

    public Employee(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public void writeExternal(ObjectOutput out) throws IOException {
        out.writeUTF(name);
        out.writeInt(age);
    }

    @Override
    public void readExternal(ObjectInput in) throws IOException {
        this.name = in.readUTF();
        this.age = in.readInt();
    }

    @Override
    public String toString() {
        return &quot;Employee{name='&quot; + name + &quot;', age=&quot; + age + &quot;}&quot;;
    }
}

public class ExternalizableExample {
    public static void main(String[] args) {
        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;employee.ser&quot;))) {
            Employee emp = new Employee(&quot;Alice&quot;, 30);
            out.writeObject(emp);
        } catch (IOException e) {
            e.printStackTrace();
        }

        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;employee.ser&quot;))) {
            Employee emp = (Employee) in.readObject();
            System.out.println(emp);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
            </code></pre>
  </li>
  <li> <strong>What is the difference between Serializable and Externalizable?</strong><br />
      <p><em>Answer:</em> `Serializable` is a marker interface that provides default serialization, while `Externalizable` requires explicit implementation of `writeExternal()` and `readExternal()`.</p>
  </li>
  <li> <strong>How does serialization work with inheritance?</strong><br />
      <p><em>Answer:</em> If a superclass implements `Serializable`, all subclasses automatically become serializable.</p>
  </li>
  <li> <strong>Can a constructor be called during deserialization?</strong><br />
      <p><em>Answer:</em> No, constructors are not called when an object is deserialized.</p>
  </li>
  <li> <strong>How can you serialize a singleton class?</strong><br />
      <p><em>Answer:</em> Implement `readResolve()` to return the existing instance instead of creating a new one.</p>
  </li>
  <li> <strong>Provide an example of serializing a singleton class.</strong><br />
      <p><em>Answer:</em></p>
    <pre><code>
import java.io.*;

class Singleton implements Serializable {
    private static final long serialVersionUID = 1L;
    private static final Singleton instance = new Singleton();

    private Singleton() {}

    public static Singleton getInstance() {
        return instance;
    }

    protected Object readResolve() {
        return instance;
    }
}

public class SingletonSerialization {
    public static void main(String[] args) {
        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;singleton.ser&quot;))) {
            out.writeObject(Singleton.getInstance());
        } catch (IOException e) {
            e.printStackTrace();
        }

        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;singleton.ser&quot;))) {
            Singleton s1 = (Singleton) in.readObject();
            Singleton s2 = Singleton.getInstance();
            System.out.println(&quot;Are both instances equal? &quot; + (s1 == s2)); // Should print true
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
            </code></pre>
  </li>
  <li> <strong>What is the role of ObjectOutputStream in serialization?</strong><br />
      <p><em>Answer:</em> `ObjectOutputStream` writes objects to an output stream, allowing them to be saved to a file or sent over a network.</p>
  </li>
</ol>
<p class="style1">&nbsp;</p>
<h1 class="style1">Java Serialization &amp; Deserialization - Questions &amp; Answers</h1>
<h2 class="style1">Set 5</h2>
<ol class="style1">
  <li> <strong>What is the role of ObjectInputStream in deserialization?</strong><br />
      <p><em>Answer:</em> `ObjectInputStream` reads objects from an input stream, reconstructing them in memory.</p>
  </li>
  <li> <strong>Can static variables be serialized in Java?</strong><br />
      <p><em>Answer:</em> No, static variables belong to the class, not an instance, so they are not serialized.</p>
  </li>
  <li> <strong>How can we prevent a variable from being serialized?</strong><br />
      <p><em>Answer:</em> By declaring it as `transient`.</p>
  </li>
  <li> <strong>Provide an example of using the transient keyword.</strong><br />
      <p><em>Answer:</em></p>
    <pre><code>
import java.io.*;

class User implements Serializable {
    private String username;
    private transient String password; // Won't be serialized

    public User(String username, String password) {
        this.username = username;
        this.password = password;
    }

    @Override
    public String toString() {
        return &quot;User{username='&quot; + username + &quot;', password='&quot; + password + &quot;'}&quot;;
    }
}

public class TransientExample {
    public static void main(String[] args) {
        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;user.ser&quot;))) {
            User user = new User(&quot;admin&quot;, &quot;secret123&quot;);
            out.writeObject(user);
        } catch (IOException e) {
            e.printStackTrace();
        }

        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;user.ser&quot;))) {
            User user = (User) in.readObject();
            System.out.println(user); // Password will be null
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
            </code></pre>
  </li>
  <li> <strong>Can final variables be serialized?</strong><br />
      <p><em>Answer:</em> Yes, final variables can be serialized like normal instance variables.</p>
  </li>
  <li> <strong>How can we customize the serialization process?</strong><br />
      <p><em>Answer:</em> By implementing the `writeObject(ObjectOutputStream out)` and `readObject(ObjectInputStream in)` methods.</p>
  </li>
  <li> <strong>Provide an example of customized serialization.</strong><br />
      <p><em>Answer:</em></p>
    <pre><code>
import java.io.*;

class Account implements Serializable {
    private String username;
    private transient String password;

    public Account(String username, String password) {
        this.username = username;
        this.password = password;
    }

    private void writeObject(ObjectOutputStream out) throws IOException {
        out.defaultWriteObject();
        out.writeUTF(encrypt(password));
    }

    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
        in.defaultReadObject();
        password = decrypt(in.readUTF());
    }

    private String encrypt(String data) {
        return new StringBuilder(data).reverse().toString(); // Simple encryption
    }

    private String decrypt(String data) {
        return new StringBuilder(data).reverse().toString(); // Simple decryption
    }

    @Override
    public String toString() {
        return &quot;Account{username='&quot; + username + &quot;', password='&quot; + password + &quot;'}&quot;;
    }
}

public class CustomSerialization {
    public static void main(String[] args) {
        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;account.ser&quot;))) {
            Account acc = new Account(&quot;user123&quot;, &quot;mypassword&quot;);
            out.writeObject(acc);
        } catch (IOException e) {
            e.printStackTrace();
        }

        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;account.ser&quot;))) {
            Account acc = (Account) in.readObject();
            System.out.println(acc); // Password should be correctly restored
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
            </code></pre>
  </li>
  <li> <strong>What happens if a superclass is not serializable, but a subclass is?</strong><br />
      <p><em>Answer:</em> The fields of the superclass will not be serialized, but the subclass fields will be.</p>
  </li>
  <li> <strong>How do you handle serialization of a class that extends a non-serializable superclass?</strong><br />
      <p><em>Answer:</em> Implement `writeObject()` and `readObject()` and manually serialize the superclass fields.</p>
  </li>
  <li> <strong>Provide an example of serializing a subclass with a non-serializable superclass.</strong><br />
      <p><em>Answer:</em></p>
    <pre><code>
import java.io.*;

class SuperClass {
    protected String superField;

    public SuperClass(String superField) {
        this.superField = superField;
    }
}

class SubClass extends SuperClass implements Serializable {
    private String subField;

    public SubClass(String superField, String subField) {
        super(superField);
        this.subField = subField;
    }

    private void writeObject(ObjectOutputStream out) throws IOException {
        out.defaultWriteObject();
        out.writeUTF(superField);
    }

    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
        in.defaultReadObject();
        superField = in.readUTF();
    }

    @Override
    public String toString() {
        return &quot;SubClass{superField='&quot; + superField + &quot;', subField='&quot; + subField + &quot;'}&quot;;
    }
}

public class SubclassSerialization {
    public static void main(String[] args) {
        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;subclass.ser&quot;))) {
            SubClass obj = new SubClass(&quot;SuperValue&quot;, &quot;SubValue&quot;);
            out.writeObject(obj);
        } catch (IOException e) {
            e.printStackTrace();
        }

        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;subclass.ser&quot;))) {
            SubClass obj = (SubClass) in.readObject();
            System.out.println(obj); // SuperField will be restored
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
            </code></pre>
  </li>
</ol>
<h1 class="style1">Java Serialization &amp; Deserialization - Questions &amp; Answers</h1>
<h2 class="style1">Set 6</h2>
<ol class="style1">
  <li> <strong>What is the use of `serialVersionUID`?</strong><br />
      <p><em>Answer:</em> It is a unique identifier that helps during deserialization to ensure the class version is compatible.</p>
  </li>
  <li> <strong>What happens if `serialVersionUID` is not defined?</strong><br />
      <p><em>Answer:</em> Java generates one automatically, but changes in the class may cause deserialization to fail.</p>
  </li>
  <li> <strong>Provide an example where `serialVersionUID` is used.</strong><br />
      <p><em>Answer:</em></p>
    <pre><code>
import java.io.*;

class Employee implements Serializable {
    private static final long serialVersionUID = 1L;
    private String name;
    private int age;

    public Employee(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot;Employee{name='&quot; + name + &quot;', age=&quot; + age + &quot;}&quot;;
    }
}

public class SerialUIDExample {
    public static void main(String[] args) {
        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;employee.ser&quot;))) {
            Employee emp = new Employee(&quot;John Doe&quot;, 30);
            out.writeObject(emp);
        } catch (IOException e) {
            e.printStackTrace();
        }

        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;employee.ser&quot;))) {
            Employee emp = (Employee) in.readObject();
            System.out.println(emp);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
            </code></pre>
  </li>
  <li> <strong>What is Externalizable in Java?</strong><br />
      <p><em>Answer:</em> `Externalizable` is an interface that allows custom serialization by overriding `writeExternal()` and `readExternal()`.</p>
  </li>
  <li> <strong>How is `Externalizable` different from `Serializable`?</strong><br />
      <p><em>Answer:</em> `Serializable` uses default serialization, while `Externalizable` requires explicit implementation of methods.</p>
  </li>
  <li> <strong>Provide an example of an Externalizable class.</strong><br />
      <p><em>Answer:</em></p>
    <pre><code>
import java.io.*;

class Student implements Externalizable {
    private String name;
    private int age;

    public Student() { } // Default constructor needed

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public void writeExternal(ObjectOutput out) throws IOException {
        out.writeUTF(name);
        out.writeInt(age);
    }

    @Override
    public void readExternal(ObjectInput in) throws IOException {
        name = in.readUTF();
        age = in.readInt();
    }

    @Override
    public String toString() {
        return &quot;Student{name='&quot; + name + &quot;', age=&quot; + age + &quot;}&quot;;
    }
}

public class ExternalizableExample {
    public static void main(String[] args) {
        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;student.ser&quot;))) {
            Student stu = new Student(&quot;Alice&quot;, 22);
            out.writeObject(stu);
        } catch (IOException e) {
            e.printStackTrace();
        }

        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;student.ser&quot;))) {
            Student stu = (Student) in.readObject();
            System.out.println(stu);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
            </code></pre>
  </li>
  <li> <strong>Can an interface be serialized?</strong><br />
      <p><em>Answer:</em> No, an interface cannot be serialized unless it is implemented by a class.</p>
  </li>
  <li> <strong>What happens if a class contains a non-serializable object?</strong><br />
      <p><em>Answer:</em> A `NotSerializableException` is thrown if an attempt is made to serialize it.</p>
  </li>
  <li> <strong>How can you serialize an object containing a non-serializable field?</strong><br />
      <p><em>Answer:</em> Mark the field as `transient` or implement custom serialization.</p>
  </li>
  <li> <strong>Provide an example where a non-serializable field is handled.</strong><br />
      <p><em>Answer:</em></p>
    <pre><code>
import java.io.*;

class Address {
    String city;

    public Address(String city) {
        this.city = city;
    }
}

class Person implements Serializable {
    private String name;
    private transient Address address; // Non-serializable

    public Person(String name, Address address) {
        this.name = name;
        this.address = address;
    }

    private void writeObject(ObjectOutputStream out) throws IOException {
        out.defaultWriteObject();
        out.writeUTF(address.city);
    }

    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
        in.defaultReadObject();
        address = new Address(in.readUTF());
    }

    @Override
    public String toString() {
        return &quot;Person{name='&quot; + name + &quot;', address=&quot; + address.city + &quot;}&quot;;
    }
}

public class NonSerializableHandling {
    public static void main(String[] args) {
        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;person.ser&quot;))) {
            Person person = new Person(&quot;Bob&quot;, new Address(&quot;New York&quot;));
            out.writeObject(person);
        } catch (IOException e) {
            e.printStackTrace();
        }

        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;person.ser&quot;))) {
            Person person = (Person) in.readObject();
            System.out.println(person);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
            </code></pre>
  </li>
</ol>
<h1 class="style1">Java Serialization &amp; Deserialization - Questions &amp; Answers</h1>
<h2 class="style1">Set 7</h2>
<ol class="style1">
  <li> <strong>Can a `static` field be serialized?</strong><br />
      <p><em>Answer:</em> No, `static` fields are not serialized as they belong to the class, not to an instance.</p>
  </li>
  <li> <strong>How can you serialize `static` fields?</strong><br />
      <p><em>Answer:</em> By manually handling them in `writeObject()` and `readObject()` methods.</p>
  </li>
  <li> <strong>Provide an example of serializing a `static` field.</strong><br />
      <p><em>Answer:</em></p>
    <pre><code>
import java.io.*;

class Company implements Serializable {
    private static String companyName = &quot;TechCorp&quot;;
    private int employeeCount;

    public Company(int employeeCount) {
        this.employeeCount = employeeCount;
    }

    private void writeObject(ObjectOutputStream out) throws IOException {
        out.defaultWriteObject();
        out.writeUTF(companyName);
    }

    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
        in.defaultReadObject();
        companyName = in.readUTF();
    }

    @Override
    public String toString() {
        return &quot;Company{employeeCount=&quot; + employeeCount + &quot;, companyName=&quot; + companyName + &quot;}&quot;;
    }
}

public class StaticFieldSerialization {
    public static void main(String[] args) {
        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;company.ser&quot;))) {
            Company company = new Company(100);
            out.writeObject(company);
        } catch (IOException e) {
            e.printStackTrace();
        }

        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;company.ser&quot;))) {
            Company company = (Company) in.readObject();
            System.out.println(company);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
            </code></pre>
  </li>
  <li> <strong>What is a `transient` keyword in Java?</strong><br />
      <p><em>Answer:</em> It prevents a field from being serialized.</p>
  </li>
  <li> <strong>What happens if a `transient` field is deserialized?</strong><br />
      <p><em>Answer:</em> The field will be initialized with its default value.</p>
  </li>
  <li> <strong>Provide an example of using `transient`.</strong><br />
      <p><em>Answer:</em></p>
    <pre><code>
import java.io.*;

class BankAccount implements Serializable {
    private String accountHolder;
    private transient double balance; // Won't be serialized

    public BankAccount(String accountHolder, double balance) {
        this.accountHolder = accountHolder;
        this.balance = balance;
    }

    @Override
    public String toString() {
        return &quot;BankAccount{accountHolder='&quot; + accountHolder + &quot;', balance=&quot; + balance + &quot;}&quot;;
    }
}

public class TransientExample {
    public static void main(String[] args) {
        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;account.ser&quot;))) {
            BankAccount account = new BankAccount(&quot;Alice&quot;, 1000.00);
            out.writeObject(account);
        } catch (IOException e) {
            e.printStackTrace();
        }

        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;account.ser&quot;))) {
            BankAccount account = (BankAccount) in.readObject();
            System.out.println(account);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
            </code></pre>
  </li>
  <li> <strong>Can we serialize an `enum` in Java?</strong><br />
      <p><em>Answer:</em> Yes, `enum` is serializable by default.</p>
  </li>
  <li> <strong>Provide an example of serializing an `enum`.</strong><br />
      <p><em>Answer:</em></p>
    <pre><code>
import java.io.*;

enum Status {
    ACTIVE, INACTIVE, PENDING
}

class User implements Serializable {
    private String name;
    private Status status;

    public User(String name, Status status) {
        this.name = name;
        this.status = status;
    }

    @Override
    public String toString() {
        return &quot;User{name='&quot; + name + &quot;', status=&quot; + status + &quot;}&quot;;
    }
}

public class EnumSerialization {
    public static void main(String[] args) {
        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;user.ser&quot;))) {
            User user = new User(&quot;John&quot;, Status.ACTIVE);
            out.writeObject(user);
        } catch (IOException e) {
            e.printStackTrace();
        }

        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;user.ser&quot;))) {
            User user = (User) in.readObject();
            System.out.println(user);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
            </code></pre>
  </li>
  <li> <strong>How can you prevent a class from being serialized?</strong><br />
      <p><em>Answer:</em> By not implementing `Serializable` or throwing an exception in `writeObject()`.</p>
  </li>
  <li> <strong>What happens if a class does not implement `Serializable` but is part of a serializable object?</strong><br />
      <p><em>Answer:</em> A `NotSerializableException` is thrown.</p>
  </li>
</ol>
<p class="style1">&nbsp;</p>
<h1 class="style1">Java Serialization &amp; Deserialization - Questions &amp; Answers</h1>
<h2 class="style1">Set 8</h2>
<ol class="style1">
  <li> <strong>What happens if a superclass is not serializable but the subclass is?</strong><br />
      <p><em>Answer:</em> The non-serializable superclass must have a no-argument constructor, or a `NotSerializableException` will be thrown.</p>
  </li>
  <li> <strong>How do you serialize a class with a non-serializable superclass?</strong><br />
      <p><em>Answer:</em> Ensure the superclass has a no-argument constructor and manually serialize its fields.</p>
  </li>
  <li> <strong>Provide an example of serializing a class with a non-serializable superclass.</strong><br />
      <p><em>Answer:</em></p>
    <pre><code>
import java.io.*;

class NonSerializableSuperClass {
    int superData;

    public NonSerializableSuperClass(int superData) {
        this.superData = superData;
    }
}

class SerializableSubClass extends NonSerializableSuperClass implements Serializable {
    int subData;

    public SerializableSubClass(int superData, int subData) {
        super(superData);
        this.subData = subData;
    }

    private void writeObject(ObjectOutputStream out) throws IOException {
        out.defaultWriteObject();
        out.writeInt(superData);
    }

    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
        in.defaultReadObject();
        superData = in.readInt();
    }

    @Override
    public String toString() {
        return &quot;SerializableSubClass{superData=&quot; + superData + &quot;, subData=&quot; + subData + &quot;}&quot;;
    }
}

public class SuperClassSerialization {
    public static void main(String[] args) {
        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;subclass.ser&quot;))) {
            SerializableSubClass obj = new SerializableSubClass(10, 20);
            out.writeObject(obj);
        } catch (IOException e) {
            e.printStackTrace();
        }

        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;subclass.ser&quot;))) {
            SerializableSubClass obj = (SerializableSubClass) in.readObject();
            System.out.println(obj);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
            </code></pre>
  </li>
  <li> <strong>What is `Externalizable` in Java?</strong><br />
      <p><em>Answer:</em> It is an interface that provides complete control over serialization by implementing `writeExternal()` and `readExternal()` methods.</p>
  </li>
  <li> <strong>Provide an example of using `Externalizable`.</strong><br />
      <p><em>Answer:</em></p>
    <pre><code>
import java.io.*;

class Employee implements Externalizable {
    private String name;
    private int age;

    public Employee() {} // Required for Externalizable

    public Employee(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public void writeExternal(ObjectOutput out) throws IOException {
        out.writeUTF(name);
        out.writeInt(age);
    }

    @Override
    public void readExternal(ObjectInput in) throws IOException {
        name = in.readUTF();
        age = in.readInt();
    }

    @Override
    public String toString() {
        return &quot;Employee{name='&quot; + name + &quot;', age=&quot; + age + &quot;}&quot;;
    }
}

public class ExternalizableExample {
    public static void main(String[] args) {
        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;employee.ser&quot;))) {
            Employee emp = new Employee(&quot;Alice&quot;, 30);
            out.writeObject(emp);
        } catch (IOException e) {
            e.printStackTrace();
        }

        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;employee.ser&quot;))) {
            Employee emp = (Employee) in.readObject();
            System.out.println(emp);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
            </code></pre>
  </li>
  <li> <strong>What is the key difference between `Serializable` and `Externalizable`?</strong><br />
      <p><em>Answer:</em> `Serializable` allows default serialization, while `Externalizable` provides full control over serialization and deserialization.</p>
  </li>
  <li> <strong>Can you serialize a class with a `final` field?</strong><br />
      <p><em>Answer:</em> Yes, but `final` fields are restored only if the class uses default serialization.</p>
  </li>
  <li> <strong>Provide an example of serializing a class with a `final` field.</strong><br />
      <p><em>Answer:</em></p>
    <pre><code>
import java.io.*;

class ImmutableClass implements Serializable {
    private final String name;

    public ImmutableClass(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return &quot;ImmutableClass{name='&quot; + name + &quot;'}&quot;;
    }
}

public class FinalFieldSerialization {
    public static void main(String[] args) {
        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;immutable.ser&quot;))) {
            ImmutableClass obj = new ImmutableClass(&quot;Immutable&quot;);
            out.writeObject(obj);
        } catch (IOException e) {
            e.printStackTrace();
        }

        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;immutable.ser&quot;))) {
            ImmutableClass obj = (ImmutableClass) in.readObject();
            System.out.println(obj);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
            </code></pre>
  </li>
  <li> <strong>What happens if an exception occurs during deserialization?</strong><br />
      <p><em>Answer:</em> The deserialization process fails, and an `IOException` or `ClassNotFoundException` is thrown.</p>
  </li>
  <li> <strong>How can you avoid `InvalidClassException` in serialization?</strong><br />
      <p><em>Answer:</em> Ensure the `serialVersionUID` remains the same or explicitly define it in the class.</p>
  </li>
</ol>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<h1 class="style1">Java Serialization &amp; Deserialization - Questions &amp; Answers</h1>
<h2 class="style1">Set 9</h2>
<ol class="style1">
  <li> <strong>What is `serialVersionUID` in Java serialization?</strong><br />
      <p><em>Answer:</em> `serialVersionUID` is a unique identifier for each class, used to ensure that a loaded class is compatible with the serialized object during deserialization.</p>
  </li>
  <li> <strong>How do you generate a `serialVersionUID`?</strong><br />
      <p><em>Answer:</em> It can be manually defined or generated by the IDE (e.g., using `serialver` command) or automatically by the Java compiler.</p>
  </li>
  <li> <strong>Provide an example of using `serialVersionUID` in a class.</strong><br />
      <p><em>Answer:</em></p>
    <pre><code>
import java.io.*;

class MyClass implements Serializable {
    private static final long serialVersionUID = 1L;

    private String name;

    public MyClass(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return &quot;MyClass{name='&quot; + name + &quot;'}&quot;;
    }
}

public class SerializationWithUID {
    public static void main(String[] args) {
        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;myclass.ser&quot;))) {
            MyClass obj = new MyClass(&quot;Serialization&quot;);
            out.writeObject(obj);
        } catch (IOException e) {
            e.printStackTrace();
        }

        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;myclass.ser&quot;))) {
            MyClass obj = (MyClass) in.readObject();
            System.out.println(obj);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
            </code></pre>
  </li>
  <li> <strong>What is the significance of `transient` keyword in serialization?</strong><br />
      <p><em>Answer:</em> The `transient` keyword prevents a field from being serialized, meaning its value will not be saved or restored during serialization and deserialization.</p>
  </li>
  <li> <strong>Provide an example of using `transient` in serialization.</strong><br />
      <p><em>Answer:</em></p>
    <pre><code>
import java.io.*;

class Person implements Serializable {
    private String name;
    private transient String password;

    public Person(String name, String password) {
        this.name = name;
        this.password = password;
    }

    @Override
    public String toString() {
        return &quot;Person{name='&quot; + name + &quot;', password='&quot; + password + &quot;'}&quot;;
    }
}

public class SerializationWithTransient {
    public static void main(String[] args) {
        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;person.ser&quot;))) {
            Person person = new Person(&quot;Alice&quot;, &quot;secretPassword&quot;);
            out.writeObject(person);
        } catch (IOException e) {
            e.printStackTrace();
        }

        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;person.ser&quot;))) {
            Person person = (Person) in.readObject();
            System.out.println(person);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
            </code></pre>
  </li>
  <li> <strong>What is `NotSerializableException`?</strong><br />
      <p><em>Answer:</em> It is an exception thrown when an object that is being serialized does not implement the `Serializable` interface.</p>
  </li>
  <li> <strong>What happens if a class has a `static` field during serialization?</strong><br />
      <p><em>Answer:</em> Static fields are not serialized because they belong to the class rather than to an instance of the class.</p>
  </li>
  <li> <strong>Provide an example of serializing an object with a `static` field.</strong><br />
      <p><em>Answer:</em></p>
    <pre><code>
import java.io.*;

class MyClass implements Serializable {
    private static final long serialVersionUID = 1L;
    private String name;
    private static int counter = 0;

    public MyClass(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return &quot;MyClass{name='&quot; + name + &quot;', counter=&quot; + counter + &quot;}&quot;;
    }

    public static void incrementCounter() {
        counter++;
    }
}

public class SerializationWithStaticField {
    public static void main(String[] args) {
        MyClass.incrementCounter();
        
        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;myclass_with_static.ser&quot;))) {
            MyClass obj = new MyClass(&quot;StaticFieldExample&quot;);
            out.writeObject(obj);
        } catch (IOException e) {
            e.printStackTrace();
        }

        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;myclass_with_static.ser&quot;))) {
            MyClass obj = (MyClass) in.readObject();
            System.out.println(obj);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
            </code></pre>
  </li>
  <li> <strong>What is the role of `ObjectOutputStream` in serialization?</strong><br />
      <p><em>Answer:</em> `ObjectOutputStream` is used to serialize objects to an output stream, converting them into a byte stream that can be saved to a file or transmitted over a network.</p>
  </li>
  <li> <strong>What is the role of `ObjectInputStream` in deserialization?</strong><br />
      <p><em>Answer:</em> `ObjectInputStream` is used to read serialized objects from an input stream and deserialize them back into their original form.</p>
  </li>
  <li> <strong>What is `WriteObjectException`?</strong><br />
      <p><em>Answer:</em> This exception is thrown if there is an issue while writing an object to the stream, such as a `NotSerializableException` or `IOException`.</p>
  </li>
</ol>
<p class="style1">&nbsp;</p>
<h1 class="style1">Java Serialization &amp; Deserialization - Questions &amp; Answers</h1>
<h2 class="style1">Set 10</h2>
<ol class="style1">
  <li> <strong>What is the difference between `Serializable` and `Externalizable` in Java?</strong><br />
      <p><em>Answer:</em> `Serializable` is a marker interface that indicates the class can be serialized, whereas `Externalizable` allows you to explicitly define how the object is serialized and deserialized by overriding `writeExternal()` and `readExternal()` methods.</p>
  </li>
  <li> <strong>What are the methods defined in the `Externalizable` interface?</strong><br />
      <p><em>Answer:</em> The `Externalizable` interface defines two methods: `writeExternal(ObjectOutput out)` and `readExternal(ObjectInput in)`. These methods allow custom serialization and deserialization of objects.</p>
  </li>
  <li> <strong>Provide an example of using `Externalizable`.</strong><br />
      <p><em>Answer:</em></p>
    <pre><code>
import java.io.*;

class MyClass implements Externalizable {
    private String name;
    private int age;

    public MyClass() {
        // No-arg constructor is required for Externalizable
    }

    public MyClass(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public void writeExternal(ObjectOutput out) throws IOException {
        out.writeObject(name);
        out.writeInt(age);
    }

    @Override
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
        name = (String) in.readObject();
        age = in.readInt();
    }

    @Override
    public String toString() {
        return &quot;MyClass{name='&quot; + name + &quot;', age=&quot; + age + &quot;}&quot;;
    }
}

public class SerializationWithExternalizable {
    public static void main(String[] args) {
        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;externalizable.ser&quot;))) {
            MyClass obj = new MyClass(&quot;John&quot;, 30);
            out.writeObject(obj);
        } catch (IOException e) {
            e.printStackTrace();
        }

        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;externalizable.ser&quot;))) {
            MyClass obj = (MyClass) in.readObject();
            System.out.println(obj);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
            </code></pre>
  </li>
  <li> <strong>What is the default behavior of serialization in Java?</strong><br />
      <p><em>Answer:</em> By default, Java performs the serialization of all non-static and non-transient fields of an object. The class must implement the `Serializable` interface for this to happen.</p>
  </li>
  <li> <strong>Can a transient field be restored during deserialization?</strong><br />
      <p><em>Answer:</em> No, a `transient` field is not restored during deserialization. It is excluded from the serialized form of the object.</p>
  </li>
  <li> <strong>What is the role of `ObjectStreamClass` in serialization?</strong><br />
      <p><em>Answer:</em> `ObjectStreamClass` is used by the `ObjectInputStream` and `ObjectOutputStream` to obtain information about the structure of a class, including its fields and methods, during serialization and deserialization.</p>
  </li>
  <li> <strong>What happens if the class version changes between serialization and deserialization?</strong><br />
      <p><em>Answer:</em> If the class version changes and the `serialVersionUID` does not match between the serialized object and the current version of the class, a `InvalidClassException` is thrown during deserialization.</p>
  </li>
  <li> <strong>What is the role of `readObject()` and `writeObject()` methods in custom serialization?</strong><br />
      <p><em>Answer:</em> `readObject()` and `writeObject()` methods are used in custom serialization where you can control the process of reading and writing object fields during serialization and deserialization.</p>
  </li>
  <li> <strong>What are the consequences of serializing a class that contains a `final` field?</strong><br />
      <p><em>Answer:</em> Serializing a class that contains a `final` field is allowed. The value of the `final` field will be preserved during deserialization.</p>
  </li>
</ol>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
</body>
</html>
