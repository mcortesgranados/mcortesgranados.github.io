<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Functional Programming in Java Questions - Set 1</title>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        .question-set {
            margin-bottom: 20px;
        }
        .question {
            margin-bottom: 10px;
        }
        .answer {
            margin-left: 20px;
            font-style: italic;
        }
    .style1 {font-weight: bold}
.style2 {font-weight: bold}
.style3 {font-weight: bold}
.style4 {font-weight: bold}
.style5 {font-weight: bold}
.style6 {font-weight: bold}
.style7 {font-weight: bold}
.style8 {font-weight: bold}
    .style10 {
	color: #669966;
	font-weight: bold;
	font-size: 18px;
}
    </style>
    
    
        <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            margin: 0;
            padding: 20px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background-color: #ffffff;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        th {
            background-color: #4CAF50;
            color: white;
            font-size: 14px;
        }

        td {
            font-size: 13px;
            color: #555;
        }

        tr:hover {
            background-color: #f1f1f1;
        }

        caption {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
        }

        .table-container {
            overflow-x: auto;
            margin-top: 20px;
        }
.style12 {color: #006699}
        .style12Copy {
	color: #FFFFFF;
	background-color: #006699;
	font-weight: bold;
	font-size: 12px;
	font-style: normal;
}
        .style10Copy {
	color: #FFFFFF;
	font-weight: bold;
	font-size: 24px;
	background-color: #660033;
}
        </style>
</head>
<body>

        <h3>Java 97 Functional Programming in Java</h3>
<p>

</p>
        <table cellpadding="0" cellspacing="0">
          <col span="0">
          <tr>
            <td>
              <p>&nbsp;</p>
            </div></td>
            <td class="style12Copy"><div align="center">Feature</div></td>
            <td class="style12Copy"><div align="center">Description</div></td>
            <td class="style12Copy"><div align="center">Java 8+ Support</div></td>
            <td class="style12Copy"><div align="center">Example</div></td>
            <td class="style12Copy"><div align="center">Use Cases</div></td>
            <td class="style12Copy"><div align="center">Advantages</div></td>
            <td class="style12Copy"><div align="center">Disadvantages</div></td>
            <td class="style12Copy"><div align="center">When to Use</div></td>
            <td class="style12Copy"><div align="center">What to Do Instead with JDK &lt; 8    (Classic Programming)</div></td>
            <td class="style12Copy"><div align="center">Disadvantage of Classic    Alternative</div></td>
          </tr>
          <tr>
            <td><div align="center" class="style2">
              <p>1</p>
            </div></td>
            <td class="style10Copy">Lambdas</td>
            <td>Enables writing concise and    expressive code with anonymous functions that can be passed as arguments.</td>
            <td>Java 8+</td>
            <td>(a, b) -&gt; a + b</td>
            <td>Event handling, callback    functions, collection transformations</td>
            <td>Simplifies code, more readable</td>
            <td>Debugging can be harder, less    readable for complex logic</td>
            <td>When writing concise, expressive    code with no need for reuse</td>
            <td>Use anonymous inner classes to    implement interfaces, e.g., (new ActionListener() {...})</td>
            <td>Anonymous inner classes are more    verbose, harder to debug, and lead to larger code size</td>
          </tr>
          <tr>
            <td><p>&nbsp;</p>
                </div></td>
            <td class="style12Copy"><div align="center">Feature</div></td>
            <td class="style12Copy"><div align="center">Description</div></td>
            <td class="style12Copy"><div align="center">Java 8+ Support</div></td>
            <td class="style12Copy"><div align="center">Example</div></td>
            <td class="style12Copy"><div align="center">Use Cases</div></td>
            <td class="style12Copy"><div align="center">Advantages</div></td>
            <td class="style12Copy"><div align="center">Disadvantages</div></td>
            <td class="style12Copy"><div align="center">When to Use</div></td>
            <td class="style12Copy"><div align="center">What to Do Instead with JDK &lt; 8    (Classic Programming)</div></td>
            <td class="style12Copy"><div align="center">Disadvantage of Classic    Alternative</div></td>
          </tr>
          <tr>
            <td><div align="center" class="style3">
              <p>2</p>
            </div></td>
            <td class="style10Copy"><strong>Streams    API</strong></td>
            <td>Allows functional-style operations    on sequences of elements, e.g., filtering, mapping, reducing.</td>
            <td>Java 8+</td>
            <td>stream.filter(x -&gt; x &gt; 5)</td>
            <td>Data transformation, filtering    collections, parallel processing</td>
            <td>Efficient, concise, declarative    style</td>
            <td>Can be overused leading to    performance bottlenecks</td>
            <td>When processing collections or    sequences of data</td>
            <td>Use traditional for or foreach    loops for iteration and manual filtering or mapping</td>
            <td>More complex to manage iteration    manually, prone to errors, and less readable</td>
          </tr>
          <tr>
            <td><p>&nbsp;</p>
                </div></td>
            <td class="style12Copy"><div align="center">Feature</div></td>
            <td class="style12Copy"><div align="center">Description</div></td>
            <td class="style12Copy"><div align="center">Java 8+ Support</div></td>
            <td class="style12Copy"><div align="center">Example</div></td>
            <td class="style12Copy"><div align="center">Use Cases</div></td>
            <td class="style12Copy"><div align="center">Advantages</div></td>
            <td class="style12Copy"><div align="center">Disadvantages</div></td>
            <td class="style12Copy"><div align="center">When to Use</div></td>
            <td class="style12Copy"><div align="center">What to Do Instead with JDK &lt; 8    (Classic Programming)</div></td>
            <td class="style12Copy"><div align="center">Disadvantage of Classic    Alternative</div></td>
          </tr>
          <tr>
            <td><div align="center" class="style4">
              <p>3</p>
            </div></td>
            <td class="style10Copy"><strong>Immutability</strong></td>
            <td>Objects whose state cannot be    changed after initialization, encouraging safe, side-effect-free code.</td>
            <td>Java 8+</td>
            <td>List&lt;String&gt; list =    List.of(&quot;A&quot;, &quot;B&quot;);</td>
            <td>Multi-threaded applications,    concurrency, safe state handling</td>
            <td>Thread-safe, predictable behavior</td>
            <td>More memory consumption (if    creating many objects)</td>
            <td>When dealing with shared or    mutable state, or concurrency</td>
            <td>Use final variables and avoid    setters; ensure data is copied when needed</td>
            <td>Manual deep copying can lead to    inefficient memory usage and boilerplate code</td>
          </tr>
          <tr>
            <td><p>&nbsp;</p>
                </div></td>
            <td class="style12Copy"><div align="center">Feature</div></td>
            <td class="style12Copy"><div align="center">Description</div></td>
            <td class="style12Copy"><div align="center">Java 8+ Support</div></td>
            <td class="style12Copy"><div align="center">Example</div></td>
            <td class="style12Copy"><div align="center">Use Cases</div></td>
            <td class="style12Copy"><div align="center">Advantages</div></td>
            <td class="style12Copy"><div align="center">Disadvantages</div></td>
            <td class="style12Copy"><div align="center">When to Use</div></td>
            <td class="style12Copy"><div align="center">What to Do Instead with JDK &lt; 8    (Classic Programming)</div></td>
            <td class="style12Copy"><div align="center">Disadvantage of Classic    Alternative</div></td>
          </tr>
          <tr>
            <td><div align="center" class="style5">
              <p>4</p>
            </div></td>
            <td class="style10Copy"><strong>First-Class    Functions</strong></td>
            <td>Functions are first-class objects,    meaning they can be passed as arguments, returned from other functions, and    assigned to variables.</td>
            <td>Java 8+ (via Lambdas)</td>
            <td>Function&lt;Integer, String&gt;    func = x -&gt; String.valueOf(x);</td>
            <td>Higher-order functions, callback    handling</td>
            <td>Flexibility, cleaner code</td>
            <td>More abstract, could confuse    developers unfamiliar with FP</td>
            <td>When passing behavior (i.e.,    functions) as arguments</td>
            <td>Use interfaces to pass behavior    (e.g., Runnable, Callable) or anonymous classes</td>
            <td>Interfaces can become overly    complex or cluttered with many methods</td>
          </tr>
          <tr>
            <td><p>&nbsp;</p>
                </div></td>
            <td class="style12Copy"><div align="center">Feature</div></td>
            <td class="style12Copy"><div align="center">Description</div></td>
            <td class="style12Copy"><div align="center">Java 8+ Support</div></td>
            <td class="style12Copy"><div align="center">Example</div></td>
            <td class="style12Copy"><div align="center">Use Cases</div></td>
            <td class="style12Copy"><div align="center">Advantages</div></td>
            <td class="style12Copy"><div align="center">Disadvantages</div></td>
            <td class="style12Copy"><div align="center">When to Use</div></td>
            <td class="style12Copy"><div align="center">What to Do Instead with JDK &lt; 8    (Classic Programming)</div></td>
            <td class="style12Copy"><div align="center">Disadvantage of Classic    Alternative</div></td>
          </tr>
          <tr>
            <td><div align="center" class="style6">
              <p>5</p>
            </div></td>
            <td class="style10Copy"><strong>Higher-Order    Functions</strong></td>
            <td>Functions that take other    functions as arguments or return functions as results.</td>
            <td>Java 8+ (via Lambdas)</td>
            <td>public static &lt;T&gt;    Function&lt;T, Integer&gt; compose(Function&lt;T, Integer&gt; f) { return    f.andThen(x -&gt; x + 1); }</td>
            <td>Function composition, custom    transformations</td>
            <td>Reduces code repetition,    modularity</td>
            <td>More abstract, harder to debug</td>
            <td>When functions need to be reused    or composed</td>
            <td>Use nested functions or classes to    simulate composition manually</td>
            <td>Manual composition is error-prone,    verbose, and can create unnecessary complexity</td>
          </tr>
          <tr>
            <td><p>&nbsp;</p>
                </div></td>
            <td class="style12Copy"><div align="center">Feature</div></td>
            <td class="style12Copy"><div align="center">Description</div></td>
            <td class="style12Copy"><div align="center">Java 8+ Support</div></td>
            <td class="style12Copy"><div align="center">Example</div></td>
            <td class="style12Copy"><div align="center">Use Cases</div></td>
            <td class="style12Copy"><div align="center">Advantages</div></td>
            <td class="style12Copy"><div align="center">Disadvantages</div></td>
            <td class="style12Copy"><div align="center">When to Use</div></td>
            <td class="style12Copy"><div align="center">What to Do Instead with JDK &lt; 8    (Classic Programming)</div></td>
            <td class="style12Copy"><div align="center">Disadvantage of Classic    Alternative</div></td>
          </tr>
          <tr>
            <td><div align="center" class="style7">
              <p>6</p>
            </div></td>
            <td class="style10Copy"><strong>Map,    Filter, Reduce</strong></td>
            <td>Common functional operations for    processing collections (filtering, transforming, and reducing elements).</td>
            <td>Java 8+</td>
            <td>stream.map(String::toUpperCase)</td>
            <td>Data manipulation, collection    processing, aggregations</td>
            <td>Clear, declarative operations,    easy chaining</td>
            <td>Can lead to performance hits with    large data</td>
            <td>When performing transformations,    filtering, or reductions on collections</td>
            <td>Use loops, forEach, and manual if checks to filter, transform, or reduce data</td>
            <td>Manual looping is more verbose,    harder to manage, and prone to bugs</td>
          </tr>
          <tr>
            <td><p>&nbsp;</p>
                </div></td>
            <td class="style12Copy"><div align="center">Feature</div></td>
            <td class="style12Copy"><div align="center">Description</div></td>
            <td class="style12Copy"><div align="center">Java 8+ Support</div></td>
            <td class="style12Copy"><div align="center">Example</div></td>
            <td class="style12Copy"><div align="center">Use Cases</div></td>
            <td class="style12Copy"><div align="center">Advantages</div></td>
            <td class="style12Copy"><div align="center">Disadvantages</div></td>
            <td class="style12Copy"><div align="center">When to Use</div></td>
            <td class="style12Copy"><div align="center">What to Do Instead with JDK &lt; 8    (Classic Programming)</div></td>
            <td class="style12Copy"><div align="center">Disadvantage of Classic    Alternative</div></td>
          </tr>
          <tr>
            <td><div align="center" class="style8">
              <p>7</p>
            </div></td>
            <td class="style10Copy"><strong>Optional</strong></td>
            <td>A container for optional values,    preventing null references and    forcing safe handling of absent values.</td>
            <td>Java 8+</td>
            <td>Optional&lt;String&gt; opt =    Optional.of(&quot;Hello&quot;);</td>
            <td>Avoiding NullPointerException, safe data retrieval</td>
            <td>Avoids null references, clear    intentions</td>
            <td>Can introduce overhead if overused</td>
            <td>When there is uncertainty about    the presence of a value</td>
            <td>Use null checks or try-catch blocks to handle nullability manually</td>
            <td>Null checks    can become cumbersome and less readable, leading to more complex code</td>
          </tr>
          <tr>
            <td><p>&nbsp;</p>
                </div></td>
            <td class="style12Copy"><div align="center">Feature</div></td>
            <td class="style12Copy"><div align="center">Description</div></td>
            <td class="style12Copy"><div align="center">Java 8+ Support</div></td>
            <td class="style12Copy"><div align="center">Example</div></td>
            <td class="style12Copy"><div align="center">Use Cases</div></td>
            <td class="style12Copy"><div align="center">Advantages</div></td>
            <td class="style12Copy"><div align="center">Disadvantages</div></td>
            <td class="style12Copy"><div align="center">When to Use</div></td>
            <td class="style12Copy"><div align="center">What to Do Instead with JDK &lt; 8    (Classic Programming)</div></td>
            <td class="style12Copy"><div align="center">Disadvantage of Classic    Alternative</div></td>
          </tr>
          <tr>
            <td><div align="center"><strong>8</strong></div></td>
            <td class="style10Copy"><strong>Function    Interfaces</strong></td>
            <td>Functional interfaces like Function, Predicate, Consumer,    and Supplier represent    various functions with different signatures.</td>
            <td>Java 8+</td>
            <td>Predicate&lt;Integer&gt; isEven =    x -&gt; x % 2 == 0;</td>
            <td>Reusable function definitions,    higher-order functions</td>
            <td>Modularity, reusability</td>
            <td>More verbose, can add complexity</td>
            <td>When creating reusable, composable    functions</td>
            <td>Define custom interfaces and    implement them using anonymous classes or concrete classes</td>
            <td>More boilerplate code, less    concise</td>
          </tr>
          <tr>
            <td><p>&nbsp;</p>
                </div></td>
            <td class="style12Copy"><div align="center">Feature</div></td>
            <td class="style12Copy"><div align="center">Description</div></td>
            <td class="style12Copy"><div align="center">Java 8+ Support</div></td>
            <td class="style12Copy"><div align="center">Example</div></td>
            <td class="style12Copy"><div align="center">Use Cases</div></td>
            <td class="style12Copy"><div align="center">Advantages</div></td>
            <td class="style12Copy"><div align="center">Disadvantages</div></td>
            <td class="style12Copy"><div align="center">When to Use</div></td>
            <td class="style12Copy"><div align="center">What to Do Instead with JDK &lt; 8    (Classic Programming)</div></td>
            <td class="style12Copy"><div align="center">Disadvantage of Classic    Alternative</div></td>
          </tr>
          <tr>
            <td><div align="center"><strong>9</strong></div></td>
            <td class="style10Copy"><strong>Pure    Functions</strong></td>
            <td>Functions that do not have side    effects and always return the same result for the same input.</td>
            <td>Java 8+ (can be implemented)</td>
            <td>public int add(int a, int b) {    return a + b; }</td>
            <td>Predictable, testable code,    parallelism</td>
            <td>No side effects, easy to test</td>
            <td>Not suitable for I/O operations or    state-modifying operations</td>
            <td>When a function should be    predictable, without side effects</td>
            <td>Use static methods that don't    modify external state or rely on class fields</td>
            <td>Static methods for    side-effect-free logic are more verbose and less flexible</td>
          </tr>
          <tr>
            <td><p>&nbsp;</p>
                </div></td>
            <td class="style12Copy"><div align="center">Feature</div></td>
            <td class="style12Copy"><div align="center">Description</div></td>
            <td class="style12Copy"><div align="center">Java 8+ Support</div></td>
            <td class="style12Copy"><div align="center">Example</div></td>
            <td class="style12Copy"><div align="center">Use Cases</div></td>
            <td class="style12Copy"><div align="center">Advantages</div></td>
            <td class="style12Copy"><div align="center">Disadvantages</div></td>
            <td class="style12Copy"><div align="center">When to Use</div></td>
            <td class="style12Copy"><div align="center">What to Do Instead with JDK &lt; 8    (Classic Programming)</div></td>
            <td class="style12Copy"><div align="center">Disadvantage of Classic    Alternative</div></td>
          </tr>
          <tr>
            <td><div align="center"><strong>10</strong></div></td>
            <td class="style10Copy"><strong>Recursion</strong></td>
            <td>A function that calls itself,    often used to replace iterative loops.</td>
            <td>Java 8+ (can be implemented)</td>
            <td>public int factorial(int n) {    return (n == 1) ? 1 : n * factorial(n - 1); }</td>
            <td>Problems involving tree    structures, fractals</td>
            <td>Simplifies complex algorithms,    elegant solutions</td>
            <td>Stack overflow issues, less    performant</td>
            <td>When recursion depth is large or    performance is critical</td>
            <td>Use traditional for or while    loops instead of recursion for iterative solutions</td>
            <td>Recursive solutions can be harder    to read and prone to stack overflow if not optimized</td>
          </tr>
          <tr>
            <td><p>&nbsp;</p>
                </div></td>
            <td class="style12Copy"><div align="center">Feature</div></td>
            <td class="style12Copy"><div align="center">Description</div></td>
            <td class="style12Copy"><div align="center">Java 8+ Support</div></td>
            <td class="style12Copy"><div align="center">Example</div></td>
            <td class="style12Copy"><div align="center">Use Cases</div></td>
            <td class="style12Copy"><div align="center">Advantages</div></td>
            <td class="style12Copy"><div align="center">Disadvantages</div></td>
            <td class="style12Copy"><div align="center">When to Use</div></td>
            <td class="style12Copy"><div align="center">What to Do Instead with JDK &lt; 8    (Classic Programming)</div></td>
            <td class="style12Copy"><div align="center">Disadvantage of Classic    Alternative</div></td>
          </tr>
          <tr >
            <td><div align="center"><strong>11</strong></div></td>
            <td class="style10Copy"><strong>Tail    Recursion</strong></td>
            <td>Optimized recursion where the    recursive call is the last operation, avoiding stack overflow.</td>
            <td>Java does not natively optimize    tail recursion, but it can be manually implemented</td>
            <td>public int factorial(int n, int    accumulator) { return (n == 1) ? accumulator : factorial(n - 1, n *    accumulator); }</td>
            <td>No stack overflow, more memory    efficient</td>
            <td>Needs manual optimization</td>
            <td>When recursion depth is large or    performance is critical</td>
            <td>Use loops instead, as tail call    optimization is not native to Java</td>
            <td>Tail recursion is complex to    implement and manage manually</td>
            <td></td>
          </tr>
          <tr>
            <td><p>&nbsp;</p>
                </div></td>
            <td class="style12Copy"><div align="center">Feature</div></td>
            <td class="style12Copy"><div align="center">Description</div></td>
            <td class="style12Copy"><div align="center">Java 8+ Support</div></td>
            <td class="style12Copy"><div align="center">Example</div></td>
            <td class="style12Copy"><div align="center">Use Cases</div></td>
            <td class="style12Copy"><div align="center">Advantages</div></td>
            <td class="style12Copy"><div align="center">Disadvantages</div></td>
            <td class="style12Copy"><div align="center">When to Use</div></td>
            <td class="style12Copy"><div align="center">What to Do Instead with JDK &lt; 8    (Classic Programming)</div></td>
            <td class="style12Copy"><div align="center">Disadvantage of Classic    Alternative</div></td>
          </tr>
          <tr>
            <td><div align="center"><strong>12</strong></div></td>
            <td class="style10Copy"><strong>Memoization</strong></td>
            <td>Storing results of expensive    function calls and reusing them when the same inputs occur.</td>
            <td>Can be implemented manually.</td>
            <td>Map&lt;Integer, Integer&gt; cache    = new HashMap&lt;&gt;(); public int fibonacci(int n) { return    cache.computeIfAbsent(n, x -&gt; fibonacci(x - 1) + fibonacci(x - 2)); }</td>
            <td>Improves performance for repeated    function calls</td>
            <td>Increased memory usage, more    complex logic</td>
            <td>When functions are repeatedly    called with the same arguments</td>
            <td>Use a Map or HashMap    for manual caching in loops or function calls</td>
            <td>Manual caching can increase memory    usage and complicate code</td>
            <td></td>
          </tr>
          <tr>
            <td><p>&nbsp;</p>
                </div></td>
            <td class="style12Copy"><div align="center">Feature</div></td>
            <td class="style12Copy"><div align="center">Description</div></td>
            <td class="style12Copy"><div align="center">Java 8+ Support</div></td>
            <td class="style12Copy"><div align="center">Example</div></td>
            <td class="style12Copy"><div align="center">Use Cases</div></td>
            <td class="style12Copy"><div align="center">Advantages</div></td>
            <td class="style12Copy"><div align="center">Disadvantages</div></td>
            <td class="style12Copy"><div align="center">When to Use</div></td>
            <td class="style12Copy"><div align="center">What to Do Instead with JDK &lt; 8    (Classic Programming)</div></td>
            <td class="style12Copy"><div align="center">Disadvantage of Classic    Alternative</div></td>
          </tr>
          <tr>
            <td><div align="center"><strong>13</strong></div></td>
            <td class="style10Copy"><strong>Type    Inference</strong></td>
            <td>Java’s ability to infer the type    of variables or expressions, reducing boilerplate code.</td>
            <td>Java 10+</td>
            <td>var list = new    ArrayList&lt;String&gt;();</td>
            <td>Reduces boilerplate, improves    readability</td>
            <td>May obscure the variable's type,    reduces explicitness</td>
            <td>When type clarity isn't critical    or when using a concise syntax</td>
            <td>Explicitly declare the type of    variables and collections (e.g., ArrayList&lt;String&gt;    list = new ArrayList&lt;&gt;();)</td>
            <td>Explicit type declarations can    clutter code, making it less flexible</td>
            <td></td>
          </tr>
          <tr>
            <td><p>&nbsp;</p>
                </div></td>
            <td class="style12Copy"><div align="center">Feature</div></td>
            <td class="style12Copy"><div align="center">Description</div></td>
            <td class="style12Copy"><div align="center">Java 8+ Support</div></td>
            <td class="style12Copy"><div align="center">Example</div></td>
            <td class="style12Copy"><div align="center">Use Cases</div></td>
            <td class="style12Copy"><div align="center">Advantages</div></td>
            <td class="style12Copy"><div align="center">Disadvantages</div></td>
            <td class="style12Copy"><div align="center">When to Use</div></td>
            <td class="style12Copy"><div align="center">What to Do Instead with JDK &lt; 8    (Classic Programming)</div></td>
            <td class="style12Copy"><div align="center">Disadvantage of Classic    Alternative</div></td>
          </tr>
          <tr>
            <td><div align="center"><strong>15</strong></div></td>
            <td class="style10Copy"><strong>Method    References</strong></td>
            <td>A shorthand notation for invoking    a method on an object or class.</td>
            <td>Java 8+</td>
            <td>List&lt;String&gt; list =    Arrays.asList(&quot;a&quot;, &quot;b&quot;);    list.forEach(System.out::println);</td>
            <td>Cleaner, more concise code</td>
            <td>Can become hard to debug with    complex method references</td>
            <td>When referring to existing methods    to improve code readability</td>
            <td>Use lambda expressions or    explicitly call methods directly</td>
            <td>Direct method calls can become    verbose and less flexible</td>
            <td></td>
          </tr>
          <tr>
            <td><p>&nbsp;</p>
                </div></td>
            <td class="style12Copy"><div align="center">Feature</div></td>
            <td class="style12Copy"><div align="center">Description</div></td>
            <td class="style12Copy"><div align="center">Java 8+ Support</div></td>
            <td class="style12Copy"><div align="center">Example</div></td>
            <td class="style12Copy"><div align="center">Use Cases</div></td>
            <td class="style12Copy"><div align="center">Advantages</div></td>
            <td class="style12Copy"><div align="center">Disadvantages</div></td>
            <td class="style12Copy"><div align="center">When to Use</div></td>
            <td class="style12Copy"><div align="center">What to Do Instead with JDK &lt; 8    (Classic Programming)</div></td>
            <td class="style12Copy"><div align="center">Disadvantage of Classic    Alternative</div></td>
          </tr>
          <tr>
            <td><div align="center"><strong>17</strong></div></td>
            <td class="style10Copy"><strong>Function    Composition</strong></td>
            <td>Combining functions where the    output of one function is passed as the input to another.</td>
            <td>Java 8+ (via Function.andThen() or Function.compose())</td>
            <td>Function&lt;Integer, Integer&gt;    addOne = x -&gt; x + 1; Function&lt;Integer, Integer&gt; multiplyByTwo = x    -&gt; x * 2; Function&lt;Integer, Integer&gt; addOneThenMultiply =    addOne.andThen(multiplyByTwo);</td>
            <td>Reusable transformations, modular    code</td>
            <td>Can become less readable with many    composed functions</td>
            <td>When functions can be broken down    into reusable, composable pieces</td>
            <td>Manually chain method calls or use    nested function calls</td>
            <td>Chaining manually can lead to    cluttered and hard-to-read code</td>
            <td></td>
          </tr>
          <tr>
            <td><p>&nbsp;</p>
                </div></td>
            <td class="style12Copy"><div align="center">Feature</div></td>
            <td class="style12Copy"><div align="center">Description</div></td>
            <td class="style12Copy"><div align="center">Java 8+ Support</div></td>
            <td class="style12Copy"><div align="center">Example</div></td>
            <td class="style12Copy"><div align="center">Use Cases</div></td>
            <td class="style12Copy"><div align="center">Advantages</div></td>
            <td class="style12Copy"><div align="center">Disadvantages</div></td>
            <td class="style12Copy"><div align="center">When to Use</div></td>
            <td class="style12Copy"><div align="center">What to Do Instead with JDK &lt; 8    (Classic Programming)</div></td>
            <td class="style12Copy"><div align="center">Disadvantage of Classic    Alternative</div></td>
          </tr>
          <tr >
            <td><div align="center"><strong>18</strong></div></td>
            <td class="style10Copy"><strong>Lazy    Evaluation</strong></td>
            <td>Delayed evaluation of expressions    until their values are required, optimizing performance.</td>
            <td>Java 8+ (via Stream API)</td>
            <td>Stream&lt;Integer&gt; stream =    Stream.of(1, 2, 3, 4); stream.filter(x -&gt; x &gt;    2).forEach(System.out::println);</td>
            <td>Performance optimization,    on-demand computation</td>
            <td>Lazy streams can introduce    complexity, harder to debug</td>
            <td>When working with large datasets    or computations that may not be needed</td>
            <td>Use if conditions to control flow and computation</td>
            <td>Manual flow control is less    efficient and can complicate logic</td>
            <td></td>
          </tr>
        </table>


    <div class="question-set">
        <p>&nbsp;</p>
        <p>&nbsp;</p>
        <h3>Set 1</h3>
        <p><strong><a href="Java 97 Functional Programming in Java 01.mp3" target="_blank">Audio 1</a> - <a href="Java 97 Functional Programming in Java 02.mp3" target="_blank">Audio 2</a></strong></p>
<div class="question">
            <p><strong>1. What is functional programming in Java?</strong></p>
            <p class="answer">Functional programming in Java is a programming paradigm that treats computation as the evaluation of mathematical functions and avoids changing state or mutable data. Java supports functional programming through features like lambda expressions, streams, and functional interfaces.</p>
      </div>

        <div class="question">
            <p><strong>2. What are lambda expressions in Java?</strong></p>
            <p class="answer">Lambda expressions are a feature in Java introduced in Java 8, allowing you to express instances of functional interfaces (interfaces with a single abstract method) in a more concise and readable way. The syntax of a lambda expression is `(parameters) -> expression`.</p>
            <pre><code>
List<String> names = Arrays.asList("John", "Jane", "Doe");
names.forEach(name -> System.out.println(name));
            </code></pre>
        </div>

        <div class="question">
            <p><strong>3. What is a functional interface in Java?</strong></p>
            <p class="answer">A functional interface is an interface that contains exactly one abstract method, and it can have multiple default or static methods. These interfaces are used as the target types for lambda expressions and method references in Java.</p>
        </div>

        <div class="question">
            <p><strong>4. How do you use the Stream API in Java?</strong></p>
            <p class="answer">The Stream API in Java allows you to process sequences of elements (like collections) in a functional style. You can use methods like `map()`, `filter()`, `reduce()`, `collect()`, etc., to process elements in a pipeline fashion.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = numbers.stream()
                .filter(n -> n % 2 == 0)
                .mapToInt(Integer::intValue)
                .sum();
System.out.println(sum);  // Output: 6
            </code></pre>
        </div>

        <div class="question">
            <p><strong>5. What is the difference between `map()` and `flatMap()` in Java Streams?</strong></p>
            <p class="answer">The `map()` function transforms each element of the stream into another element, while `flatMap()` is used to flatten nested structures like lists within lists, transforming each element of the stream into a stream and then flattening them into a single stream.</p>
        </div>

        <div class="question">
            <p><strong>6. What is the purpose of the `Optional` class in Java?</strong></p>
            <p class="answer">The `Optional` class is used to represent a value that may or may not be present. It is often used to avoid null pointer exceptions and provide a way to handle missing values more functionally, using methods like `ifPresent()`, `map()`, and `orElse()`.</p>
            <pre><code>
Optional<String> name = Optional.of("John");
name.ifPresent(n -> System.out.println("Hello, " + n));
            </code></pre>
        </div>

        <div class="question">
            <p><strong>7. How do you use method references in Java?</strong></p>
            <p class="answer">Method references in Java provide a shorthand way of writing lambda expressions that call a specific method. The syntax for method references is `ClassName::methodName`, and it can be used in place of lambda expressions where a method is directly invoked.</p>
            <pre><code>
List<String> names = Arrays.asList("John", "Jane", "Doe");
names.forEach(System.out::println);  // Equivalent to: name -> System.out.println(name)
            </code></pre>
        </div>

        <div class="question">
            <p><strong>8. What is the `reduce()` function in Java Streams?</strong></p>
            <p class="answer">The `reduce()` function in Java Streams is used to combine elements of the stream into a single result, typically by performing some kind of aggregation or accumulation operation, such as sum, multiplication, etc.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = numbers.stream().reduce(0, Integer::sum);
System.out.println(sum);  // Output: 15
            </code></pre>
        </div>

        <div class="question">
            <p><strong>9. How do you filter elements in a stream in Java?</strong></p>
            <p class="answer">You can filter elements in a stream using the `filter()` method, which takes a predicate as an argument. It returns a new stream that only contains the elements that match the predicate.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> evenNumbers = numbers.stream()
                                  .filter(n -> n % 2 == 0)
                                  .collect(Collectors.toList());
System.out.println(evenNumbers);  // Output: [2, 4]
            </code></pre>
        </div>

      <div class="question">
            <p><strong>10. What are the key benefits of functional programming in Java?</strong></p>
          <p class="answer">The key benefits of functional programming in Java include improved readability, less boilerplate code, easier parallelism, more declarative code, and better handling of side effects. It also promotes immutability and safer handling of state.</p>
          <p class="answer">&nbsp;</p>
          <h3>Set 2</h3>
          <div class="question">
            <p><strong>11. What is a higher-order function in Java?</strong></p>
            <p class="answer">A higher-order function is a function that takes one or more functions as parameters, returns a function as a result, or both. Java’s functional interfaces, lambda expressions, and method references allow for higher-order functions.</p>
          </div>
          <div class="question">
            <p><strong>12. How does immutability work in functional programming in Java?</strong></p>
            <p class="answer">In functional programming, immutability refers to the idea that objects cannot be modified after they are created. In Java, this can be achieved by using final variables, making fields of objects final, and returning new objects rather than modifying existing ones.</p>
          </div>
          <div class="question">
            <p><strong>13. What is the difference between `collect()` and `toList()` in Java Streams?</strong></p>
            <p class="answer">`collect()` is a terminal operation that transforms the elements of the stream into a different form, such as a collection. `toList()` is a collector that collects the stream elements into a `List`. While `toList()` is a specific collector, `collect()` is more general and can be used with any collector.</p>
          </div>
          <div class="question">
            <p><strong>14. What does the `peek()` method do in Java Streams?</strong></p>
            <p class="answer">The `peek()` method in Java Streams is an intermediate operation that allows you to see the elements of the stream as they are processed. It is mainly used for debugging purposes or logging, as it does not modify the stream.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.stream()
       .peek(n -> System.out.println("Processing: " + n))
       .map(n -> n * 2)
       .collect(Collectors.toList());
            </code></pre>
          </div>
          <div class="question">
            <p><strong>15. What are default methods in Java interfaces?</strong></p>
            <p class="answer">Default methods are methods in interfaces that have a body. They allow interfaces to provide default implementations of methods, which helps maintain backward compatibility when new methods are added to interfaces.</p>
          </div>
          <div class="question">
            <p><strong>16. How does Java handle side effects in functional programming?</strong></p>
            <p class="answer">In functional programming, side effects are discouraged. Java handles side effects by encouraging immutability, stateless functions, and the use of pure functions, which don’t change any state outside of their scope or rely on external state.</p>
          </div>
          <div class="question">
            <p><strong>17. How can you create a stream from an array in Java?</strong></p>
            <p class="answer">You can create a stream from an array in Java using the `Arrays.stream()` method. This method returns a stream for the given array.</p>
            <pre><code>
int[] numbers = {1, 2, 3, 4, 5};
IntStream stream = Arrays.stream(numbers);
stream.forEach(System.out::println);
            </code></pre>
          </div>
          <div class="question">
            <p><strong>18. What is a `UnaryOperator` in Java?</strong></p>
            <p class="answer">A `UnaryOperator` is a functional interface in Java that represents a function that takes one argument of a specific type and returns a result of the same type. It is a specialization of the `Function` interface for cases where the input and output types are the same.</p>
            <pre><code>
UnaryOperator<Integer> doubleValue = x -> x * 2;
System.out.println(doubleValue.apply(5));  // Output: 10
            </code></pre>
          </div>
          <div class="question">
            <p><strong>19. What is a `BiFunction` in Java?</strong></p>
            <p class="answer">A `BiFunction` is a functional interface in Java that represents a function that takes two arguments of possibly different types and returns a result of another type. It is often used to combine or transform two input values into one output value.</p>
            <pre><code>
BiFunction add = (a, b) -> a + b;
System.out.println(add.apply(5, 10));  // Output: 15
            </code></pre>
          </div>
          <div class="question">
            <p><strong>20. How do you chain multiple operations in Java Streams?</strong></p>
            <p class="answer">In Java Streams, multiple operations can be chained together to form a pipeline. The intermediate operations (such as `map()`, `filter()`, etc.) are applied to the stream and the final result is produced by a terminal operation (like `collect()` or `forEach()`). Each operation returns a new stream.</p>
            <pre><code>
List<String> names = Arrays.asList("John", "Jane", "Alice", "Bob");
List<String> result = names.stream()
                           .filter(name -> name.length() > 3)
                           .map(String::toUpperCase)
                           .collect(Collectors.toList());
System.out.println(result);  // Output: [JOHN, JANE, ALICE]
            </code></pre>
          </div>
          <h3>Set 3</h3>
          <div class="question">
            <p><strong>21. What is a `Supplier` in Java?</strong></p>
            <p class="answer">A `Supplier` is a functional interface in Java that represents a function that takes no arguments and returns a result. It is often used when you need to supply a value but don't need to provide input data.</p>
            <pre><code>
Supplier<String> supplier = () -> "Hello, World!";
System.out.println(supplier.get());  // Output: Hello, World!
            </code></pre>
          </div>
          <div class="question">
            <p><strong>22. How can you use `Optional` to handle null values in Java?</strong></p>
            <p class="answer">`Optional` is a container object which may or may not contain a value. It is used to avoid `NullPointerException`. You can use methods like `isPresent()`, `ifPresent()`, or `orElse()` to handle values safely.</p>
            <pre><code>
Optional<String> name = Optional.ofNullable(null);
System.out.println(name.orElse("Default Value"));  // Output: Default Value
            </code></pre>
          </div>
          <div class="question">
            <p><strong>23. What is the `reduce()` method in Java Streams?</strong></p>
            <p class="answer">The `reduce()` method in Java Streams is a terminal operation that combines the elements of a stream into a single result. It takes an associative binary operator and can be used to accumulate values, such as summing or multiplying numbers.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = numbers.stream().reduce(0, (a, b) -> a + b);
System.out.println(sum);  // Output: 15
            </code></pre>
          </div>
          <div class="question">
            <p><strong>24. What is a `Stream` in Java?</strong></p>
            <p class="answer">A `Stream` in Java is a sequence of elements supporting sequential and parallel aggregate operations. Streams are not data structures, but they provide a functional approach to processing data in a declarative manner.</p>
          </div>
          <div class="question">
            <p><strong>25. How can you create an empty stream in Java?</strong></p>
            <p class="answer">You can create an empty stream in Java using the `Stream.empty()` method. This returns an empty stream with no elements.</p>
            <pre><code>
Stream<String> emptyStream = Stream.empty();
emptyStream.forEach(System.out::println);  // No output
            </code></pre>
          </div>
          <div class="question">
            <p><strong>26. What is a `Consumer` in Java?</strong></p>
            <p class="answer">A `Consumer` is a functional interface that represents a function that takes one argument and returns no result. It is commonly used to perform operations like printing, modifying, or logging data.</p>
            <pre><code>
Consumer<String> printer = message -> System.out.println(message);
printer.accept("Hello, World!");  // Output: Hello, World!
            </code></pre>
          </div>
          <div class="question">
            <p><strong>27. What does the `map()` method do in Java Streams?</strong></p>
            <p class="answer">The `map()` method is an intermediate operation that transforms the elements of the stream by applying a function to each element. It produces a new stream consisting of the transformed elements.</p>
            <pre><code>
List<String> names = Arrays.asList("john", "jane", "bob");
List<String> uppercasedNames = names.stream()
                                    .map(String::toUpperCase)
                                    .collect(Collectors.toList());
System.out.println(uppercasedNames);  // Output: [JOHN, JANE, BOB]
            </code></pre>
          </div>
          <div class="question">
            <p><strong>28. What is the difference between `filter()` and `map()` in Java Streams?</strong></p>
            <p class="answer">`filter()` is used to remove elements from the stream based on a condition, whereas `map()` transforms the elements of the stream using a provided function. `filter()` returns a new stream with elements that match the condition, while `map()` changes each element of the stream.</p>
          </div>
          <div class="question">
            <p><strong>29. How do you handle parallel streams in Java?</strong></p>
            <p class="answer">Parallel streams in Java are created by calling the `parallel()` method on a stream. This allows operations on the stream to be executed concurrently, which can improve performance on large datasets. However, you should use parallel streams with caution, as they may not always improve performance due to overhead or issues with thread safety.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.parallelStream().forEach(System.out::println);
            </code></pre>
          </div>
          <div class="question">
            <p><strong>30. What is the significance of `forEach()` in Java Streams?</strong></p>
            <p class="answer">The `forEach()` method is a terminal operation that performs an action for each element of the stream. It is typically used for operations like printing or logging the elements of the stream. It cannot be used after a terminal operation as it consumes the stream.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.stream().forEach(System.out::println);
            </code></pre>
          </div>
          <p>&nbsp;</p>
          <h3>Set 4</h3>
          <div class="question">
            <p><strong>31. What is the `flatMap()` method in Java Streams?</strong></p>
            <p class="answer">The `flatMap()` method is an intermediate operation that maps each element of the stream to another stream and flattens the resulting streams into a single stream. It is used when the transformation results in multiple elements per original element.</p>
            <pre><code>
List<List<String>> listOfLists = Arrays.asList(
    Arrays.asList("apple", "banana"),
    Arrays.asList("orange", "pear")
);
List<String> flattenedList = listOfLists.stream()
                                       .flatMap(List::stream)
                                       .collect(Collectors.toList());
System.out.println(flattenedList);  // Output: [apple, banana, orange, pear]
            </code></pre>
          </div>
          <div class="question">
            <p><strong>32. What is the difference between `collect()` and `toList()` in Java Streams?</strong></p>
            <p class="answer">`collect()` is a terminal operation that transforms a stream into a different form, typically a collection. `toList()` is a specific collector that collects the elements of the stream into a `List`. While `collect()` is a more general operation, `toList()` is a predefined collector for lists.</p>
          </div>
          <div class="question">
            <p><strong>33. How can you find the maximum value in a stream in Java?</strong></p>
            <p class="answer">To find the maximum value in a stream, you can use the `max()` method with a comparator. This returns an `Optional` that contains the maximum value, or is empty if the stream is empty.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
Optional<Integer> max = numbers.stream().max(Integer::compareTo);
max.ifPresent(System.out::println);  // Output: 5
            </code></pre>
          </div>
          <div class="question">
            <p><strong>34. What is method reference in Java and how is it used with streams?</strong></p>
            <p class="answer">A method reference in Java is a shorthand for lambda expressions that call a method. It is used to refer to a method of an object or class without executing it. In streams, method references can replace lambda expressions for invoking methods directly on elements of the stream.</p>
            <pre><code>
List<String> names = Arrays.asList("john", "jane", "bob");
names.stream().map(String::toUpperCase).forEach(System.out::println);  // Output: JOHN, JANE, BOB
            </code></pre>
          </div>
          <div class="question">
            <p><strong>35. What does the `allMatch()` method do in Java Streams?</strong></p>
            <p class="answer">The `allMatch()` method is a short-circuiting terminal operation that checks if all elements in the stream satisfy a given predicate. It returns `true` if all elements match the predicate, or `false` otherwise.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(2, 4, 6, 8);
boolean allEven = numbers.stream().allMatch(n -> n % 2 == 0);
System.out.println(allEven);  // Output: true
            </code></pre>
          </div>
          <div class="question">
            <p><strong>36. How do you handle exceptions in lambda expressions in Java?</strong></p>
            <p class="answer">Lambda expressions in Java do not allow checked exceptions directly. However, you can handle exceptions within a lambda by either catching them or using a custom wrapper method that handles the exception.</p>
            <pre><code>
Runnable task = () -> {
    try {
        // Code that might throw an exception
    } catch (Exception e) {
        e.printStackTrace();
    }
};
task.run();
            </code></pre>
          </div>
          <div class="question">
            <p><strong>37. What is the `forEachOrdered()` method in Java Streams?</strong></p>
            <p class="answer">The `forEachOrdered()` method is similar to `forEach()`, but it guarantees that the elements will be processed in the encounter order, even if the stream is processed in parallel. This is useful when the order of processing is important.</p>
            <pre><code>
List<String> names = Arrays.asList("john", "jane", "bob");
names.parallelStream().forEachOrdered(System.out::println);
            </code></pre>
          </div>
          <div class="question">
            <p><strong>38. How can you convert a stream into an array in Java?</strong></p>
            <p class="answer">To convert a stream into an array, you can use the `toArray()` method. This method returns an array containing the elements of the stream.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
Integer[] array = numbers.stream().toArray(Integer[]::new);
System.out.println(Arrays.toString(array));  // Output: [1, 2, 3, 4, 5]
            </code></pre>
          </div>
          <div class="question">
            <p><strong>39. What is the purpose of the `peek()` method in Java Streams?</strong></p>
            <p class="answer">The `peek()` method is an intermediate operation that allows you to inspect the elements of the stream as they are processed. It is typically used for debugging or logging purposes. Note that it does not modify the elements of the stream.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.stream().peek(System.out::println).map(n -> n * 2).collect(Collectors.toList());
            </code></pre>
          </div>
          <div class="question">
            <p><strong>40. What is `toMap()` in Java Streams?</strong></p>
            <p class="answer">The `toMap()` method is a collector in Java Streams that allows you to transform the elements of the stream into a map. You need to provide a key and a value for the map. The method returns a `Map` containing the elements of the stream.</p>
            <pre><code>
List<String> names = Arrays.asList("john", "jane", "bob");
Map nameMap = names.stream()
                                    .collect(Collectors.toMap(String::length, name -> name));
System.out.println(nameMap);  // Output: {4=john, 4=jane, 3=bob}
            </code></pre>
          </div>
          <p>&nbsp;</p>
          <div class="question-set">
            <h3>Set 5</h3>
            <div class="question">
              <p><strong>41. How does the `reduce()` method work in Java Streams?</strong></p>
              <p class="answer">The `reduce()` method is a terminal operation that combines the elements of the stream using an associative accumulation function. It produces a single result based on the stream elements.</p>
              <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = numbers.stream().reduce(0, Integer::sum);
System.out.println(sum);  // Output: 15
            </code></pre>
            </div>
            <div class="question">
              <p><strong>42. What is the purpose of the `Optional` class in Java Streams?</strong></p>
              <p class="answer">The `Optional` class is a container object which may or may not contain a value. It is used to avoid `NullPointerException` and to provide a way to handle missing values more gracefully. Many stream operations return `Optional` objects.</p>
            </div>
            <div class="question">
              <p><strong>43. What is the `sorted()` method used for in Java Streams?</strong></p>
              <p class="answer">The `sorted()` method is an intermediate operation in Java Streams that returns a stream with the elements sorted according to their natural order or according to a provided comparator.</p>
              <pre><code>
List<Integer> numbers = Arrays.asList(5, 3, 8, 1);
List<Integer> sortedNumbers = numbers.stream().sorted().collect(Collectors.toList());
System.out.println(sortedNumbers);  // Output: [1, 3, 5, 8]
            </code></pre>
            </div>
            <div class="question">
              <p><strong>44. How do you handle multiple conditions using `filter()` in Java Streams?</strong></p>
              <p class="answer">You can combine multiple conditions in the `filter()` method using logical operators (`&&`, `||`, etc.) within a lambda expression.</p>
              <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
List<Integer> filteredNumbers = numbers.stream()
                                       .filter(n -> n % 2 == 0 && n > 2)
                                       .collect(Collectors.toList());
System.out.println(filteredNumbers);  // Output: [4, 6]
            </code></pre>
            </div>
            <div class="question">
              <p><strong>45. How do you use the `distinct()` method in Java Streams?</strong></p>
              <p class="answer">The `distinct()` method is an intermediate operation that eliminates duplicate elements from the stream.</p>
              <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 2, 3, 4, 4);
List<Integer> distinctNumbers = numbers.stream().distinct().collect(Collectors.toList());
System.out.println(distinctNumbers);  // Output: [1, 2, 3, 4]
            </code></pre>
            </div>
            <div class="question">
              <p><strong>46. What is the `anyMatch()` method used for in Java Streams?</strong></p>
              <p class="answer">The `anyMatch()` method is a short-circuiting terminal operation that checks if any element in the stream matches a given predicate. It returns `true` if at least one element matches, otherwise `false`.</p>
              <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
boolean hasEven = numbers.stream().anyMatch(n -> n % 2 == 0);
System.out.println(hasEven);  // Output: true
            </code></pre>
            </div>
            <div class="question">
              <p><strong>47. How can you check if a stream is empty in Java?</strong></p>
              <p class="answer">You can check if a stream is empty using the `findAny()` method combined with `isPresent()` to see if any element is present in the stream. If no element is found, the stream is empty.</p>
              <pre><code>
List<Integer> numbers = Arrays.asList();
boolean isEmpty = numbers.stream().findAny().isEmpty();
System.out.println(isEmpty);  // Output: true
            </code></pre>
            </div>
            <div class="question">
              <p><strong>48. What is the difference between `count()` and `anyMatch()` in Java Streams?</strong></p>
              <p class="answer">The `count()` method returns the number of elements in the stream that match a given condition, while `anyMatch()` returns a boolean value indicating whether at least one element matches the condition.</p>
            </div>
            <div class="question">
              <p><strong>49. How do you chain multiple operations in Java Streams?</strong></p>
              <p class="answer">You can chain multiple operations in Java Streams by calling stream methods consecutively. The stream is processed step by step in the order of method calls, and intermediate operations are lazily evaluated.</p>
              <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> result = numbers.stream()
                              .filter(n -> n % 2 == 0)
                              .map(n -> n * 2)
                              .collect(Collectors.toList());
System.out.println(result);  // Output: [4, 8]
            </code></pre>
            </div>
            <div class="question">
              <p><strong>50. What is the purpose of the `skip()` method in Java Streams?</strong></p>
              <p class="answer">The `skip()` method is an intermediate operation that skips the first `n` elements of the stream and returns a new stream with the remaining elements.</p>
              <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> skippedNumbers = numbers.stream().skip(2).collect(Collectors.toList());
System.out.println(skippedNumbers);  // Output: [3, 4, 5]
            </code></pre>
            </div>
          </div>
          <p>&nbsp;</p>
          <h3>Set 6</h3>
          <div class="question">
            <p><strong>51. What is the `peek()` method in Java Streams used for?</strong></p>
            <p class="answer">The `peek()` method is an intermediate operation that allows you to inspect the elements of the stream as they are processed. It is often used for debugging purposes and does not alter the stream.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.stream().peek(n -> System.out.println(n)).collect(Collectors.toList());
            </code></pre>
          </div>
          <div class="question">
            <p><strong>52. What is the `flatMap()` method in Java Streams?</strong></p>
            <p class="answer">The `flatMap()` method is an intermediate operation that allows you to transform each element into a stream and then flatten the resulting streams into a single stream.</p>
            <pre><code>
List<List<Integer>> numbers = Arrays.asList(Arrays.asList(1, 2), Arrays.asList(3, 4));
List<Integer> flattened = numbers.stream().flatMap(List::stream).collect(Collectors.toList());
System.out.println(flattened);  // Output: [1, 2, 3, 4]
            </code></pre>
          </div>
          <div class="question">
            <p><strong>53. How do you handle multiple streams concurrently in Java?</strong></p>
            <p class="answer">In Java, you can use the `parallel()` method to enable parallel processing of streams, which can improve performance for large datasets.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> squaredNumbers = numbers.parallelStream().map(n -> n * n).collect(Collectors.toList());
System.out.println(squaredNumbers);
            </code></pre>
          </div>
          <div class="question">
            <p><strong>54. What is the difference between `map()` and `flatMap()` in Java Streams?</strong></p>
            <p class="answer">The `map()` method transforms each element of the stream into a new element, while `flatMap()` transforms each element into a stream and then flattens the resulting streams into a single stream.</p>
          </div>
          <div class="question">
            <p><strong>55. What is the `collect()` method in Java Streams?</strong></p>
            <p class="answer">The `collect()` method is a terminal operation that transforms the elements of a stream into a different form, such as a collection (e.g., List, Set, Map). It is typically used with `Collectors` utility methods.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> result = numbers.stream().collect(Collectors.toList());
System.out.println(result);  // Output: [1, 2, 3, 4, 5]
            </code></pre>
          </div>
          <div class="question">
            <p><strong>56. How do you use the `groupingBy()` collector in Java Streams?</strong></p>
            <p class="answer">The `groupingBy()` collector is a convenient way to group elements of a stream based on a classifier function. It returns a Map where the key is the result of applying the classifier function to each element.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7);
Map<Integer>> grouped = numbers.stream()
                                             .collect(Collectors.groupingBy(n -> n % 2));
System.out.println(grouped);  // Output: {0=[2, 4, 6], 1=[1, 3, 5, 7]}
            </code></pre>
          </div>
          <div class="question">
            <p><strong>57. What is the `toMap()` collector used for in Java Streams?</strong></p>
            <p class="answer">The `toMap()` collector is used to accumulate elements of the stream into a Map. It requires two functions: one to extract the key and one to extract the value for each element.</p>
            <pre><code>
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
Map map = names.stream()
                                .collect(Collectors.toMap(String::length, Function.identity()));
System.out.println(map);  // Output: {5=Alice, 3=Bob, 7=Charlie}
            </code></pre>
          </div>
          <div class="question">
            <p><strong>58. How do you handle null values in Java Streams?</strong></p>
            <p class="answer">You can handle null values in Java Streams by using `filter()` to exclude them, or by using `Optional` to wrap potentially null values and avoid `NullPointerException`.</p>
            <pre><code>
List<String> names = Arrays.asList("Alice", null, "Bob", "Charlie");
List<String> nonNullNames = names.stream().filter(Objects::nonNull).collect(Collectors.toList());
System.out.println(nonNullNames);  // Output: [Alice, Bob, Charlie]
            </code></pre>
          </div>
          <div class="question">
            <p><strong>59. What does the `findFirst()` method do in Java Streams?</strong></p>
            <p class="answer">The `findFirst()` method is a terminal operation that returns the first element in the stream that matches the specified condition, if any. It returns an `Optional`.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
Optional<Integer> firstEven = numbers.stream().filter(n -> n % 2 == 0).findFirst();
firstEven.ifPresent(System.out::println);  // Output: 2
            </code></pre>
          </div>
          <div class="question">
            <p><strong>60. How do you perform an operation on each element in a stream without modifying the stream?</strong></p>
            <p class="answer">You can use the `forEach()` method to perform an action on each element in the stream. This is a terminal operation that doesn't alter the stream itself.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.stream().forEach(n -> System.out.println(n));
            </code></pre>
          </div>
          <h3>Set 7</h3>
          <div class="question">
            <p><strong>61. What is the `reduce()` method in Java Streams?</strong></p>
            <p class="answer">The `reduce()` method is a terminal operation that performs a reduction on the elements of the stream using an associative accumulation function. It produces a single result.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = numbers.stream().reduce(0, (a, b) -> a + b);
System.out.println(sum);  // Output: 15
            </code></pre>
          </div>
          <div class="question">
            <p><strong>62. What is a `Supplier` in Java Functional Interfaces?</strong></p>
            <p class="answer">A `Supplier` is a functional interface that represents a supplier of results. It does not take any arguments but returns a result.</p>
            <pre><code>
Supplier<Integer> randomSupplier = () -> (int)(Math.random() * 100);
System.out.println(randomSupplier.get());  // Output: Random number
            </code></pre>
          </div>
          <div class="question">
            <p><strong>63. What is a `Consumer` in Java Functional Interfaces?</strong></p>
            <p class="answer">A `Consumer` is a functional interface that represents an operation that takes a single input argument and returns no result. It is used to perform an action on an input.</p>
            <pre><code>
Consumer<String> printConsumer = str -> System.out.println(str);
printConsumer.accept("Hello, World!");  // Output: Hello, World!
            </code></pre>
          </div>
          <div class="question">
            <p><strong>64. How does the `mapToInt()` method work in Java Streams?</strong></p>
            <p class="answer">The `mapToInt()` method is an intermediate operation that converts a stream of objects to an `IntStream`. It applies a function to each element and returns an integer value.</p>
            <pre><code>
List<String> numbers = Arrays.asList("1", "2", "3", "4");
int sum = numbers.stream().mapToInt(Integer::parseInt).sum();
System.out.println(sum);  // Output: 10
            </code></pre>
          </div>
          <div class="question">
            <p><strong>65. What is the `anyMatch()` method in Java Streams?</strong></p>
            <p class="answer">The `anyMatch()` method is a terminal operation that checks whether any elements in the stream satisfy the given predicate. It returns `true` if any element matches the condition, otherwise `false`.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
boolean hasEven = numbers.stream().anyMatch(n -> n % 2 == 0);
System.out.println(hasEven);  // Output: true
            </code></pre>
          </div>
          <div class="question">
            <p><strong>66. What is the `allMatch()` method in Java Streams?</strong></p>
            <p class="answer">The `allMatch()` method is a terminal operation that checks whether all elements in the stream satisfy the given predicate. It returns `true` if all elements match the condition, otherwise `false`.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(2, 4, 6, 8);
boolean allEven = numbers.stream().allMatch(n -> n % 2 == 0);
System.out.println(allEven);  // Output: true
            </code></pre>
          </div>
          <div class="question">
            <p><strong>67. How does the `noneMatch()` method work in Java Streams?</strong></p>
            <p class="answer">The `noneMatch()` method is a terminal operation that checks whether no elements in the stream satisfy the given predicate. It returns `true` if no elements match the condition, otherwise `false`.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
boolean noEven = numbers.stream().noneMatch(n -> n % 2 != 0);
System.out.println(noEven);  // Output: false
            </code></pre>
          </div>
          <div class="question">
            <p><strong>68. What is the `forEachOrdered()` method in Java Streams?</strong></p>
            <p class="answer">The `forEachOrdered()` method is a terminal operation that performs an action for each element in the stream in the encounter order. It is used when you want to preserve the order of elements while processing them in parallel streams.</p>
            <pre><code>
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
names.parallelStream().forEachOrdered(System.out::println);
            </code></pre>
          </div>
          <div class="question">
            <p><strong>69. What is the `skip()` method used for in Java Streams?</strong></p>
            <p class="answer">The `skip()` method is an intermediate operation that skips the first `n` elements of the stream and returns a new stream with the remaining elements.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> skipped = numbers.stream().skip(2).collect(Collectors.toList());
System.out.println(skipped);  // Output: [3, 4, 5]
            </code></pre>
          </div>
          <div class="question">
            <p><strong>70. How do you use the `limit()` method in Java Streams?</strong></p>
            <p class="answer">The `limit()` method is an intermediate operation that returns a new stream containing the first `n` elements from the original stream. It is useful for restricting the number of elements in a stream.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> limited = numbers.stream().limit(3).collect(Collectors.toList());
System.out.println(limited);  // Output: [1, 2, 3]
            </code></pre>
          </div>
          <p>&nbsp;</p>
          <h3>Set 8</h3>
          <div class="question">
            <p><strong>71. What is the `flatMap()` method in Java Streams?</strong></p>
            <p class="answer">The `flatMap()` method is an intermediate operation that transforms each element of the stream into a new stream and then flattens the result into a single stream.</p>
            <pre><code>
List<List<String>> listOfLists = Arrays.asList(
    Arrays.asList("a", "b", "c"),
    Arrays.asList("d", "e")
);
List<String> flattened = listOfLists.stream().flatMap(List::stream).collect(Collectors.toList());
System.out.println(flattened);  // Output: [a, b, c, d, e]
            </code></pre>
          </div>
          <div class="question">
            <p><strong>72. What is a `Predicate` in Java Functional Interfaces?</strong></p>
            <p class="answer">A `Predicate` is a functional interface that represents a boolean-valued function of one argument. It is typically used to test whether a condition is true or false for an object.</p>
            <pre><code>
Predicate<Integer> isEven = n -> n % 2 == 0;
System.out.println(isEven.test(4));  // Output: true
            </code></pre>
          </div>
          <div class="question">
            <p><strong>73. How does the `distinct()` method work in Java Streams?</strong></p>
            <p class="answer">The `distinct()` method is an intermediate operation that removes duplicate elements from a stream based on the `equals()` method.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 2, 3, 4, 4, 5);
List<Integer> distinctNumbers = numbers.stream().distinct().collect(Collectors.toList());
System.out.println(distinctNumbers);  // Output: [1, 2, 3, 4, 5]
            </code></pre>
          </div>
          <div class="question">
            <p><strong>74. What is the `toArray()` method used for in Java Streams?</strong></p>
            <p class="answer">The `toArray()` method is a terminal operation that converts a stream into an array. You can pass a function that returns an array of the correct type.</p>
            <pre><code>
List<String> words = Arrays.asList("apple", "banana", "cherry");
String[] array = words.stream().toArray(String[]::new);
System.out.println(Arrays.toString(array));  // Output: [apple, banana, cherry]
            </code></pre>
          </div>
          <div class="question">
            <p><strong>75. What is a `Function` in Java Functional Interfaces?</strong></p>
            <p class="answer">A `Function` is a functional interface that represents a function that takes one argument and produces a result. It is typically used for mapping one type to another.</p>
            <pre><code>
Function stringLength = str -> str.length();
System.out.println(stringLength.apply("Hello"));  // Output: 5
            </code></pre>
          </div>
          <div class="question">
            <p><strong>76. How does the `sorted()` method work in Java Streams?</strong></p>
            <p class="answer">The `sorted()` method is an intermediate operation that sorts the elements of a stream in natural order or using a comparator.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(5, 1, 3, 4, 2);
List<Integer> sortedNumbers = numbers.stream().sorted().collect(Collectors.toList());
System.out.println(sortedNumbers);  // Output: [1, 2, 3, 4, 5]
            </code></pre>
          </div>
          <div class="question">
            <p><strong>77. What is the `peek()` method used for in Java Streams?</strong></p>
            <p class="answer">The `peek()` method is an intermediate operation that allows you to perform a side-effect operation on each element of the stream without consuming it. It is often used for debugging.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.stream().peek(n -> System.out.println("Processing: " + n)).forEach(System.out::println);
            </code></pre>
          </div>
          <div class="question">
            <p><strong>78. What is the difference between `map()` and `flatMap()` in Java Streams?</strong></p>
            <p class="answer">The `map()` method transforms each element of the stream into a new value, while `flatMap()` transforms each element into a stream and then flattens the resulting streams into a single stream.</p>
          </div>
          <div class="question">
            <p><strong>79. How do you use the `forEach()` method in Java Streams?</strong></p>
            <p class="answer">The `forEach()` method is a terminal operation that iterates over each element of the stream and performs a specified action.</p>
            <pre><code>
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
names.stream().forEach(System.out::println);
            </code></pre>
          </div>
          <div class="question">
            <p><strong>80. What is a `UnaryOperator` in Java Functional Interfaces?</strong></p>
            <p class="answer">A `UnaryOperator` is a functional interface that represents an operation on a single operand that produces a result of the same type as the operand.</p>
            <pre><code>
UnaryOperator<Integer> square = x -> x * x;
System.out.println(square.apply(5));  // Output: 25
            </code></pre>
          </div>
          <p>&nbsp;</p>
          <h3>Set 9</h3>
          <div class="question">
            <p><strong>81. What is the `collect()` method in Java Streams?</strong></p>
            <p class="answer">The `collect()` method is a terminal operation that transforms the elements of a stream into a different form, usually a collection like a List, Set, or Map.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4);
List<Integer> doubled = numbers.stream().map(n -> n * 2).collect(Collectors.toList());
System.out.println(doubled);  // Output: [2, 4, 6, 8]
            </code></pre>
          </div>
          <div class="question">
            <p><strong>82. What is the difference between `findFirst()` and `findAny()` in Java Streams?</strong></p>
            <p class="answer">The `findFirst()` method returns the first element in the stream, while `findAny()` can return any element from the stream. `findAny()` is typically used in parallel streams.</p>
          </div>
          <div class="question">
            <p><strong>83. What is `Optional` in Java and how is it used in functional programming?</strong></p>
            <p class="answer">`Optional` is a container object that may or may not contain a non-null value. It is used to represent a value that may be absent, allowing safe handling of null values.</p>
            <pre><code>
Optional<String> name = Optional.ofNullable("John");
System.out.println(name.orElse("Default"));  // Output: John
            </code></pre>
          </div>
          <div class="question">
            <p><strong>84. What is the `anyMatch()` method in Java Streams?</strong></p>
            <p class="answer">The `anyMatch()` method is a terminal operation that checks whether at least one element of the stream matches the given predicate.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4);
boolean hasEven = numbers.stream().anyMatch(n -> n % 2 == 0);
System.out.println(hasEven);  // Output: true
            </code></pre>
          </div>
          <div class="question">
            <p><strong>85. How do you use the `reduce()` method in Java Streams?</strong></p>
            <p class="answer">The `reduce()` method is a terminal operation that performs a reduction on the elements of the stream using an associative accumulation function and returns an `Optional` containing the result.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4);
int sum = numbers.stream().reduce(0, (a, b) -> a + b);
System.out.println(sum);  // Output: 10
            </code></pre>
          </div>
          <div class="question">
            <p><strong>86. What is the `IntStream` in Java Streams?</strong></p>
            <p class="answer">`IntStream` is a specialized stream for working with primitive `int` values. It provides methods that are optimized for working with primitive values, reducing the overhead of autoboxing.</p>
            <pre><code>
IntStream.range(1, 5).forEach(System.out::println);  // Output: 1, 2, 3, 4
            </code></pre>
          </div>
          <div class="question">
            <p><strong>87. How does the `skip()` method work in Java Streams?</strong></p>
            <p class="answer">The `skip()` method is an intermediate operation that skips the first `n` elements of the stream and returns a stream with the remaining elements.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> skipped = numbers.stream().skip(2).collect(Collectors.toList());
System.out.println(skipped);  // Output: [3, 4, 5]
            </code></pre>
          </div>
          <div class="question">
            <p><strong>88. What is the `limit()` method in Java Streams?</strong></p>
            <p class="answer">The `limit()` method is an intermediate operation that returns a stream with at most the specified number of elements, truncating the stream if it is larger.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> limited = numbers.stream().limit(3).collect(Collectors.toList());
System.out.println(limited);  // Output: [1, 2, 3]
            </code></pre>
          </div>
          <div class="question">
            <p><strong>89. How do you use the `mapToInt()` method in Java Streams?</strong></p>
            <p class="answer">The `mapToInt()` method is used to convert a stream of objects to a stream of primitive `int` values. It is commonly used when you need to perform numeric operations on the stream elements.</p>
            <pre><code>
List<String> numbers = Arrays.asList("1", "2", "3", "4");
int sum = numbers.stream().mapToInt(Integer::parseInt).sum();
System.out.println(sum);  // Output: 10
            </code></pre>
          </div>
          <div class="question">
            <p><strong>90. What is a `BiFunction` in Java Functional Interfaces?</strong></p>
            <p class="answer">A `BiFunction` is a functional interface that takes two arguments of different types and produces a result. It is commonly used for functions that take two inputs and return a result.</p>
            <pre><code>
BiFunction add = (a, b) -> a + b;
System.out.println(add.apply(2, 3));  // Output: 5
            </code></pre>
          </div>
          <p>&nbsp;</p>
          <h3>Set 10</h3>
          <div class="question">
            <p><strong>91. What is the difference between `map()` and `flatMap()` in Java Streams?</strong></p>
            <p class="answer">The `map()` method transforms each element of the stream into a new form, while `flatMap()` flattens the result into a single stream when the mapping produces multiple elements per input.</p>
            <pre><code>
List<String> words = Arrays.asList("Hello", "World");
List<String> characters = words.stream()
                               .flatMap(word -> Arrays.stream(word.split("")))
                               .collect(Collectors.toList());
System.out.println(characters);  // Output: [H, e, l, l, o, W, o, r, l, d]
            </code></pre>
          </div>
          <div class="question">
            <p><strong>92. What is the `UnaryOperator` functional interface in Java?</strong></p>
            <p class="answer">A `UnaryOperator` is a functional interface that takes one argument and returns a result of the same type. It is used for functions that perform operations on a single input and return the same type.</p>
            <pre><code>
UnaryOperator<Integer> square = x -> x * x;
System.out.println(square.apply(5));  // Output: 25
            </code></pre>
          </div>
          <div class="question">
            <p><strong>93. How do you use `Stream.of()` in Java?</strong></p>
            <p class="answer">`Stream.of()` is a static method that creates a stream from a specified set of elements.</p>
            <pre><code>
Stream<String> stream = Stream.of("Java", "Python", "C++");
stream.forEach(System.out::println);  // Output: Java, Python, C++
            </code></pre>
          </div>
          <div class="question">
            <p><strong>94. What is the `Function` interface in Java?</strong></p>
            <p class="answer">`Function` is a functional interface that takes one argument and returns a result. It is commonly used for mapping functions or operations that transform data.</p>
            <pre><code>
Function numberToString = n -> "Number: " + n;
System.out.println(numberToString.apply(5));  // Output: Number: 5
            </code></pre>
          </div>
          <div class="question">
            <p><strong>95. How does the `forEach()` method work in Java Streams?</strong></p>
            <p class="answer">The `forEach()` method is a terminal operation that performs an action for each element in the stream. It is often used to iterate over elements in a stream.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3);
numbers.stream().forEach(System.out::println);  // Output: 1, 2, 3
            </code></pre>
          </div>
          <div class="question">
            <p><strong>96. What is the `Comparator` interface in Java?</strong></p>
            <p class="answer">`Comparator` is a functional interface used for comparing two objects. It is often used for sorting elements in a stream or a collection.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(5, 3, 8, 1);
numbers.stream().sorted(Comparator.naturalOrder()).forEach(System.out::println);  // Output: 1, 3, 5, 8
            </code></pre>
          </div>
          <div class="question">
            <p><strong>97. What is `reduce()` used for in Java Streams?</strong></p>
            <p class="answer">`reduce()` is a terminal operation used to combine all elements in a stream into a single result. It uses an associative accumulation function.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4);
int sum = numbers.stream().reduce(0, (a, b) -> a + b);
System.out.println(sum);  // Output: 10
            </code></pre>
          </div>
          <div class="question">
            <p><strong>98. What is the `IntStream` in Java?</strong></p>
            <p class="answer">`IntStream` is a specialized stream for working with primitive `int` values. It provides methods that reduce overhead and improve performance when working with primitive data types.</p>
            <pre><code>
IntStream.range(1, 5).forEach(System.out::println);  // Output: 1, 2, 3, 4
            </code></pre>
          </div>
          <div class="question">
            <p><strong>99. How can you create a Stream from an array in Java?</strong></p>
            <p class="answer">You can use `Arrays.stream()` to create a stream from an array.</p>
            <pre><code>
int[] arr = {1, 2, 3, 4};
IntStream stream = Arrays.stream(arr);
stream.forEach(System.out::println);  // Output: 1, 2, 3, 4
            </code></pre>
          </div>
          <div class="question">
            <p><strong>100. How do you use `Stream.generate()` in Java?</strong></p>
            <p class="answer">`Stream.generate()` is a method that generates an infinite stream based on a provided `Supplier`. You can limit the size of the stream using `limit()` to prevent it from running indefinitely.</p>
            <pre><code>
Stream<Integer> randomNumbers = Stream.generate(() -> (int) (Math.random() * 100));
randomNumbers.limit(5).forEach(System.out::println);  // Output: random numbers between 0 and 100
            </code></pre>
          </div>
          <p>&nbsp;</p>
          <h3>Set 11</h3>
          <div class="question">
            <p><strong>101. What is the `Supplier` functional interface in Java?</strong></p>
            <p class="answer">The `Supplier` functional interface represents a supplier of results. It has a method `get()` that doesn't take any input parameters and returns a value.</p>
            <pre><code>
Supplier<String> stringSupplier = () -> "Hello, World!";
System.out.println(stringSupplier.get());  // Output: Hello, World!
            </code></pre>
          </div>
          <div class="question">
            <p><strong>102. How does `Stream.filter()` work in Java?</strong></p>
            <p class="answer">`Stream.filter()` is a method that returns a new stream containing only elements that match the specified predicate. It is often used to filter out unwanted elements.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.stream().filter(n -> n % 2 == 0).forEach(System.out::println);  // Output: 2, 4
            </code></pre>
          </div>
          <div class="question">
            <p><strong>103. What is the `Optional` class in Java?</strong></p>
            <p class="answer">`Optional` is a container object which may or may not contain a value. It is used to represent the possibility of a null value and helps avoid `NullPointerException`.</p>
            <pre><code>
Optional<String> optional = Optional.of("Hello");
optional.ifPresent(System.out::println);  // Output: Hello
            </code></pre>
          </div>
          <div class="question">
            <p><strong>104. How can you create an immutable collection in Java?</strong></p>
            <p class="answer">Java provides the `Collections.unmodifiableList()`, `unmodifiableSet()`, and `unmodifiableMap()` methods to create immutable collections. In addition, you can use `List.of()` and `Set.of()` in Java 9 and later.</p>
            <pre><code>
List<String> immutableList = List.of("A", "B", "C");
System.out.println(immutableList);  // Output: [A, B, C]
            </code></pre>
          </div>
          <div class="question">
            <p><strong>105. What is the use of `Stream.peek()` in Java?</strong></p>
            <p class="answer">`Stream.peek()` is an intermediate operation that allows you to perform a side effect on each element of the stream as it is processed. It is primarily used for debugging purposes.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4);
numbers.stream()
       .peek(n -> System.out.println("Processing: " + n))
       .collect(Collectors.toList());
            </code></pre>
          </div>
          <div class="question">
            <p><strong>106. How does `Stream.concat()` work in Java?</strong></p>
            <p class="answer">`Stream.concat()` is a method that merges two streams into a single stream. It takes two streams as parameters and returns a new stream that contains the elements of both.</p>
            <pre><code>
Stream<String> stream1 = Stream.of("A", "B");
Stream<String> stream2 = Stream.of("C", "D");
Stream<String> combined = Stream.concat(stream1, stream2);
combined.forEach(System.out::println);  // Output: A, B, C, D
            </code></pre>
          </div>
          <div class="question">
            <p><strong>107. How do you use `Stream.collect()` in Java?</strong></p>
            <p class="answer">`Stream.collect()` is a terminal operation that transforms the elements of the stream into a different form, typically a collection, such as a list, set, or map.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4);
List<Integer> evenNumbers = numbers.stream()
                                   .filter(n -> n % 2 == 0)
                                   .collect(Collectors.toList());
System.out.println(evenNumbers);  // Output: [2, 4]
            </code></pre>
          </div>
          <div class="question">
            <p><strong>108. What is `Stream.allMatch()` in Java?</strong></p>
            <p class="answer">`Stream.allMatch()` is a terminal operation that checks if all elements in the stream satisfy the given predicate.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(2, 4, 6, 8);
boolean allEven = numbers.stream().allMatch(n -> n % 2 == 0);
System.out.println(allEven);  // Output: true
            </code></pre>
          </div>
          <div class="question">
            <p><strong>109. What is the difference between `limit()` and `skip()` in Java Streams?</strong></p>
            <p class="answer">`limit()` is an operation that truncates the stream to a specified size, while `skip()` is used to skip a specified number of elements from the beginning of the stream.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.stream().limit(3).forEach(System.out::println);  // Output: 1, 2, 3
numbers.stream().skip(2).forEach(System.out::println);   // Output: 3, 4, 5
            </code></pre>
          </div>
          <div class="question">
            <p><strong>110. How does `Stream.forEachOrdered()` work in Java?</strong></p>
            <p class="answer">`Stream.forEachOrdered()` is similar to `forEach()`, but it guarantees the elements are processed in the encounter order if the stream has an encounter order.</p>
            <pre><code>
Stream.of(1, 2, 3, 4)
      .parallel()
      .forEachOrdered(System.out::println);  // Output: 1, 2, 3, 4 (order preserved)
            </code></pre>
          </div>
          <p>&nbsp;</p>
          <h3>Set 12</h3>
          <div class="question">
            <p><strong>111. What is the `Consumer` functional interface in Java?</strong></p>
            <p class="answer">`Consumer` is a functional interface that represents an operation that accepts a single input argument and returns no result. It has the method `accept()`.</p>
            <pre><code>
Consumer<String> printConsumer = s -> System.out.println(s);
printConsumer.accept("Hello");  // Output: Hello
            </code></pre>
          </div>
          <div class="question">
            <p><strong>112. How do you use `Stream.reduce()` in Java?</strong></p>
            <p class="answer">`Stream.reduce()` is a terminal operation that performs a reduction on the elements of the stream using an associative accumulation function and returns an `Optional` result.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4);
int sum = numbers.stream().reduce(0, Integer::sum);
System.out.println(sum);  // Output: 10
            </code></pre>
          </div>
          <div class="question">
            <p><strong>113. What is `Stream.flatMap()` used for in Java?</strong></p>
            <p class="answer">`Stream.flatMap()` is an intermediate operation that replaces each element of the stream with a stream of new values, then flattens the resulting streams into a single stream.</p>
            <pre><code>
List<List<Integer>> listOfLists = Arrays.asList(
    Arrays.asList(1, 2), 
    Arrays.asList(3, 4)
);
List<Integer> flatList = listOfLists.stream()
                                   .flatMap(List::stream)
                                   .collect(Collectors.toList());
System.out.println(flatList);  // Output: [1, 2, 3, 4]
            </code></pre>
          </div>
          <div class="question">
            <p><strong>114. What is the difference between `map()` and `flatMap()` in Java Streams?</strong></p>
            <p class="answer">`map()` transforms each element into one element, while `flatMap()` can transform each element into zero, one, or more elements and flattens the result into a single stream.</p>
            <pre><code>
Stream<String> words = Stream.of("hello", "world");
Stream<String> uppercased = words.map(String::toUpperCase);  // [HELLO, WORLD]
Stream<String> flatMapExample = Stream.of(Arrays.asList("a", "b"), Arrays.asList("c", "d"))
                                      .flatMap(List::stream);  // [a, b, c, d]
            </code></pre>
          </div>
          <div class="question">
            <p><strong>115. How does `Stream.distinct()` work in Java?</strong></p>
            <p class="answer">`Stream.distinct()` is an intermediate operation that returns a stream with distinct elements (removes duplicates) according to the `equals()` method.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 2, 3, 3, 4);
numbers.stream().distinct().forEach(System.out::println);  // Output: 1, 2, 3, 4
            </code></pre>
          </div>
          <div class="question">
            <p><strong>116. What is `Stream.anyMatch()` in Java?</strong></p>
            <p class="answer">`Stream.anyMatch()` is a terminal operation that checks whether any element in the stream matches the provided predicate. It returns `true` if at least one element satisfies the condition.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4);
boolean hasEven = numbers.stream().anyMatch(n -> n % 2 == 0);
System.out.println(hasEven);  // Output: true
            </code></pre>
          </div>
          <div class="question">
            <p><strong>117. How does `Stream.noneMatch()` work in Java?</strong></p>
            <p class="answer">`Stream.noneMatch()` is a terminal operation that checks if no elements in the stream match the given predicate. It returns `true` if none of the elements satisfy the condition.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(1, 3, 5);
boolean noEven = numbers.stream().noneMatch(n -> n % 2 == 0);
System.out.println(noEven);  // Output: true
            </code></pre>
          </div>
          <div class="question">
            <p><strong>118. What is the purpose of `Stream.sorted()` in Java?</strong></p>
            <p class="answer">`Stream.sorted()` is an intermediate operation that returns a stream with elements sorted according to the natural order or using a custom comparator.</p>
            <pre><code>
List<Integer> numbers = Arrays.asList(5, 3, 2, 4, 1);
numbers.stream().sorted().forEach(System.out::println);  // Output: 1, 2, 3, 4, 5
            </code></pre>
          </div>
          <div class="question">
            <p><strong>119. What is the `Function` functional interface in Java?</strong></p>
            <p class="answer">`Function` is a functional interface that represents a function that accepts one argument and produces a result. It has the method `apply()`.</p>
            <pre><code>
Function lengthFunction = String::length;
System.out.println(lengthFunction.apply("Hello"));  // Output: 5
            </code></pre>
          </div>
          <div class="question">
            <p><strong>120. How do you use `Stream.toList()` in Java?</strong></p>
            <p class="answer">`Stream.toList()` is a terminal operation that collects the elements of a stream into a new list. This method was introduced in Java 16.</p>
            <pre><code>
List<Integer> numbers = Stream.of(1, 2, 3, 4).toList();
System.out.println(numbers);  // Output: [1, 2, 3, 4]
            </code></pre>
          </div>
          <p>&nbsp;</p>
          <p>&nbsp;</p>
          <p>&nbsp;</p>
          <p>&nbsp;</p>
          <p>&nbsp;</p>
          <p>&nbsp;</p>
          <p>&nbsp;</p>
          <p>&nbsp;</p>
          <p>&nbsp;	</p>
          <p>&nbsp;</p>
          <p>&nbsp;</p>
          <p>&nbsp;</p>
          <p>&nbsp;</p>
          <p class="answer">&nbsp;</p>
      </div>

    </div>

</body>
</html>
