<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Untitled Document</title>
<style type="text/css">
<!--
.answer {            margin-bottom: 20px;
}
.question {            margin-bottom: 10px;
}
.style1 {font-family: Arial, Helvetica, sans-serif}
.style2 {margin-bottom: 10px; font-family: Arial, Helvetica, sans-serif; }
.style3 {font-family: Arial, Helvetica, sans-serif; font-weight: bold; }
-->
</style>
</head>

<body>
<h1 class="style1">Set 1 - Transactions &amp; Isolation Levels - JPA</h1>
<p class="style3"><a href="Java 46 Transactions Isolation Levels 01.mp3" target="_blank">Audio 1</a> - <a href="Java 46 Transactions Isolation Levels 02.mp3" target="_blank">Audio 2</a></p>
<div class="style2"> <b>Q1: How do you configure a transaction in JPA?</b>
    <div class="answer">
      <p>In JPA, you typically configure transactions using the <code>@Transactional</code> annotation provided by Spring. This annotation ensures that the methods in which it's applied are executed within a transactional context.</p>
      <pre><code>@Transactional
public void saveEntity(Entity entity) {
    entityManager.persist(entity);
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q2: How do isolation levels affect transactions in JPA?</b>
    <div class="answer">
      <p>Isolation levels in JPA can be controlled using the <code>@Transactional</code> annotation with the <code>isolation</code> attribute. Different isolation levels help manage how data is shared between transactions, ensuring the consistency of the data.</p>
      <pre><code>@Transactional(isolation = Isolation.READ_COMMITTED)
public void processTransaction() {
    // Transaction logic
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q3: What is the default isolation level in JPA?</b>
    <div class="answer">
      <p>The default isolation level in JPA (through Hibernate) is typically <code>READ_COMMITTED</code>, which ensures that no dirty reads occur but still allows non-repeatable reads and phantom reads.</p>
    </div>
</div>
<div class="style2"> <b>Q4: Can you configure a custom isolation level for a JPA method?</b>
    <div class="answer">
      <p>Yes, you can specify a custom isolation level for a JPA method by using the <code>@Transactional</code> annotation and setting the <code>isolation</code> attribute.</p>
      <pre><code>@Transactional(isolation = Isolation.SERIALIZABLE)
public void updateEntity(Entity entity) {
    // Update logic
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q5: What is the difference between <code>READ_COMMITTED</code> and <code>SERIALIZABLE</code> isolation levels in JPA?</b>
    <div class="answer">
      <p><code>READ_COMMITTED</code> allows reading committed data, preventing dirty reads but still allowing non-repeatable reads and phantom reads. On the other hand, <code>SERIALIZABLE</code> prevents dirty reads, non-repeatable reads, and phantom reads, ensuring complete isolation between transactions.</p>
    </div>
</div>
<div class="style2"> <b>Q6: What is the purpose of the <code>@Transactional</code> annotation in JPA?</b>
    <div class="answer">
      <p>The <code>@Transactional</code> annotation in JPA is used to define the boundaries of a transaction. It manages transaction boundaries (begin, commit, rollback) automatically and ensures that the method executes within a transactional context.</p>
    </div>
</div>
<div class="style2"> <b>Q7: How can you set the propagation behavior in JPA?</b>
    <div class="answer">
      <p>Propagation behavior in JPA can be configured using the <code>@Transactional</code> annotation with the <code>propagation</code> attribute. It defines how transactions are handled when a method is called within an existing transaction.</p>
      <pre><code>@Transactional(propagation = Propagation.REQUIRED)
public void someMethod() {
    // Transaction logic
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q8: How can you ensure that a transaction is rolled back in case of a runtime exception in JPA?</b>
    <div class="answer">
      <p>By default, JPA will automatically roll back a transaction if a <code>RuntimeException</code> or its subclass is thrown. You can also explicitly specify rollback behavior using the <code>@Transactional</code> annotation.</p>
      <pre><code>@Transactional(rollbackFor = Exception.class)
public void someMethod() throws Exception {
    // Logic that may throw a checked exception
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q9: What is the <code>flush()</code> method in JPA?</b>
    <div class="answer">
      <p>The <code>flush()</code> method in JPA synchronizes the in-memory state of the persistence context with the underlying database. It ensures that all changes made to entities are persisted to the database, although the transaction may not yet be committed.</p>
      <pre><code>entityManager.flush();</code></pre>
    </div>
</div>
<div class="style2"> <b>Q10: How can you handle concurrency issues in JPA?</b>
    <div class="answer">
      <p>JPA provides <code>optimistic</code> and <code>pessimistic</code> locking mechanisms to handle concurrency issues. Optimistic locking uses version fields to detect conflicting changes, while pessimistic locking locks the data for exclusive access.</p>
      <pre><code>@Version
private int version;</code></pre>
    </div>
</div>
<p class="style1">&nbsp;</p>
<h1 class="style1">Set 2 - Transactions &amp; Isolation Levels - JPA</h1>
<div class="style2"> <b>Q1: What is optimistic locking in JPA?</b>
    <div class="answer">
      <p>Optimistic locking in JPA is a mechanism to handle concurrent access to an entity by using a version field. It prevents lost updates by checking if the entity has been modified since it was last read. If a conflict is detected, a <code>OptimisticLockException</code> is thrown.</p>
      <pre><code>@Version
private int version;</code></pre>
    </div>
</div>
<div class="style2"> <b>Q2: What is pessimistic locking in JPA?</b>
    <div class="answer">
      <p>Pessimistic locking in JPA is a mechanism to prevent concurrent modifications by explicitly locking the entity. The lock can either be shared or exclusive, ensuring that no other transaction can modify the data during the transaction.</p>
      <pre><code>entityManager.find(Entity.class, id, LockModeType.PESSIMISTIC_WRITE);</code></pre>
    </div>
</div>
<div class="style2"> <b>Q3: What is the <code>LockModeType.PESSIMISTIC_READ</code> in JPA?</b>
    <div class="answer">
      <p><code>LockModeType.PESSIMISTIC_READ</code> is used to acquire a shared lock on an entity. This prevents other transactions from writing to the entity but allows reading.</p>
      <pre><code>entityManager.find(Entity.class, id, LockModeType.PESSIMISTIC_READ);</code></pre>
    </div>
</div>
<div class="style2"> <b>Q4: What is the <code>LockModeType.PESSIMISTIC_WRITE</code> in JPA?</b>
    <div class="answer">
      <p><code>LockModeType.PESSIMISTIC_WRITE</code> is used to acquire an exclusive lock on an entity, preventing other transactions from modifying the entity during the transaction.</p>
      <pre><code>entityManager.find(Entity.class, id, LockModeType.PESSIMISTIC_WRITE);</code></pre>
    </div>
</div>
<div class="style2"> <b>Q5: How do you handle transaction timeouts in JPA?</b>
    <div class="answer">
      <p>In JPA, you can set a timeout for a transaction by using the <code>@Transactional</code> annotation with the <code>timeout</code> attribute. This defines the time (in seconds) after which a transaction will be rolled back if not completed.</p>
      <pre><code>@Transactional(timeout = 30)
public void someMethod() {
    // Transaction logic
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q6: How do you ensure that a method is executed within a new transaction in JPA?</b>
    <div class="answer">
      <p>To ensure a method executes within a new transaction, you can use the <code>@Transactional</code> annotation with <code>propagation = Propagation.REQUIRES_NEW</code>. This starts a new transaction, suspending any existing transaction.</p>
      <pre><code>@Transactional(propagation = Propagation.REQUIRES_NEW)
public void newTransactionMethod() {
    // Logic for a new transaction
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q7: What is the difference between <code>REQUIRED</code> and <code>REQUIRES_NEW</code> propagation types in JPA?</b>
    <div class="answer">
      <p><code>REQUIRED</code> will use the existing transaction if one is already active, while <code>REQUIRES_NEW</code> will always start a new transaction, even if one is already active. The latter will suspend the current transaction temporarily.</p>
    </div>
</div>
<div class="style2"> <b>Q8: How do you roll back a transaction manually in JPA?</b>
    <div class="answer">
      <p>In JPA, you can manually roll back a transaction by calling the <code>rollback()</code> method on the <code>EntityTransaction</code> object. This can be done inside a catch block if an exception occurs.</p>
      <pre><code>EntityTransaction tx = entityManager.getTransaction();
try {
    tx.begin();
    // Transaction logic
    tx.commit();
} catch (Exception e) {
    tx.rollback();
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q9: How does Spring manage transaction boundaries in JPA?</b>
    <div class="answer">
      <p>Spring manages transaction boundaries in JPA using the <code>@Transactional</code> annotation. This ensures that the transaction is automatically started before the method execution and committed after, or rolled back in case of an exception.</p>
    </div>
</div>
<div class="style2"> <b>Q10: What are some common exceptions that trigger a rollback in JPA?</b>
    <div class="answer">
      <p>Some common exceptions that trigger a rollback in JPA include:</p>
      <ul>
        <li><code>RuntimeException</code> or its subclasses</li>
        <li><code>javax.persistence.PersistenceException</code></li>
        <li><code>javax.transaction.RollbackException</code></li>
      </ul>
    </div>
</div>
<h1 class="style1">Set 3 - Transactions &amp; Isolation Levels - JPA</h1>
<div class="style2"> <b>Q1: What is the default isolation level in JPA?</b>
    <div class="answer">
      <p>The default isolation level in JPA is <code>Isolation.DEFAULT</code>, which depends on the underlying database's default isolation level. It usually corresponds to <code>READ_COMMITTED</code> in most databases.</p>
    </div>
</div>
<div class="style2"> <b>Q2: How do you configure isolation levels in JPA?</b>
    <div class="answer">
      <p>You can configure the isolation level in JPA by using the <code>@Transactional</code> annotation's <code>isolation</code> attribute, specifying an isolation level like <code>Isolation.READ_COMMITTED</code>, <code>Isolation.SERIALIZABLE</code>, or <code>Isolation.READ_UNCOMMITTED</code>.</p>
      <pre><code>@Transactional(isolation = Isolation.SERIALIZABLE)
public void someMethod() {
    // Transaction logic
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q3: What is the <code>Isolation.READ_COMMITTED</code> isolation level in JPA?</b>
    <div class="answer">
      <p><code>Isolation.READ_COMMITTED</code> ensures that any data read by a transaction is committed at the moment it is read. It prevents dirty reads but allows non-repeatable reads and phantom reads.</p>
    </div>
</div>
<div class="style2"> <b>Q4: What is the <code>Isolation.READ_UNCOMMITTED</code> isolation level in JPA?</b>
    <div class="answer">
      <p><code>Isolation.READ_UNCOMMITTED</code> allows dirty reads, meaning transactions can read data that has been modified but not yet committed by another transaction. This isolation level is generally not recommended due to the risk of reading inconsistent data.</p>
    </div>
</div>
<div class="style2"> <b>Q5: What is the <code>Isolation.SERIALIZABLE</code> isolation level in JPA?</b>
    <div class="answer">
      <p><code>Isolation.SERIALIZABLE</code> is the strictest isolation level. It ensures that transactions are executed in such a way that the results are as if they were executed sequentially, one after the other. This level prevents dirty reads, non-repeatable reads, and phantom reads, but it can lead to performance issues due to locking.</p>
    </div>
</div>
<div class="style2"> <b>Q6: What is the <code>Isolation.REPEATABLE_READ</code> isolation level in JPA?</b>
    <div class="answer">
      <p><code>Isolation.REPEATABLE_READ</code> ensures that if a transaction reads a value, it will see the same value each time it reads it during the duration of the transaction. It prevents dirty reads and non-repeatable reads but still allows phantom reads.</p>
    </div>
</div>
<div class="style2"> <b>Q7: How does the <code>@Version</code> annotation help with concurrency control in JPA?</b>
    <div class="answer">
      <p>The <code>@Version</code> annotation is used to implement optimistic locking in JPA. It marks a version field in the entity, and every time an update is made, the version number is incremented. If another transaction modifies the entity between reads and writes, an <code>OptimisticLockException</code> is thrown.</p>
      <pre><code>@Version
private int version;</code></pre>
    </div>
</div>
<div class="style2"> <b>Q8: What is an <code>OptimisticLockException</code> in JPA?</b>
    <div class="answer">
      <p><code>OptimisticLockException</code> is thrown when an update to an entity fails due to a version mismatch. This happens in optimistic locking scenarios when two transactions try to update the same entity concurrently, and one of them detects that the entity was modified by the other.</p>
    </div>
</div>
<div class="style2"> <b>Q9: How can you handle an <code>OptimisticLockException</code> in JPA?</b>
    <div class="answer">
      <p>You can handle an <code>OptimisticLockException</code> in JPA by catching it in a <code>try-catch</code> block and deciding how to respond, such as prompting the user to reload the data or retrying the operation.</p>
      <pre><code>try {
    // Update logic
} catch (OptimisticLockException e) {
    // Handle exception
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q10: What is the <code>javax.persistence.TransactionRequiredException</code> in JPA?</b>
    <div class="answer">
      <p><code>TransactionRequiredException</code> is thrown when an operation requiring a transaction is executed without an active transaction. This is common when you attempt to use the <code>EntityManager</code> outside the context of a transaction, like a non-transactional method.</p>
    </div>
</div>
<p class="style1">&nbsp;</p>
<h1 class="style1">Set 4 - Transactions &amp; Isolation Levels - JPA</h1>
<div class="style2"> <b>Q1: How can you set the isolation level in a Spring Data JPA repository?</b>
    <div class="answer">
      <p>In Spring Data JPA, you can set the isolation level using the <code>@Transactional</code> annotation with the <code>isolation</code> attribute, specifying the desired isolation level for methods in your repository.</p>
      <pre><code>@Transactional(isolation = Isolation.REPEATABLE_READ)
public void someMethod() {
    // Transaction logic
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q2: What happens if a transaction is not marked with <code>@Transactional</code> in a JPA application?</b>
    <div class="answer">
      <p>If a transaction is not marked with <code>@Transactional</code>, the method will run without transactional support. Any changes to the entity will not be committed, and no rollback will occur in case of errors.</p>
    </div>
</div>
<div class="style2"> <b>Q3: How can you ensure that a JPA method is executed in a single transaction?</b>
    <div class="answer">
      <p>You can ensure that a JPA method is executed in a single transaction by annotating the method with <code>@Transactional</code>. This ensures that all operations within the method are performed within the same transactional context.</p>
      <pre><code>@Transactional
public void performTransaction() {
    // Operations performed in a single transaction
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q4: What is the effect of <code>PROPAGATION_REQUIRES_NEW</code> on transactions in JPA?</b>
    <div class="answer">
      <p><code>PROPAGATION_REQUIRES_NEW</code> causes a new transaction to be started, suspending any existing transaction. This ensures that the current method operates in isolation from any existing transactions.</p>
    </div>
</div>
<div class="style2"> <b>Q5: How do you manage nested transactions in JPA?</b>
    <div class="answer">
      <p>In JPA, nested transactions can be managed using <code>@Transactional</code> with different propagation settings. By using <code>PROPAGATION_NESTED</code>, a nested transaction will be created. However, this is typically supported only by databases that support savepoints.</p>
    </div>
</div>
<div class="style2"> <b>Q6: What is the difference between <code>PROPAGATION_REQUIRED</code> and <code>PROPAGATION_SUPPORTS</code> in JPA?</b>
    <div class="answer">
      <p><code>PROPAGATION_REQUIRED</code> ensures that a new transaction is started if there isn't one already. If a transaction is already in progress, the existing transaction will be used. On the other hand, <code>PROPAGATION_SUPPORTS</code> allows the method to run with or without a transaction. If a transaction exists, it will be used; if not, no transaction is started.</p>
    </div>
</div>
<div class="style2"> <b>Q7: What is the purpose of the <code>@Transactional</code> annotation in Spring?</b>
    <div class="answer">
      <p>The <code>@Transactional</code> annotation in Spring is used to define the boundaries of a transaction. It ensures that a method runs within the scope of a transaction, handling commit and rollback automatically based on the outcome.</p>
    </div>
</div>
<div class="style2"> <b>Q8: What does the <code>@Transactional(readOnly = true)</code> annotation do in JPA?</b>
    <div class="answer">
      <p>The <code>@Transactional(readOnly = true)</code> annotation indicates that the method will not modify any entities, allowing for optimizations such as using a read-only database connection. It also prevents accidental modifications to the database within the scope of the transaction.</p>
    </div>
</div>
<div class="style2"> <b>Q9: What is the role of a <code>TransactionManager</code> in JPA?</b>
    <div class="answer">
      <p>A <code>TransactionManager</code> is responsible for managing the lifecycle of transactions in JPA. It coordinates the commit or rollback of a transaction, ensuring data consistency and integrity. In Spring, the <code>JpaTransactionManager</code> is commonly used.</p>
    </div>
</div>
<div class="style2"> <b>Q10: What is the <code>flush()</code> method used for in JPA?</b>
    <div class="answer">
      <p>The <code>flush()</code> method in JPA is used to synchronize the persistence context with the database. It forces any changes made to entities within the current persistence context to be persisted to the database, but it doesn't commit the transaction.</p>
      <pre><code>entityManager.flush();</code></pre>
    </div>
</div>
<p class="style1">&nbsp;</p>
<h1 class="style1">Set 5 - Transactions &amp; Isolation Levels - JPA</h1>
<div class="style2"> <b>Q1: How can you define the transaction isolation level in JPA?</b>
    <div class="answer">
      <p>In JPA, you can define the transaction isolation level using the <code>@Transactional</code> annotation by setting the <code>isolation</code> attribute to the desired isolation level, such as <code>Isolation.READ_COMMITTED</code> or <code>Isolation.SERIALIZABLE</code>.</p>
      <pre><code>@Transactional(isolation = Isolation.READ_COMMITTED)
public void someMethod() {
    // Transaction logic
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q2: What are the different types of isolation levels in JPA?</b>
    <div class="answer">
      <p>There are four standard isolation levels in JPA:</p>
      <ul>
        <li><b>Isolation.DEFAULT</b>: The default isolation level, typically <code>READ_COMMITTED</code> in most databases.</li>
        <li><b>Isolation.READ_UNCOMMITTED</b>: Allows dirty reads, where a transaction can read data that has not yet been committed by another transaction.</li>
        <li><b>Isolation.READ_COMMITTED</b>: Ensures that only committed data can be read by transactions, preventing dirty reads.</li>
        <li><b>Isolation.REPEATABLE_READ</b>: Ensures that data read by a transaction cannot be modified by another transaction before the first transaction is complete.</li>
        <li><b>Isolation.SERIALIZABLE</b>: The highest isolation level, where transactions are executed sequentially, ensuring complete isolation but potentially causing performance issues.</li>
      </ul>
    </div>
</div>
<div class="style2"> <b>Q3: How can you ensure that a method runs outside the scope of an existing transaction in JPA?</b>
    <div class="answer">
      <p>To ensure that a method runs outside the scope of an existing transaction, you can use <code>PROPAGATION_REQUIRES_NEW</code> in the <code>@Transactional</code> annotation. This creates a new transaction, suspending any existing transaction.</p>
      <pre><code>@Transactional(propagation = Propagation.REQUIRES_NEW)
public void someMethod() {
    // New transaction logic
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q4: What is the difference between <code>PROPAGATION_REQUIRED</code> and <code>PROPAGATION_REQUIRES_NEW</code>?</b>
    <div class="answer">
      <p><code>PROPAGATION_REQUIRED</code> ensures that a new transaction is started if there isn't one already. If an existing transaction exists, the method will participate in it. On the other hand, <code>PROPAGATION_REQUIRES_NEW</code> suspends the current transaction and starts a new one, ensuring complete isolation.</p>
    </div>
</div>
<div class="style2"> <b>Q5: What happens when you have multiple <code>@Transactional</code> annotations on the same method in JPA?</b>
    <div class="answer">
      <p>Having multiple <code>@Transactional</code> annotations on the same method will result in a conflict, and only the outermost annotation will be effective. The configuration from the innermost annotations will be ignored.</p>
    </div>
</div>
<div class="style2"> <b>Q6: What is the purpose of <code>TransactionSynchronizationManager</code> in JPA?</b>
    <div class="answer">
      <p><code>TransactionSynchronizationManager</code> is used to manage transaction synchronization in Spring. It allows you to check if there is an active transaction, bind resources to the current transaction, and register synchronization callbacks that will be executed when the transaction is committed or rolled back.</p>
    </div>
</div>
<div class="style2"> <b>Q7: How do you handle transaction rollback in JPA?</b>
    <div class="answer">
      <p>In JPA, a transaction is rolled back automatically if a runtime exception occurs. You can also manually trigger a rollback by setting <code>@Transactional(rollbackFor = Exception.class)</code> to specify which exceptions should trigger a rollback.</p>
      <pre><code>@Transactional(rollbackFor = Exception.class)
public void someMethod() throws Exception {
    // Perform operations
    if (someCondition) {
        throw new Exception(&quot;Trigger rollback&quot;);
    }
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q8: Can you nest transactions in JPA?</b>
    <div class="answer">
      <p>JPA does not support true nested transactions, but you can simulate them using savepoints with <code>PROPAGATION_NESTED</code>. However, this requires a database that supports savepoints. If the nested transaction fails, the parent transaction can be rolled back to the savepoint.</p>
    </div>
</div>
<div class="style2"> <b>Q9: How can you control the rollback behavior for specific exceptions in JPA?</b>
    <div class="answer">
      <p>In JPA, you can control the rollback behavior for specific exceptions using the <code>@Transactional</code> annotation's <code>rollbackFor</code> or <code>noRollbackFor</code> attributes. For example, to roll back only on <code>RuntimeException</code>, you can specify <code>@Transactional(rollbackFor = RuntimeException.class)</code>.</p>
    </div>
</div>
<div class="style2"> <b>Q10: What is the effect of setting <code>readOnly = true</code> in a <code>@Transactional</code> annotation in JPA?</b>
    <div class="answer">
      <p>Setting <code>readOnly = true</code> in a <code>@Transactional</code> annotation indicates that the transaction will not modify any data, which can lead to performance optimizations. The underlying database may avoid acquiring locks or performing other write-related operations.</p>
    </div>
</div>
<p class="style1">&nbsp;</p>
<h1 class="style1">Set 6 - Transactions &amp; Isolation Levels - JPA</h1>
<div class="style2"> <b>Q1: What is the role of the <code>@Transactional</code> annotation in JPA?</b>
    <div class="answer">
      <p>The <code>@Transactional</code> annotation is used to define the boundaries of a transaction in JPA. It ensures that a method is executed within a transaction context, automatically handling commit and rollback operations based on the outcome of the method.</p>
    </div>
</div>
<div class="style2"> <b>Q2: How can you control transaction timeouts in JPA?</b>
    <div class="answer">
      <p>Transaction timeouts can be set using the <code>@Transactional</code> annotation by specifying the <code>timeout</code> attribute. This defines the maximum time a transaction is allowed to run before it is automatically rolled back.</p>
      <pre><code>@Transactional(timeout = 30) // 30 seconds
public void someMethod() {
    // Transaction logic
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q3: How do you handle optimistic locking in JPA?</b>
    <div class="answer">
      <p>Optimistic locking is handled in JPA using the <code>@Version</code> annotation. The version field ensures that the entity is not concurrently modified by multiple transactions. When an entity is updated, the version value is checked to detect conflicts.</p>
      <pre><code>@Entity
public class Product {
    @Id
    private Long id;

    @Version
    private int version;

    // other fields and methods
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q4: How does JPA handle pessimistic locking?</b>
    <div class="answer">
      <p>Pessimistic locking in JPA can be achieved using <code>LockModeType.PESSIMISTIC_WRITE</code> or <code>LockModeType.PESSIMISTIC_READ</code> when executing queries. This prevents other transactions from modifying the data until the transaction completes.</p>
      <pre><code>entityManager.lock(entity, LockModeType.PESSIMISTIC_WRITE);</code></pre>
    </div>
</div>
<div class="style2"> <b>Q5: Can you override the default isolation level of a JPA provider?</b>
    <div class="answer">
      <p>Yes, the default isolation level can be overridden in JPA by specifying the desired isolation level in the <code>@Transactional</code> annotation. This setting is supported by most JPA providers like Hibernate.</p>
    </div>
</div>
<div class="style2"> <b>Q6: What happens if a transaction is rolled back in JPA?</b>
    <div class="answer">
      <p>If a transaction is rolled back, any changes made during the transaction are discarded, and the database returns to the state it was in before the transaction began. The rollback can be triggered by an exception or manually using <code>setRollbackOnly()</code>.</p>
    </div>
</div>
<div class="style2"> <b>Q7: What is the purpose of <code>setRollbackOnly()</code> in JPA?</b>
    <div class="answer">
      <p>The <code>setRollbackOnly()</code> method is used to mark a transaction for rollback, meaning that no matter what happens, the transaction will be rolled back when it ends. This is typically used when an exception occurs, but the transaction has already been partially executed.</p>
      <pre><code>TransactionStatus status = transactionManager.getTransaction();
status.setRollbackOnly();</code></pre>
    </div>
</div>
<div class="style2"> <b>Q8: How can you prevent a transaction from rolling back on a specific exception in JPA?</b>
    <div class="answer">
      <p>To prevent a transaction from rolling back on a specific exception, you can use the <code>noRollbackFor</code> attribute in the <code>@Transactional</code> annotation, specifying the exception type that should not trigger a rollback.</p>
      <pre><code>@Transactional(noRollbackFor = CustomException.class)
public void someMethod() {
    // Transaction logic
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q9: Can you configure JPA to automatically roll back a transaction on checked exceptions?</b>
    <div class="answer">
      <p>By default, JPA only rolls back transactions on unchecked exceptions (i.e., <code>RuntimeException</code> and its subclasses). To roll back on checked exceptions, you can use the <code>rollbackFor</code> attribute in the <code>@Transactional</code> annotation.</p>
    </div>
</div>
<div class="style2"> <b>Q10: What is the effect of using <code>readOnly=true</code> in the <code>@Transactional</code> annotation?</b>
    <div class="answer">
      <p>Setting <code>readOnly=true</code> in the <code>@Transactional</code> annotation informs the persistence provider that the transaction will only read data and will not perform any write operations. This can optimize performance, as the provider can skip certain database optimizations for writes.</p>
    </div>
</div>
<p class="style1">&nbsp;</p>
<h1 class="style1">Set 7 - Transactions &amp; Isolation Levels - JPA</h1>
<div class="style2"> <b>Q1: What are the different transaction propagation behaviors in JPA?</b>
    <div class="answer">
      <p>JPA provides several transaction propagation behaviors, such as <code>REQUIRED</code>, <code>REQUIRES_NEW</code>, <code>SUPPORTS</code>, <code>MANDATORY</code>, <code>NEVER</code>, and <code>NOSUPPORT</code>. These define how transactions are handled when a method is called inside an existing transaction or when no transaction exists.</p>
    </div>
</div>
<div class="style2"> <b>Q2: How do you configure isolation levels in JPA?</b>
    <div class="answer">
      <p>Isolation levels can be configured in JPA by specifying the desired level in the <code>@Transactional</code> annotation's <code>isolation</code> attribute. Common isolation levels include <code>READ_COMMITTED</code>, <code>READ_UNCOMMITTED</code>, <code>REPEATABLE_READ</code>, and <code>SERIALIZABLE</code>.</p>
      <pre><code>@Transactional(isolation = Isolation.READ_COMMITTED)
public void someMethod() {
    // Transaction logic
}</code></pre>
    </div>
</div>
<div class="style2"> <b>Q3: What is the difference between <code>REQUIRED</code> and <code>REQUIRES_NEW</code> propagation in JPA?</b>
    <div class="answer">
      <p><code>REQUIRED</code> propagation behavior means that if a transaction already exists, the method will join that transaction. If no transaction exists, a new one is started. <code>REQUIRES_NEW</code> creates a new transaction, suspending any existing transaction, and commits or rolls back independently of the outer transaction.</p>
    </div>
</div>
<div class="style2"> <b>Q4: What is the <code>TransactionSynchronizationManager</code> in JPA?</b>
    <div class="answer">
      <p>The <code>TransactionSynchronizationManager</code> is a utility class in Spring that allows you to retrieve and manage resources tied to a transaction, such as transaction attributes or data bound to the current transaction.</p>
    </div>
</div>
<div class="style2"> <b>Q5: What is the default isolation level in JPA?</b>
    <div class="answer">
      <p>The default isolation level in JPA depends on the underlying database, but it is typically set to <code>READ_COMMITTED</code>, which allows dirty reads to be avoided while allowing non-repeatable reads and phantom reads.</p>
    </div>
</div>
<div class="style2"> <b>Q6: Can you use optimistic locking with JPA?</b>
    <div class="answer">
      <p>Yes, optimistic locking can be used in JPA by annotating a version field with <code>@Version</code>. This ensures that when an entity is updated, its version is checked, and an exception is thrown if another transaction has modified the entity in the meantime.</p>
      <pre><code>@Version
private int version;</code></pre>
    </div>
</div>
<div class="style2"> <b>Q7: How can you handle concurrency control in JPA?</b>
    <div class="answer">
      <p>Concurrency control in JPA can be handled by using either optimistic locking or pessimistic locking. Optimistic locking uses a version column to check for data consistency, while pessimistic locking uses database locks to prevent concurrent access to the data.</p>
    </div>
</div>
<div class="style2"> <b>Q8: What happens if two transactions update the same entity with optimistic locking?</b>
    <div class="answer">
      <p>If two transactions attempt to update the same entity with optimistic locking, the second transaction will throw a <code>javax.persistence.OptimisticLockException</code> when it tries to commit, indicating that the version check has failed.</p>
    </div>
</div>
<div class="style2"> <b>Q9: How can you use <code>LockModeType.PESSIMISTIC_WRITE</code> in JPA?</b>
    <div class="answer">
      <p><code>LockModeType.PESSIMISTIC_WRITE</code> is used to acquire a write lock on an entity, preventing other transactions from accessing the entity for updates. This is useful in scenarios where you need exclusive access to the data.</p>
      <pre><code>entityManager.lock(entity, LockModeType.PESSIMISTIC_WRITE);</code></pre>
    </div>
</div>
<div class="style2"> <b>Q10: What is the effect of setting <code>rollbackFor</code> in <code>@Transactional</code>?</b>
    <div class="answer">
      <p>Setting the <code>rollbackFor</code> attribute in <code>@Transactional</code> allows you to specify which exceptions should trigger a rollback. By default, JPA rolls back on unchecked exceptions, but you can configure it to roll back on specific checked exceptions as well.</p>
      <pre><code>@Transactional(rollbackFor = CustomException.class)
public void someMethod() {
    // Transaction logic
}</code></pre>
    </div>
</div>
<p class="style1">&nbsp;</p>
<h1 class="style1">Set 8 - Transactions &amp; Isolation Levels - JPA</h1>
<div class="style2"> <b>Q1: What is the purpose of the <code>@Transactional</code> annotation in JPA?</b>
    <div class="answer">
      <p>The <code>@Transactional</code> annotation in JPA is used to define the transactional boundaries for a method or class. It ensures that all database operations within the scope of the annotated method are executed as a single unit of work, with automatic commit or rollback depending on the outcome.</p>
    </div>
</div>
<div class="style2"> <b>Q2: How do you configure transaction management in a Spring-based JPA application?</b>
    <div class="answer">
      <p>In a Spring-based JPA application, transaction management can be configured by enabling annotation-driven transaction management using <code>@EnableTransactionManagement</code> in a configuration class. Additionally, a <code>DataSource</code>, <code>EntityManagerFactory</code>, and <code>PlatformTransactionManager</code> need to be set up in the Spring context.</p>
    </div>
</div>
<div class="style2"> <b>Q3: What is the <code>propagation</code> attribute in the <code>@Transactional</code> annotation?</b>
    <div class="answer">
      <p>The <code>propagation</code> attribute in the <code>@Transactional</code> annotation specifies how transactions should behave in relation to existing transactions. For example, <code>Propagation.REQUIRED</code> means that the method will join an existing transaction or create a new one if none exists.</p>
    </div>
</div>
<div class="style2"> <b>Q4: How can you enable nested transactions in JPA?</b>
    <div class="answer">
      <p>Nested transactions can be achieved using <code>Propagation.NESTED</code> in the <code>@Transactional</code> annotation. This allows the inner transaction to be committed or rolled back independently of the outer transaction, providing finer control over the transaction boundaries.</p>
    </div>
</div>
<div class="style2"> <b>Q5: What is the difference between <code>REPEATABLE_READ</code> and <code>SERIALIZABLE</code> isolation levels?</b>
    <div class="answer">
      <p><code>REPEATABLE_READ</code> ensures that if a transaction reads a value, that value will remain the same throughout the transaction, but phantom reads can still occur. In contrast, <code>SERIALIZABLE</code> is the highest isolation level, ensuring that no other transactions can read or write to the data being accessed, thus preventing phantom reads as well.</p>
    </div>
</div>
<div class="style2"> <b>Q6: What happens if you use <code>LockModeType.PESSIMISTIC_READ</code> in JPA?</b>
    <div class="answer">
      <p><code>LockModeType.PESSIMISTIC_READ</code> acquires a shared lock on the entity, meaning other transactions can read the entity but cannot update or delete it. This prevents dirty reads and ensures the data is consistent during the transaction, though other transactions can still read the data.</p>
    </div>
</div>
<div class="style2"> <b>Q7: How do you handle transactions in a JPA repository?</b>
    <div class="answer">
      <p>Transactions in a JPA repository are typically handled by using the <code>@Transactional</code> annotation at the service layer. The repository methods do not directly handle transactions, but they participate in transactions defined by the service layer. The transaction is automatically committed or rolled back based on the outcome.</p>
    </div>
</div>
<div class="style2"> <b>Q8: What is the <code>Isolation.DEFAULT</code> setting in JPA?</b>
    <div class="answer">
      <p><code>Isolation.DEFAULT</code> indicates that the transaction will use the default isolation level of the underlying database. Most databases default to <code>READ_COMMITTED</code>, but this may vary depending on the database's configuration.</p>
    </div>
</div>
<div class="style2"> <b>Q9: How do you set up pessimistic locking in JPA?</b>
    <div class="answer">
      <p>Pessimistic locking can be set up in JPA using <code>LockModeType.PESSIMISTIC_WRITE</code> or <code>LockModeType.PESSIMISTIC_READ</code> in the <code>EntityManager.lock()</code> method to acquire a lock on an entity. This prevents other transactions from accessing the entity until the lock is released.</p>
      <pre><code>entityManager.lock(entity, LockModeType.PESSIMISTIC_WRITE);</code></pre>
    </div>
</div>
<div class="style2"> <b>Q10: What is the difference between optimistic and pessimistic locking in JPA?</b>
    <div class="answer">
      <p>Optimistic locking assumes that conflicts are rare and allows multiple transactions to read and update the same entity. It uses a version column to detect conflicts. Pessimistic locking, on the other hand, locks the entity to prevent other transactions from reading or modifying it, ensuring exclusive access.</p>
    </div>
</div>
<p class="style1">&nbsp;</p>
<h1 class="style1">Set 9 - Transactions &amp; Isolation Levels - JPA</h1>
<div class="style2"> <b>Q1: What is the role of the <code>Version</code> field in JPA?</b>
    <div class="answer">
      <p>The <code>Version</code> field in JPA is used for optimistic locking. It ensures that if a concurrent transaction modifies an entity, the version number will be incremented, and a conflict will be detected during the transaction. If the version numbers do not match, an <code>OptimisticLockException</code> is thrown.</p>
    </div>
</div>
<div class="style2"> <b>Q2: How do you configure a version field for optimistic locking in JPA?</b>
    <div class="answer">
      <p>You configure a version field in JPA by using the <code>@Version</code> annotation on a field in the entity. This field is automatically managed by JPA to track the version of the entity and help detect conflicts in concurrent updates.</p>
      <pre><code>@Version private int version;</code></pre>
    </div>
</div>
<div class="style2"> <b>Q3: What happens if two transactions try to update the same entity with optimistic locking?</b>
    <div class="answer">
      <p>If two transactions try to update the same entity, the second transaction will fail if it attempts to update the entity after the first transaction has committed. JPA will throw an <code>OptimisticLockException</code> to indicate a version conflict, preventing the second transaction from overwriting the changes made by the first.</p>
    </div>
</div>
<div class="style2"> <b>Q4: What is the <code>rollbackFor</code> attribute in the <code>@Transactional</code> annotation?</b>
    <div class="answer">
      <p>The <code>rollbackFor</code> attribute in the <code>@Transactional</code> annotation specifies which exceptions should trigger a rollback of the transaction. By default, only unchecked exceptions (<code>RuntimeException</code>) cause a rollback, but you can specify additional exceptions to trigger a rollback.</p>
    </div>
</div>
<div class="style2"> <b>Q5: What is the <code>timeout</code> attribute in the <code>@Transactional</code> annotation?</b>
    <div class="answer">
      <p>The <code>timeout</code> attribute in the <code>@Transactional</code> annotation defines the maximum time (in seconds) a transaction is allowed to run. If the transaction exceeds this time limit, it is automatically rolled back.</p>
    </div>
</div>
<div class="style2"> <b>Q6: What is a <code>TransactionRequiredException</code> in JPA?</b>
    <div class="answer">
      <p>A <code>TransactionRequiredException</code> is thrown when an operation that requires an active transaction is performed, but no transaction is available. This exception typically occurs when a method that requires transaction management is called outside of a transactional context.</p>
    </div>
</div>
<div class="style2"> <b>Q7: How do you manually begin, commit, and roll back a transaction in JPA?</b>
    <div class="answer">
      <p>In JPA, you can manually manage transactions using the <code>EntityTransaction</code> interface. Use the <code>begin()</code> method to start a transaction, <code>commit()</code> to commit it, and <code>rollback()</code> to roll back the transaction if an error occurs.</p>
      <pre><code>EntityTransaction transaction = entityManager.getTransaction();
transaction.begin();
transaction.commit();</code></pre>
    </div>
</div>
<div class="style2"> <b>Q8: How do you configure a custom isolation level for a transaction in JPA?</b>
    <div class="answer">
      <p>JPA allows you to set a custom isolation level using the <code>@Transactional</code> annotation with the <code>isolation</code> attribute. For example, you can set <code>Isolation.READ_COMMITTED</code> or <code>Isolation.SERIALIZABLE</code> to control the transaction isolation behavior.</p>
      <pre><code>@Transactional(isolation = Isolation.READ_COMMITTED)</code></pre>
    </div>
</div>
<div class="style2"> <b>Q9: How does the <code>flush</code> method work in JPA?</b>
    <div class="answer">
      <p>The <code>flush</code> method in JPA forces the synchronization of the persistence context with the underlying database. It ensures that any changes made to entities are written to the database, but it does not commit the transaction. A <code>flush</code> can be invoked manually to ensure that pending changes are persisted.</p>
      <pre><code>entityManager.flush();</code></pre>
    </div>
</div>
<div class="style2"> <b>Q10: How do you handle transaction propagation for a service layer in JPA?</b>
    <div class="answer">
      <p>Transaction propagation in JPA can be handled using the <code>@Transactional</code> annotation at the service layer. The <code>propagation</code> attribute can control how a transaction behaves when an existing transaction is present. Common values include <code>REQUIRED</code> (join an existing transaction or create a new one) and <code>REQUIRES_NEW</code> (suspend the current transaction and start a new one).</p>
    </div>
</div>
<h1 class="style1">Set 10 - Transactions &amp; Isolation Levels - JPA</h1>
<div class="style2"> <b>Q1: What is the purpose of using <code>@Transactional</code> in Spring JPA?</b>
    <div class="answer">
      <p>The <code>@Transactional</code> annotation is used to manage transaction boundaries in Spring JPA. It ensures that a method is executed within a transactional context, and it automatically handles transaction commit or rollback depending on whether an exception is thrown.</p>
    </div>
</div>
<div class="style2"> <b>Q2: What happens when a method annotated with <code>@Transactional</code> throws a runtime exception?</b>
    <div class="answer">
      <p>If a method annotated with <code>@Transactional</code> throws a runtime exception, the transaction will automatically be rolled back. This is the default behavior of Spring's transaction management.</p>
    </div>
</div>
<div class="style2"> <b>Q3: Can <code>@Transactional</code> be applied to multiple methods in the same class?</b>
    <div class="answer">
      <p>Yes, <code>@Transactional</code> can be applied to multiple methods in the same class. It will ensure that each method has its own transactional boundary, and the transactions will behave independently unless combined within a larger context.</p>
    </div>
</div>
<div class="style2"> <b>Q4: What is the default isolation level in JPA when using <code>@Transactional</code>?</b>
    <div class="answer">
      <p>The default isolation level in JPA when using <code>@Transactional</code> is <code>Isolation.DEFAULT</code>, which means that the underlying database's default isolation level will be used. In most databases, this is typically <code>READ_COMMITTED</code>.</p>
    </div>
</div>
<div class="style2"> <b>Q5: What does the <code>Isolation.READ_UNCOMMITTED</code> isolation level do?</b>
    <div class="answer">
      <p>The <code>Isolation.READ_UNCOMMITTED</code> isolation level allows dirty reads, meaning that a transaction can read data that has been modified by another transaction but not yet committed. This can lead to inconsistencies, so it is rarely used in practice.</p>
    </div>
</div>
<div class="style2"> <b>Q6: How do you use <code>@Transactional</code> with a custom propagation setting?</b>
    <div class="answer">
      <p>You can specify a custom propagation behavior in the <code>@Transactional</code> annotation by using the <code>propagation</code> attribute. Common propagation types include <code>REQUIRED</code>, <code>REQUIRES_NEW</code>, and <code>SUPPORTS</code>.</p>
      <pre><code>@Transactional(propagation = Propagation.REQUIRES_NEW)</code></pre>
    </div>
</div>
<div class="style2"> <b>Q7: What does <code>PROPAGATION_REQUIRES_NEW</code> do?</b>
    <div class="answer">
      <p><code>PROPAGATION_REQUIRES_NEW</code> creates a new transaction, suspending any existing transaction. This ensures that the current method runs in a new transaction, independent of any previous transactions that may be in progress.</p>
    </div>
</div>
<div class="style2"> <b>Q8: What is the difference between <code>READ_COMMITTED</code> and <code>READ_UNCOMMITTED</code> isolation levels?</b>
    <div class="answer">
      <p><code>READ_COMMITTED</code> prevents dirty reads, meaning that a transaction cannot read data that has been modified by another uncommitted transaction. In contrast, <code>READ_UNCOMMITTED</code> allows dirty reads, where one transaction can read uncommitted data from another transaction, which can lead to inconsistencies.</p>
    </div>
</div>
<div class="style2"> <b>Q9: Can you nest transactions in JPA?</b>
    <div class="answer">
      <p>Yes, you can nest transactions in JPA, but the behavior depends on the transaction propagation settings. By default, nested transactions will share the same transaction unless you explicitly specify a different propagation setting like <code>REQUIRES_NEW</code>.</p>
    </div>
</div>
<div class="style2"> <b>Q10: What is the <code>@TransactionAttribute</code> annotation used for in JPA?</b>
    <div class="answer">
      <p><code>@TransactionAttribute</code> is used in EJB (Enterprise JavaBeans) for specifying the transaction behavior for a method. It is similar to the <code>@Transactional</code> annotation in Spring, allowing you to configure the isolation level, propagation, and other transaction-related attributes for EJB methods.</p>
    </div>
</div>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
<p class="style1">&nbsp;</p>
</body>
</html>
