<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dependency Injection in .NET Core Overview and Interview Questions</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        h1, h2 {
            color: #333;
        }
        h2 {
            margin-top: 20px;
        }
        p {
            margin-bottom: 10px;
        }
        ol {
            list-style-type: decimal;
            margin-left: 20px;
        }
        li {
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <h1>Dependency Injection in .NET Core Overview</h1>

    <p>Dependency Injection (DI) in .NET Core is a design pattern and a technique for achieving Inversion of Control (IoC) in which a class receives its dependencies from an external entity rather than creating them itself. .NET Core provides a built-in DI container that simplifies the management and injection of dependencies in applications.</p>

    <h2>Key Concepts</h2>

    <p><strong>1. Service:</strong> A service is a class or a component that provides functionality to other parts of the application. Services are typically registered with the DI container.</p>

    <p><strong>2. Dependency Injection Container:</strong> The DI container is responsible for managing the lifetime and resolution of services. It tracks dependencies and injects them into the dependent classes when requested.</p>

    <p><strong>3. Registration:</strong> Registration involves informing the DI container about the services and their dependencies. In .NET Core, registration is often done in the <code>Startup</code> class.</p>

    <p><strong>4. Dependency Injection:</strong> Dependency injection is the process of providing a service to a class or a component. It allows classes to use services without creating instances themselves.</p>

    <h2>Technical Interview Questions</h2>

    <ol>
        <li>
            <strong>What is Dependency Injection?</strong>
            <p>Dependency Injection is a design pattern and a technique for achieving Inversion of Control (IoC) in which a class receives its dependencies from an external entity rather than creating them itself.</p>
        </li>
        <li>
            <strong>How does Dependency Injection differ from Inversion of Control?</strong>
            <p>Dependency Injection is a specific implementation of Inversion of Control. In IoC, the control flow is inverted, and dependencies are managed by an external entity. Dependency Injection is a way to achieve IoC by injecting dependencies into a class.</p>
        </li>
        <li>
            <strong>Explain the benefits of using Dependency Injection in .NET Core.</strong>
            <p>Dependency Injection in .NET Core promotes modular and testable code by allowing classes to use services without creating instances themselves. It also simplifies the management of dependencies and improves the maintainability of the codebase.</p>
        </li>
        <li>
            <strong>What is a Service in the context of Dependency Injection?</strong>
            <p>A service in the context of Dependency Injection is a class or a component that provides functionality to other parts of the application. Services are typically registered with the DI container.</p>
        </li>
        <li>
            <strong>Explain the role of the Dependency Injection Container in .NET Core.</strong>
            <p>The Dependency Injection Container in .NET Core is responsible for managing the lifetime and resolution of services. It tracks dependencies and injects them into the dependent classes when requested.</p>
        </li>
        <li>
            <strong>How are services registered with the Dependency Injection Container in .NET Core?</strong>
            <p>Services are registered with the Dependency Injection Container in .NET Core using the <code>ConfigureServices</code> method in the <code>Startup</code> class. Registration includes specifying the service type, implementation, and lifetime.</p>
        </li>
        <li>
            <strong>What is the difference between Singleton and Transient service lifetimes?</strong>
            <p>In Singleton lifetime, a single instance of the service is created and shared across the entire application. In Transient lifetime, a new instance is created every time the service is requested.</p>
        </li>
        <li>
            <strong>Explain Constructor Injection in Dependency Injection.</strong>
            <p>Constructor Injection is a form of Dependency Injection where dependencies are provided to a class through its constructor. This is the most common and recommended way to inject dependencies.</p>
        </li>
        <li>
            <strong>What are the common ways to inject dependencies in .NET Core?</strong>
            <p>The common ways to inject dependencies in .NET Core are Constructor Injection, Property Injection, and Method Injection. Constructor Injection is the most widely used and recommended approach.</p>
        </li>
        <li>
            <strong>What is the purpose of the <code>[FromServices]</code> attribute in ASP.NET Core?</strong>
            <p>The <code>[FromServices]</code> attribute in ASP.NET Core is used for parameter binding in action methods. It signals the framework to provide the parameter value from the dependency injection container.</p>
        </li>
        <li>
            <strong>How is circular dependency handled in Dependency Injection?</strong>
            <p>Circular dependency occurs when two or more services depend on each other. In .NET Core, circular dependencies can be resolved using Lazy Initialization or by refactoring the code to eliminate the circular relationship.</p>
        </li>
        <li>
            <strong>What is the purpose of the <code>IServiceProvider</code> interface in .NET Core?</strong>
            <p>The <code>IServiceProvider</code> interface in .NET Core represents the DI container and provides methods for retrieving services. It is used for manual service resolution when necessary.</p>
        </li>
        <li>
            <strong>Explain the concept of Scoped service lifetime in .NET Core.</strong>
            <p>Scoped service lifetime in .NET Core means that a new instance of the service is created for each scope. In the context of a web application, a scope corresponds to an HTTP request, ensuring that services are scoped to the request.</p>
        </li>
        <li>
            <strong>What is the purpose of the <code>IServiceScope</code> interface in .NET Core?</strong>
            <p>The <code>IServiceScope</code> interface in .NET Core represents a scope in which services are created and managed. It is used to create and release services within a specific scope, such as an HTTP request.</p>
        </li>
        <li>
            <strong>Explain the difference between <code>AddSingleton</code> and <code>AddScoped</code> methods in service registration.</strong>
            <p><code>AddSingleton</code> registers a service with a Singleton lifetime, creating a single instance shared across the entire application. <code>AddScoped</code> registers a service with a Scoped lifetime, creating a new instance for each scope (e.g., each HTTP request).</p>
        </li>
        <li>
            <strong>What is the purpose of the <code>[Inject]</code> attribute in Blazor?</strong>
            <p>The <code>[Inject]</code> attribute in Blazor is used for dependency injection in Blazor components. It signals the framework to inject the specified service or dependency into the component.</p>
        </li>
        <li>
            <strong>How can you achieve named or keyed dependencies in .NET Core?</strong>
            <p>In .NET Core, named or keyed dependencies can be achieved by using the <code>named</code> parameter when registering services. The <code>named</code> parameter allows associating a specific instance with a unique name or key.</p>
        </li>
        <li>
            <strong>Explain the concept of Interception in Dependency Injection.</strong>
            <p>Interception in Dependency Injection involves intercepting method calls or property access on a service to add additional behavior. It can be used for logging, caching, or other cross-cutting concerns.</p>
        </li>
        <li>
            <strong>What is the purpose of the <code>TryAdd</code> methods in service registration?</strong>
            <p>The <code>TryAdd</code> methods in service registration attempt to add a service to the container only if it hasn't been registered previously. These methods are useful for avoiding duplicate registrations.</p>
        </li>
        <li>
            <strong>Explain the concept of Decorators in Dependency Injection.</strong>
            <p>Decorators in Dependency Injection involve wrapping a service with another service that provides additional or modified behavior. Decorators are a way to extend or alter the functionality of existing services without modifying their code.</p>
        </li>
        <li>
            <strong>What is the purpose of the <code>Options pattern</code> in .NET Core Dependency Injection?</strong>
            <p>The Options pattern in .NET Core Dependency Injection is used for configuring and accessing strongly-typed settings or options. It allows services to depend on an options class, providing a clean way to configure application settings.</p>
        </li>
        <li>
            <strong>How does .NET Core handle disposal of services with scoped and transient lifetimes?</strong>
            <p>In .NET Core, services with scoped and transient lifetimes are automatically disposed of when the scope or request ends. The DI container manages the disposal of these services, ensuring proper resource cleanup.</p>
        </li>
        <li>
            <strong>Explain the concept of Service Lifetime in Dependency Injection.</strong>
            <p>Service Lifetime in Dependency Injection refers to the duration for which a service instance is available. The common lifetimes in .NET Core are Singleton (shared across the entire application), Scoped (created for each scope, e.g., each HTTP request), and Transient (created every time the service is requested).</p>
        </li>
    </ol>

</body>
</html>
